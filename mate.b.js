
/* @license
Mate
https://github.com/zhanzhenzhen/mate
Copyright 2014 Zhenzhen Zhan
Released under the MIT license
*/

// This wrapper is to prevent global variable assignments. It's not to
// prevent naming conflicts ("386389655257694535" already does), but to
// work better with minification tools.
(function() {
    // `{}` is to guarantee that any subsequent `mod.result` assignment will make
    // the variable different from the initial value.
    var initialModResult_386389655257694535 = {};

    var mods_386389655257694535 = [
    {
fun: function(exports, module, require) {

// Generated by CoffeeScript 1.8.0
(function() {
  var ArrayLazyWrapper, mate, wishlist,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  wishlist = require("wishlist");

  mate = {};

  mate.packageInfo = require("./package.json");

  mate.environmentType = ((typeof process !== "undefined" && process !== null ? process.execPath : void 0) != null) && typeof process.execPath === "string" && process.execPath.search(/node/i) !== -1 ? "node" : (typeof window !== "undefined" && window !== null) && (typeof navigator !== "undefined" && navigator !== null) && (typeof HTMLElement !== "undefined" && HTMLElement !== null) ? "browser" : void 0;

  if (mate.environmentType === "browser") {
    window.global = window;
  }

  global.npmMate = mate;

  ArrayLazyWrapper = (function() {
    function ArrayLazyWrapper(value, chainToCopy, itemToPush) {
      this._value = value;
      this._chain = (chainToCopy != null ? chainToCopy : []).slice(0);
      if (itemToPush != null) {
        this._chain.push(itemToPush);
      }
      Object.getter(this, "length", (function(_this) {
        return function() {
          return _this.force().length;
        };
      })(this));
    }

    ArrayLazyWrapper.prototype.force = function() {
      var m, n, _i, _len, _ref;
      n = this._value;
      _ref = this._chain;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        m = _ref[_i];
        n = m.fun.apply(n, m.args);
      }
      return n;
    };

    ArrayLazyWrapper.prototype.map = function() {
      return this._pushChain(Array.prototype.map, arguments);
    };

    ArrayLazyWrapper.prototype.filter = function() {
      return this._pushChain(Array.prototype.filter, arguments);
    };

    ArrayLazyWrapper.prototype.concat = function() {
      return this._pushChain(Array.prototype.concat, arguments);
    };

    ArrayLazyWrapper.prototype.portion = function() {
      return this._pushChain(Array.prototype.portion, arguments);
    };

    ArrayLazyWrapper.prototype.funSort = function() {
      return this._pushChain(Array.prototype.funSort, arguments);
    };

    ArrayLazyWrapper.prototype.funSortDescending = function() {
      return this._pushChain(Array.prototype.funSortDescending, arguments);
    };

    ArrayLazyWrapper.prototype.funReverse = function() {
      return this._pushChain(Array.prototype.funReverse, arguments);
    };

    ArrayLazyWrapper.prototype.except = function() {
      return this._pushChain(Array.prototype.except, arguments);
    };

    ArrayLazyWrapper.prototype.group = function() {
      return this._pushChain(Array.prototype.group, arguments);
    };

    ArrayLazyWrapper.prototype.flatten = function() {
      return this._pushChain(Array.prototype.flatten, arguments);
    };

    ArrayLazyWrapper.prototype.random = function() {
      return this._pushChain(Array.prototype.random, arguments);
    };

    ArrayLazyWrapper.prototype.some = function() {
      return this._unwrapAndDo(Array.prototype.some, arguments);
    };

    ArrayLazyWrapper.prototype.every = function() {
      return this._unwrapAndDo(Array.prototype.every, arguments);
    };

    ArrayLazyWrapper.prototype.isEmpty = function() {
      return this._unwrapAndDo(Array.prototype.isEmpty, arguments);
    };

    ArrayLazyWrapper.prototype.at = function() {
      return this._unwrapAndDo(Array.prototype.at, arguments);
    };

    ArrayLazyWrapper.prototype.atOrNull = function() {
      return this._unwrapAndDo(Array.prototype.atOrNull, arguments);
    };

    ArrayLazyWrapper.prototype.contains = function() {
      return this._unwrapAndDo(Array.prototype.contains, arguments);
    };

    ArrayLazyWrapper.prototype.first = function() {
      return this._unwrapAndDo(Array.prototype.first, arguments);
    };

    ArrayLazyWrapper.prototype.firstOrNull = function() {
      return this._unwrapAndDo(Array.prototype.firstOrNull, arguments);
    };

    ArrayLazyWrapper.prototype.last = function() {
      return this._unwrapAndDo(Array.prototype.last, arguments);
    };

    ArrayLazyWrapper.prototype.lastOrNull = function() {
      return this._unwrapAndDo(Array.prototype.lastOrNull, arguments);
    };

    ArrayLazyWrapper.prototype.single = function() {
      return this._unwrapAndDo(Array.prototype.single, arguments);
    };

    ArrayLazyWrapper.prototype.singleOrNull = function() {
      return this._unwrapAndDo(Array.prototype.singleOrNull, arguments);
    };

    ArrayLazyWrapper.prototype.withMax = function() {
      return this._unwrapAndDo(Array.prototype.withMax, arguments);
    };

    ArrayLazyWrapper.prototype.withMin = function() {
      return this._unwrapAndDo(Array.prototype.withMin, arguments);
    };

    ArrayLazyWrapper.prototype.max = function() {
      return this._unwrapAndDo(Array.prototype.max, arguments);
    };

    ArrayLazyWrapper.prototype.min = function() {
      return this._unwrapAndDo(Array.prototype.min, arguments);
    };

    ArrayLazyWrapper.prototype.sum = function() {
      return this._unwrapAndDo(Array.prototype.sum, arguments);
    };

    ArrayLazyWrapper.prototype.average = function() {
      return this._unwrapAndDo(Array.prototype.average, arguments);
    };

    ArrayLazyWrapper.prototype.median = function() {
      return this._unwrapAndDo(Array.prototype.median, arguments);
    };

    ArrayLazyWrapper.prototype.product = function() {
      return this._unwrapAndDo(Array.prototype.product, arguments);
    };

    ArrayLazyWrapper.prototype.randomOne = function() {
      return this._unwrapAndDo(Array.prototype.randomOne, arguments);
    };

    ArrayLazyWrapper.prototype._pushChain = function(fun, args) {
      return new ArrayLazyWrapper(this._value, this._chain, {
        fun: fun,
        args: args
      });
    };

    ArrayLazyWrapper.prototype._unwrapAndDo = function(fun, args) {
      return fun.apply(this.force(), args);
    };

    return ArrayLazyWrapper;

  })();

  Array._elementOrUseSelector = function(element, selector) {
    if (selector != null) {
      return selector(element);
    } else {
      return element;
    }
  };

  Array.prototype._numberToIndex = function(pos) {
    if ((0 < pos && pos < 1)) {
      return pos = Math.round(pos * (this.length - 1));
    } else {
      return pos;
    }
  };

  Array.prototype._numberToLength = function(pos) {
    if ((0 < pos && pos < 1)) {
      return pos = Math.round(pos * this.length);
    } else {
      return pos;
    }
  };

  Array.prototype.clone = function() {
    return this.slice(0);
  };

  Array.prototype.isEmpty = function() {
    return this.length === 0;
  };

  Array.prototype.lazy = function() {
    return new ArrayLazyWrapper(this);
  };

  Array.prototype.portion = function(startIndex, length, endIndex) {
    if (Number.isFraction(startIndex) || Number.isFraction(length) || Number.isFraction(endIndex)) {
      if (startIndex === 0) {
        startIndex = 0 + Number.EPSILON;
      }
      if (startIndex === 1) {
        startIndex = 1 - Number.EPSILON;
      }
      if (length === 0) {
        length = 0 + Number.EPSILON;
      }
      if (length === 1) {
        length = 1 - Number.EPSILON;
      }
      if (endIndex === 0) {
        endIndex = 0 + Number.EPSILON;
      }
      if (endIndex === 1) {
        endIndex = 1 - Number.EPSILON;
      }
    }
    startIndex = this._numberToIndex(startIndex);
    length = this._numberToLength(length);
    endIndex = this._numberToIndex(endIndex);
    return this.slice(startIndex, length != null ? startIndex + length : endIndex + 1);
  };

  Array.prototype.at = function(index) {
    index = this._numberToIndex(index);
    assert((0 <= index && index < this.length));
    return this[index];
  };

  Array.prototype.atOrNull = function(index) {
    try {
      return this.at(index);
    } catch (_error) {
      return null;
    }
  };

  Array.prototype.contains = function(value) {
    return __indexOf.call(this, value) >= 0;
  };

  Array.prototype.first = function(predicate) {
    var queryResult;
    queryResult = predicate != null ? this.filter(predicate) : this;
    return queryResult.at(0);
  };

  Array.prototype.firstOrNull = function(predicate) {
    try {
      return this.first(predicate);
    } catch (_error) {
      return null;
    }
  };

  Array.prototype.last = function(predicate) {
    var queryResult;
    queryResult = predicate != null ? this.filter(predicate) : this;
    return queryResult.at(queryResult.length - 1);
  };

  Array.prototype.lastOrNull = function(predicate) {
    try {
      return this.last(predicate);
    } catch (_error) {
      return null;
    }
  };

  Array.prototype.single = function(predicate) {
    var queryResult;
    queryResult = predicate != null ? this.filter(predicate) : this;
    assert(queryResult.length === 1);
    return queryResult.at(0);
  };

  Array.prototype.singleOrNull = function(predicate) {
    try {
      return this.single(predicate);
    } catch (_error) {
      return null;
    }
  };

  Array.prototype.withMax = function(selector) {
    return this.reduce((function(_this) {
      return function(a, b, index) {
        if (Array._elementOrUseSelector(a, selector) > Array._elementOrUseSelector(b, selector)) {
          return a;
        } else {
          return b;
        }
      };
    })(this));
  };

  Array.prototype.withMin = function(selector) {
    return this.reduce((function(_this) {
      return function(a, b, index) {
        if (Array._elementOrUseSelector(a, selector) < Array._elementOrUseSelector(b, selector)) {
          return a;
        } else {
          return b;
        }
      };
    })(this));
  };

  Array.prototype.max = function(selector) {
    return Array._elementOrUseSelector(this.withMax(selector), selector);
  };

  Array.prototype.min = function(selector) {
    return Array._elementOrUseSelector(this.withMin(selector), selector);
  };

  Array.prototype.sum = function(selector) {
    if (this.length === 1) {
      return Array._elementOrUseSelector(this.first(), selector);
    } else {
      return this.reduce((function(_this) {
        return function(a, b, index) {
          return (index === 1 ? Array._elementOrUseSelector(a, selector) : a) + Array._elementOrUseSelector(b, selector);
        };
      })(this));
    }
  };

  Array.prototype.average = function(selector) {
    return this.sum(selector) / this.length;
  };

  Array.prototype.median = function(selector) {
    var a, b, m, n, sorted;
    sorted = this.funSort(selector);
    a = sorted.at(0.5 - Number.EPSILON);
    b = sorted.at(0.5 + Number.EPSILON);
    m = Array._elementOrUseSelector(a, selector);
    n = Array._elementOrUseSelector(b, selector);
    return (m + n) / 2;
  };

  Array.prototype.product = function(selector) {
    if (this.length === 1) {
      return Array._elementOrUseSelector(this.first(), selector);
    } else {
      return this.reduce((function(_this) {
        return function(a, b, index) {
          return (index === 1 ? Array._elementOrUseSelector(a, selector) : a) * Array._elementOrUseSelector(b, selector);
        };
      })(this));
    }
  };

  Array.prototype.group = function(keySelector, valueSelector) {
    var comparedKey, elements, key, m, results, sorted, _i, _len;
    if (this.isEmpty()) {
      return [];
    }
    sorted = this.funSort(keySelector);
    results = [];
    comparedKey = Array._elementOrUseSelector(sorted.first(), keySelector);
    elements = [];
    for (_i = 0, _len = sorted.length; _i < _len; _i++) {
      m = sorted[_i];
      key = Array._elementOrUseSelector(m, keySelector);
      if (key !== comparedKey) {
        results.push([comparedKey, Array._elementOrUseSelector(elements, valueSelector)]);
        comparedKey = key;
        elements = [];
      }
      elements.push(m);
    }
    results.push([comparedKey, Array._elementOrUseSelector(elements, valueSelector)]);
    return results;
  };

  Array.prototype._sort = function(keySelector, isDescending) {
    return this.clone().sort((function(_this) {
      return function(a, b) {
        var a1, b1;
        a1 = Array._elementOrUseSelector(a, keySelector);
        b1 = Array._elementOrUseSelector(b, keySelector);
        if (a1 < b1) {
          if (isDescending) {
            return 1;
          } else {
            return -1;
          }
        } else if (a1 > b1) {
          if (isDescending) {
            return -1;
          } else {
            return 1;
          }
        } else {
          return 0;
        }
      };
    })(this));
  };

  Array.prototype.funSort = function(keySelector) {
    return this._sort(keySelector, false);
  };

  Array.prototype.funSortDescending = function(keySelector) {
    return this._sort(keySelector, true);
  };

  Array.prototype.funReverse = function() {
    return this.clone().reverse();
  };

  Array.prototype.except = function(array) {
    return this.filter(function(m) {
      return __indexOf.call(array, m) < 0;
    });
  };

  Array.prototype.flatten = function(level) {
    var canContinue, m, n, r, _i, _j, _len, _len1;
    if (level <= 0) {
      return fail();
    } else {
      r = [];
      canContinue = false;
      for (_i = 0, _len = this.length; _i < _len; _i++) {
        m = this[_i];
        if (Array.isArray(m)) {
          canContinue = true;
          for (_j = 0, _len1 = m.length; _j < _len1; _j++) {
            n = m[_j];
            r.push(n);
          }
        } else {
          r.push(m);
        }
      }
      if (canContinue) {
        if (level != null) {
          if (level === 1) {
            return r;
          } else {
            return r.flatten(level - 1);
          }
        } else {
          return r.flatten();
        }
      } else {
        return r;
      }
    }
  };

  Array.prototype.randomOne = function() {
    return this[Math.randomInt(this.length)];
  };

  Array.prototype.random = function(count) {
    return this.clone().takeRandom(count);
  };

  Array.prototype.takeRandomOne = function() {
    var index, r;
    index = Math.randomInt(this.length);
    r = this[index];
    this.removeAt(index);
    return r;
  };

  Array.prototype.takeRandom = function(count) {
    if (count == null) {
      count = this.length;
    }
    count = this._numberToLength(count);
    return repeat(count, (function(_this) {
      return function() {
        return _this.takeRandomOne();
      };
    })(this));
  };

  Array.prototype.removeAt = function(index) {
    this.splice(index, 1);
    return this;
  };

  Array.prototype.remove = function(element) {
    var index;
    index = this.indexOf(element);
    assert(index > -1);
    return this.removeAt(index);
  };

  Array.prototype.removeAll = function(element) {
    var index;
    while (true) {
      index = this.indexOf(element);
      if (index === -1) {
        break;
      }
      this.removeAt(index);
    }
    return this;
  };

  Array.prototype.removeMatch = function(predicate) {
    var index;
    index = this.findIndex(predicate);
    assert(index > -1);
    return this.removeAt(index);
  };

  Array.prototype.removeAllMatch = function(predicate) {
    var index;
    while (true) {
      index = this.findIndex(predicate);
      if (index === -1) {
        break;
      }
      this.removeAt(index);
    }
    return this;
  };

  if (Number.EPSILON === void 0) {
    Number.EPSILON = 2.2204460492503130808472633361816e-16;
  }

  if (Number.isInteger === void 0) {
    Number.isInteger = function(x) {
      return typeof x === "number" && isFinite(x) && x > -9007199254740992 && x < 9007199254740992 && Math.floor(x) === x;
    };
  }

  if (Number.isFinite === void 0) {
    Number.isFinite = function(x) {
      return typeof x === "number" && isFinite(x);
    };
  }

  if (Number.isNaN === void 0) {
    Number.isNaN = function(x) {
      return typeof x === "number" && isNaN(x);
    };
  }

  if (Number.parseInt === void 0) {
    Number.parseInt = parseInt;
  }

  if (Number.parseFloat === void 0) {
    Number.parseFloat = parseFloat;
  }

  if (String.prototype.startsWith === void 0) {
    String.prototype.startsWith = function(s) {
      return this.indexOf(s) === 0;
    };
  }

  if (String.prototype.endsWith === void 0) {
    String.prototype.endsWith = function(s) {
      return this.lastIndexOf(s) === this.length - s.length;
    };
  }

  if (String.prototype.contains === void 0) {
    String.prototype.contains = function(s) {
      return this.indexOf(s) !== -1;
    };
  }

  if (Object.is === void 0) {
    Object.is = function(a, b) {
      if (typeof a === "number" && typeof b === "number") {
        if (a === 0 && b === 0) {
          return 1 / a === 1 / b;
        } else if (isNaN(a) && isNaN(b)) {
          return true;
        } else {
          return a === b;
        }
      } else {
        return a === b;
      }
    };
  }

  if (Array.from === void 0) {
    Array.from = function(arrayLike) {
      var m, _i, _len, _results;
      _results = [];
      for (_i = 0, _len = arrayLike.length; _i < _len; _i++) {
        m = arrayLike[_i];
        _results.push(m);
      }
      return _results;
    };
  }

  if (Array.of === void 0) {
    Array.of = function() {
      return Array.from(arguments);
    };
  }

  if (Array.prototype.find === void 0) {
    Array.prototype.find = function(predicate) {
      var found;
      assert(typeof predicate === "function");
      found = this.filter(predicate);
      if (!found.isEmpty()) {
        return found.at(0);
      } else {
        return void 0;
      }
    };
  }

  if (Array.prototype.findIndex === void 0) {
    Array.prototype.findIndex = function(predicate) {
      var element;
      element = this.find(predicate);
      if (element === void 0) {
        return -1;
      } else {
        return this.indexOf(element);
      }
    };
  }

  if (Math.sign === void 0) {
    Math.sign = function(x) {
      if (typeof x === "number") {
        if (x === 0) {
          return 0;
        } else if (x > 0) {
          return 1;
        } else if (x < 0) {
          return -1;
        } else {
          return NaN;
        }
      } else {
        return NaN;
      }
    };
  }

  if (Math.trunc === void 0) {
    Math.trunc = function(x) {
      if (x < 0) {
        return Math.ceil(x);
      } else {
        return Math.floor(x);
      }
    };
  }

  if (global.setImmediate === void 0) {
    global.setImmediate = function(callback, args) {
      return setTimeout(callback, 0, args);
    };
  }

  if (global.clearImmediate === void 0) {
    global.clearImmediate = clearTimeout;
  }

  global.compose = function(functions) {
    if (arguments.length > 1) {
      functions = Array.from(arguments);
    }
    return function() {
      var args, m, _i, _len;
      args = arguments;
      for (_i = 0, _len = functions.length; _i < _len; _i++) {
        m = functions[_i];
        args = [m.apply(this, args)];
      }
      return args[0];
    };
  };

  global.fail = function(errorMessage) {
    throw new Error(errorMessage);
  };

  global.assert = function(condition, message) {
    if (!condition) {
      return fail(message);
    }
  };

  global.repeat = function(iterator, times) {
    var i, _i, _ref, _results;
    if (typeof iterator === "number") {
      _ref = [iterator, times], times = _ref[0], iterator = _ref[1];
    }
    _results = [];
    for (i = _i = 0; 0 <= times ? _i < times : _i > times; i = 0 <= times ? ++_i : --_i) {
      _results.push(iterator());
    }
    return _results;
  };

  global.spread = function(value, count) {
    var i, _i, _results;
    _results = [];
    for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
      _results.push(value);
    }
    return _results;
  };

  Object.getter = function(obj, prop, fun) {
    return Object.defineProperty(obj, prop, {
      get: fun,
      configurable: true
    });
  };

  Object.setter = function(obj, prop, fun) {
    return Object.defineProperty(obj, prop, {
      set: fun,
      configurable: true
    });
  };

  Object.clone = function(x) {
    var key, y, _i, _len, _ref;
    y = {};
    _ref = Object.keys(x);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      y[key] = x[key];
    }
    return y;
  };

  JSON.clone = function(x) {
    return JSON.parse(JSON.stringify(x));
  };

  String.prototype.matches = function(regex) {
    var adjustedRegex, match, result;
    adjustedRegex = new RegExp(regex.source, "g");
    result = [];
    while (true) {
      match = adjustedRegex.exec(this);
      if (match != null) {
        result.push(match);
      } else {
        break;
      }
    }
    return result;
  };

  String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.substr(1);
  };

  Date.prototype.add = function(x) {
    return new Date(this - (-x));
  };

  Date.prototype.subtract = function(x) {
    if (typeof x === "number") {
      return new Date(this - x);
    } else {
      return this - x;
    }
  };

  Date.prototype.equals = function(x) {
    return (x <= this && this <= x);
  };

  console.logt = function() {
    return console.log.apply(console, [new Date().toISOString()].concat(Array.from(arguments)));
  };

  global.Test = wishlist.Test;

  global.eventField = function() {
    var f;
    f = function(method, arg) {
      if (typeof method === "function") {
        arg = method;
        method = "bind";
      }
      assert(typeof method === "string");
      f[method](arg);
      return this;
    };
    f._listeners = [];
    f.bind = function(listener) {
      if (__indexOf.call(f._listeners, listener) < 0) {
        f._listeners.push(listener);
      }
      return f;
    };
    f.unbind = function(listener) {
      f._listeners.removeAll(listener);
      return f;
    };
    f.fire = function(arg) {
      var m, _i, _len, _ref;
      _ref = f._listeners;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        m = _ref[_i];
        if (arg != null ? arg.blocksListeners : void 0) {
          break;
        }
        m(arg);
      }
      return void 0;
    };
    return f;
  };

  global.EventedObject = (function() {
    function EventedObject() {
      this._eventList = {};
    }

    EventedObject.prototype.on = function(eventName, listener) {
      var _base;
      if ((_base = this._eventList)[eventName] == null) {
        _base[eventName] = [];
      }
      if (__indexOf.call(this._eventList[eventName], listener) < 0) {
        this._eventList[eventName].push(listener);
      }
      return this;
    };

    EventedObject.prototype.off = function(eventName, listener) {
      this._eventList[eventName].removeAll(listener);
      return this;
    };

    EventedObject.prototype.fire = function(eventName, arg) {
      var m, _base, _i, _len, _ref;
      if ((_base = this._eventList)[eventName] == null) {
        _base[eventName] = [];
      }
      _ref = this._eventList[eventName];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        m = _ref[_i];
        m(arg);
      }
      return void 0;
    };

    EventedObject.prototype.listeners = function(eventName) {
      return this._eventList[eventName];
    };

    return EventedObject;

  })();

  Math.nearlyEquals = function(a, b) {
    var threshold, _ref;
    threshold = 1 + 1 / 65536;
    return (1 / threshold < (_ref = a / b) && _ref < threshold);
  };

  Math.nearlyGreaterThan = function(a, b) {
    return a > b || Math.nearlyEquals(a, b);
  };

  Math.nearlyLessThan = function(a, b) {
    return a < b || Math.nearlyEquals(a, b);
  };

  Math.radiansToDegrees = function(radians) {
    return radians / Math.PI * 180;
  };

  Math.degreesToRadians = function(degrees) {
    return degrees / 180 * Math.PI;
  };

  Math.principalRadians = function(radians) {
    var t;
    t = radians % (2 * Math.PI);
    if (t <= -Math.PI) {
      return t + 2 * Math.PI;
    } else if (t > Math.PI) {
      return t - 2 * Math.PI;
    } else {
      return t;
    }
  };

  Math.principalDegrees = function(degrees) {
    var t;
    t = degrees % 360;
    if (t <= -180) {
      return t + 360;
    } else if (t > 180) {
      return t - 360;
    } else {
      return t;
    }
  };

  Math.randomNumber = function(m, n) {
    if (m < n) {
      return m + Math.random() * (n - m);
    } else {
      return fail();
    }
  };

  Math.randomInt = function(m, n) {
    var max, min;
    min = n === void 0 ? 0 : m;
    max = n === void 0 ? m : n;
    return Math.floor(Math.randomNumber(min, max));
  };

  Number.isFraction = function(x) {
    return typeof x === "number" && isFinite(x) && Math.floor(x) !== x;
  };

  Number.parseFloatExt = function(s) {
    return parseFloat(s) * (s.endsWith("%") ? 0.01 : 1);
  };

  Number.prototype.nearlyEquals = function(x) {
    return Math.nearlyEquals(this, x);
  };

  Number.prototype.nearlyGreaterThan = function(x) {
    return Math.nearlyGreaterThan(this, x);
  };

  Number.prototype.nearlyLessThan = function(x) {
    return Math.nearlyLessThan(this, x);
  };

  global.Point = (function() {
    function Point(x, y) {
      this.x = x;
      this.y = y;
    }

    Point.from = function(value) {
      if (typeof value === "number") {
        return new Point(value, 0);
      } else if (value instanceof Point) {
        return value.clone();
      } else if (typeof value === "string") {
        return Point.fromString(value);
      } else if (Array.isArray(value)) {
        return Point.fromArray(value);
      } else {
        return fail();
      }
    };

    Point.fromArray = function(array) {
      return new Point(array[0], array[1]);
    };

    Point.fromString = function(s) {
      var adjustedString, complexMatch, imaginary, normalMatch, real, _ref, _ref1;
      adjustedString = s.replace(/[\x20()]/g, "");
      normalMatch = adjustedString.match(/^([^,]*),(.*)$/);
      if (normalMatch != null) {
        return new Point(Number.parseFloatExt(normalMatch[1]), Number.parseFloatExt(normalMatch[2]));
      } else {
        complexMatch = adjustedString.match(/^([+-]?[0-9]*\.?[0-9]*(?:[Ee][+-]?[0-9]+)?(?![i0-9Ee.]))?(?:([+-]?[0-9]*\.?[0-9]*(?:[Ee][+-]?[0-9]+)?)i)?$/);
        if (complexMatch != null) {
          real = (_ref = complexMatch[1]) != null ? _ref : "0";
          imaginary = (_ref1 = complexMatch[2]) != null ? _ref1 : "0";
          if (real === "") {
            real = "1";
          }
          if (imaginary === "") {
            imaginary = "1";
          }
          if (real === "+") {
            real = "1";
          }
          if (imaginary === "+") {
            imaginary = "1";
          }
          if (real === "-") {
            real = "-1";
          }
          if (imaginary === "-") {
            imaginary = "-1";
          }
          return new Point(parseFloat(real), parseFloat(imaginary));
        } else {
          return fail();
        }
      }
    };

    Point.fromPolar = function(r, angle) {
      return new Point(r * Math.cos(angle), r * Math.sin(angle));
    };

    Point.fromPolarInDegrees = function(r, angle) {
      switch (Math.principalDegrees(angle)) {
        case 0:
          return new Point(r, 0);
        case 90:
          return new Point(0, r);
        case -90:
          return new Point(0, -r);
        case 180:
          return new Point(-r, 0);
        default:
          return Point.fromPolar(r, Math.degreesToRadians(angle));
      }
    };

    Point.prototype.real = function() {
      return this.x;
    };

    Point.prototype.imaginary = function() {
      return this.y;
    };

    Point.prototype.toString = function() {
      return "(" + this.x + "," + this.y + ")";
    };

    Point.prototype.toComplexString = function() {
      var sign;
      sign = this.y >= 0 ? "+" : "-";
      return "" + this.x + sign + (Math.abs(this.y)) + "i";
    };

    Point.prototype.clone = function() {
      return new Point(this.x, this.y);
    };

    Point.prototype.equals = function(p) {
      return cmath.equals(this, p);
    };

    Point.prototype.nearlyEquals = function(p) {
      return cmath.nearlyEquals(this, p);
    };

    Point.prototype.opposite = function() {
      return cmath.opposite(this);
    };

    Point.prototype.reciprocal = function() {
      return cmath.reciprocal(this);
    };

    Point.prototype.conjugate = function() {
      return cmath.conjugate(this);
    };

    Point.prototype.abs = function() {
      return cmath.abs(this);
    };

    Point.prototype.add = function(p) {
      return cmath.add(this, p);
    };

    Point.prototype.subtract = function(p) {
      return cmath.subtract(this, p);
    };

    Point.prototype.multiply = function(p) {
      return cmath.multiply(this, p);
    };

    Point.prototype.divide = function(p) {
      return cmath.divide(this, p);
    };

    Point.prototype.distance = function(p) {
      return cmath.distance(this, p);
    };

    Point.prototype.dotProduct = function(p) {
      p = Point.from(p);
      return this.x * p.x + this.y * p.y;
    };

    Point.prototype.crossProduct = function(p) {
      p = Point.from(p);
      return this.x * p.y - this.y * p.x;
    };

    Point.prototype.isOppositeTo = function(p) {
      return this.opposite().equals(p);
    };

    Point.prototype.phase = function() {
      return cmath.phase(this);
    };

    Point.prototype.phaseTo = function(p) {
      p = Point.from(p);
      return Math.principalRadians(p.phase() - this.phase());
    };

    Point.prototype.phaseInDegrees = function() {
      return cmath.phaseInDegrees(this);
    };

    Point.prototype.phaseInDegreesTo = function(p) {
      p = Point.from(p);
      return Math.principalDegrees(p.phaseInDegrees() - this.phaseInDegrees());
    };

    Point.prototype.scale = function(size) {
      size = Point.from(size);
      return new Point(this.x * size.x, this.y * size.y);
    };

    Point.prototype.rotate = function(angle) {
      return this.multiply(Point.fromPolar(1, angle));
    };

    Point.prototype.rotateDegrees = function(angle) {
      return this.multiply(Point.fromPolarInDegrees(1, angle));
    };

    return Point;

  })();

  global.cmath = {
    equals: function(a, b) {
      a = Point.from(a);
      b = Point.from(b);
      return a.x === b.x && a.y === b.y;
    },
    nearlyEquals: function(a, b) {
      a = Point.from(a);
      b = Point.from(b);
      return a.x.nearlyEquals(b.x) && a.y.nearlyEquals(b.y);
    },
    opposite: function(p) {
      p = Point.from(p);
      return new Point(-p.x, -p.y);
    },
    reciprocal: function(p) {
      var n;
      p = Point.from(p);
      n = p.x * p.x + p.y * p.y;
      return new Point(p.x / n, -p.y / n);
    },
    conjugate: function(p) {
      p = Point.from(p);
      return new Point(p.x, -p.y);
    },
    abs: function(p) {
      p = Point.from(p);
      if (p.x === 0) {
        return Math.abs(p.y);
      } else if (p.y === 0) {
        return Math.abs(p.x);
      } else {
        return Math.sqrt(p.x * p.x + p.y * p.y);
      }
    },
    phase: function(p) {
      p = Point.from(p);
      return Math.atan2(p.y, p.x);
    },
    phaseInDegrees: function(p) {
      var d;
      p = Point.from(p);
      if (p.x === 0 && p.y === 0) {
        return 0;
      } else if (p.x === 0 && p.y > 0) {
        return 90;
      } else if (p.x === 0 && p.y < 0) {
        return -90;
      } else if (p.x > 0 && p.y === 0) {
        return 0;
      } else if (p.x < 0 && p.y === 0) {
        return 180;
      } else {
        d = Math.radiansToDegrees(cmath.phase(p));
        if (d <= -180) {
          return 180;
        } else {
          return d;
        }
      }
    },
    add: function(a, b) {
      a = Point.from(a);
      b = Point.from(b);
      return new Point(a.x + b.x, a.y + b.y);
    },
    subtract: function(a, b) {
      return cmath.add(a, cmath.opposite(b));
    },
    multiply: function(a, b) {
      a = Point.from(a);
      b = Point.from(b);
      return new Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
    },
    divide: function(a, b) {
      return cmath.multiply(a, cmath.reciprocal(b));
    },
    distance: function(a, b) {
      return cmath.abs(cmath.subtract(a, b));
    },
    exp: function(p) {
      p = Point.from(p);
      return Point.fromPolar(Math.exp(p.x), p.y);
    },
    log: function(p) {
      return new Point(Math.log(cmath.abs(p)), cmath.phase(p));
    },
    pow: function(a, b) {
      return cmath.exp(cmath.multiply(cmath.log(a), b));
    },
    sqrt: function(p) {
      var r;
      p = Point.from(p);
      r = cmath.abs(p);
      return new Point(Math.sqrt((r + p.x) / 2), Math.sign(p.y) * Math.sqrt((r - p.x) / 2));
    },
    cos: function(p) {
      return cmath.divide(cmath.add(cmath.exp(cmath.multiply(p, new Point(0, 1))), cmath.exp(cmath.multiply(cmath.opposite(p), new Point(0, 1)))), 2);
    },
    sin: function(p) {
      return cmath.divide(cmath.subtract(cmath.exp(cmath.multiply(p, new Point(0, 1))), cmath.exp(cmath.multiply(cmath.opposite(p), new Point(0, 1)))), new Point(0, 2));
    },
    tan: function(p) {
      return cmath.divide(cmath.sin(p), cmath.cos(p));
    },
    acos: function(p) {
      return cmath.opposite(cmath.multiply(cmath.log(cmath.add(p, cmath.multiply(cmath.sqrt(cmath.add(cmath.opposite(cmath.multiply(p, p)), 1)), new Point(0, 1)))), new Point(0, 1)));
    },
    asin: function(p) {
      return cmath.opposite(cmath.multiply(cmath.log(cmath.add(cmath.multiply(p, new Point(0, 1)), cmath.sqrt(cmath.add(cmath.opposite(cmath.multiply(p, p)), 1)))), new Point(0, 1)));
    },
    atan: function(p) {
      return cmath.multiply(cmath.subtract(cmath.log(cmath.subtract(1, cmath.multiply(p, new Point(0, 1)))), cmath.log(cmath.add(1, cmath.multiply(p, new Point(0, 1))))), new Point(0, 0.5));
    }
  };

  Date.Timer = (function() {
    Timer._endOfTime = new Date("9999-12-30T00:00:00Z");

    function Timer(targetTime) {
      this.targetTime = targetTime != null ? targetTime : Date.Timer._endOfTime;
      this._counterValue = 0;
      this._internalTimer = null;
      this._running = false;
      this.allowsEqual = true;
      this.precision = 30;
      this.onArrive = eventField();
    }

    Timer.prototype.run = function() {
      if (this._running) {
        return;
      }
      this._counterValue = 0;
      this._internalTimer = setInterval((function(_this) {
        return function() {
          var lastTargetTime, nowTime;
          nowTime = new Date();
          if ((_this.allowsEqual ? nowTime >= _this.targetTime : nowTime > _this.targetTime)) {
            _this._counterValue++;
            lastTargetTime = _this.targetTime;
            _this.targetTime = Date.Timer._endOfTime;
            return _this.onArrive.fire({
              idealTime: lastTargetTime,
              nowTime: nowTime,
              index: _this._counterValue - 1
            });
          }
        };
      })(this), this.precision);
      this._running = true;
      return this;
    };

    Timer.prototype.stop = function() {
      if (!this._running) {
        return;
      }
      clearInterval(this._internalTimer);
      this._running = false;
      return this;
    };

    Timer.prototype.getRunning = function() {
      return this._running;
    };

    Timer.prototype.resetCounter = function() {
      return this._counterValue = 0;
    };

    Timer.prototype.getCounterValue = function() {
      return this._counterValue;
    };

    return Timer;

  })();

  Date.IntervalTimer = (function(_super) {
    __extends(IntervalTimer, _super);

    function IntervalTimer(interval, startTime, endTime) {
      this.interval = interval != null ? interval : 1000;
      this.startTime = startTime != null ? startTime : new Date();
      this.endTime = endTime;
      IntervalTimer.__super__.constructor.call(this);
      this._started = false;
      this.includesStart = true;
      this.includesEnd = false;
      this.onStart = eventField();
      this.onArrive.bind((function(_this) {
        return function(event) {
          _this.targetTime = event.idealTime.add(_this.interval);
          if (!_this._started) {
            _this._started = true;
            if (!_this.includesStart) {
              _this.resetCounter();
              event.blocksListeners = true;
            }
            _this.onStart.fire();
          }
          if ((_this.endTime != null) && (_this.includesEnd ? _this.targetTime > _this.endTime : _this.targetTime >= _this.endTime)) {
            return _this.stop();
          }
        };
      })(this));
    }

    IntervalTimer.prototype.run = function() {
      if (this.getRunning()) {
        return;
      }
      this.targetTime = this.startTime;
      return IntervalTimer.__super__.run.call(this);
    };

    return IntervalTimer;

  })(Date.Timer);

  module.exports = mate;

}).call(this);


},
nameIndexes: {"wishlist":1,"./package.json":2},
result: initialModResult_386389655257694535
}
,
{
fun: function(exports, module, require) {

// Generated by CoffeeScript 1.7.1

/* @license
Wishlist
https://github.com/zhanzhenzhen/wishlist
Copyright 2014 Zhenzhen Zhan
Released under the MIT license
 */

(function() {
  var wishlist,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  wishlist = {};

  wishlist.environmentType = (typeof exports !== "undefined" && exports !== null) && ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) && ((typeof process !== "undefined" && process !== null ? process.execPath : void 0) != null) && typeof process.execPath === "string" && process.execPath.search(/node/i) !== -1 ? "node" : (typeof window !== "undefined" && window !== null) && (typeof navigator !== "undefined" && navigator !== null) && (typeof HTMLElement !== "undefined" && HTMLElement !== null) ? "browser" : void 0;

  wishlist.moduleSystem = (typeof exports !== "undefined" && exports !== null) && ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) ? "commonjs" : null;

  wishlist.objectIs = function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      if (a === 0 && b === 0) {
        return 1 / a === 1 / b;
      } else if (isNaN(a) && isNaN(b)) {
        return true;
      } else {
        return a === b;
      }
    } else {
      return a === b;
    }
  };

  wishlist.objectClone = function(x) {
    var key, y, _i, _len, _ref;
    y = {};
    _ref = Object.keys(x);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      y[key] = x[key];
    }
    return y;
  };

  wishlist.valueToMessage = function(value) {
    var internal, r;
    internal = function(value, maxLevel) {
      if (value === void 0) {
        return "undefined";
      } else if (value === null) {
        return "null";
      } else if (Array.isArray(value)) {
        if (maxLevel > 0) {
          return "[" + value.map(function(m) {
            return internal(m, maxLevel - 1);
          }).join(",") + "]";
        } else {
          return "[Array]";
        }
      } else if (typeof value === "function") {
        return "[Function]";
      } else if (typeof value === "object") {
        if (maxLevel > 0) {
          return "{" + Object.keys(value).map(function(m) {
            return ("" + (JSON.stringify(m)) + ":") + internal(value[m], maxLevel - 1);
          }).join(",") + "}";
        } else {
          return "[Object]";
        }
      } else if (typeof value === "string") {
        return JSON.stringify(value.toString());
      } else if (typeof value === "number") {
        if (wishlist.objectIs(value, -0)) {
          return "-0";
        } else {
          return value.toString();
        }
      } else {
        return value.toString();
      }
    };
    r = internal(value, 3);
    if (r.length > 1000) {
      r = internal(value, 2);
    }
    if (r.length > 1000) {
      r = internal(value, 1);
    }
    if (r.length > 1000) {
      r = internal(value, 0);
    }
    return r;
  };

  wishlist.currentRootTest = null;

  wishlist.parseExpression = function(expStr, envNames) {
    var c, dotAffected, i, objectKeyReady, oldDotAffected, oldObjectKeyReady, oldSlashQuoteReady, oldWordStarted, positions, quote, regex, s, slashQuoteReady, wordStarted;
    expStr += " ";
    if (envNames.length === 0) {
      return [];
    }
    regex = new RegExp("^(" + envNames.join("|") + ")[^a-zA-Z0-9_$]", "g");
    positions = [];
    quote = null;
    slashQuoteReady = true;
    wordStarted = false;
    dotAffected = false;
    objectKeyReady = false;
    i = 0;
    while (i < expStr.length - 1) {
      c = expStr[i];
      oldSlashQuoteReady = slashQuoteReady;
      if (quote === null) {
        if (("a" <= c && c <= "z") || ("A" <= c && c <= "Z") || ("0" <= c && c <= "9") || c === "_" || c === "$" || c === ")" || c === "]") {
          slashQuoteReady = false;
        } else if (c === " " || c === "\t" || c === "\n" || c === "\r") {

        } else {
          slashQuoteReady = true;
        }
      }
      oldWordStarted = wordStarted;
      if (quote === null) {
        if (("a" <= c && c <= "z") || ("A" <= c && c <= "Z") || ("0" <= c && c <= "9") || c === "_" || c === "$" || c === ".") {
          wordStarted = true;
        } else {
          wordStarted = false;
        }
      }
      oldDotAffected = dotAffected;
      if (quote === null) {
        if (c === ".") {
          dotAffected = true;
        } else if (c === " " || c === "\t" || c === "\n" || c === "\r") {

        } else {
          dotAffected = false;
        }
      }
      oldObjectKeyReady = objectKeyReady;
      if (quote === null) {
        if (c === "{" || c === ",") {
          objectKeyReady = true;
        } else if (c === " " || c === "\t" || c === "\n" || c === "\r") {

        } else {
          objectKeyReady = false;
        }
      }
      if (c === "\"" && quote === null) {
        quote = "double";
        i++;
      } else if (c === "'" && quote === null) {
        quote = "single";
        i++;
      } else if (c === "/" && quote === null && oldSlashQuoteReady) {
        quote = "slash";
        i++;
      } else if ((c === "\"" && quote === "double") || (c === "'" && quote === "single") || (c === "/" && quote === "slash")) {
        quote = null;
        i++;
      } else if (c === "\\" && quote !== null) {
        i += 2;
      } else if (quote === null && !oldWordStarted && !oldDotAffected && (("a" <= c && c <= "z") || ("A" <= c && c <= "Z"))) {
        s = expStr.substr(i, 31);
        if (!(oldObjectKeyReady && s.search(/^([a-zA-Z0-9_$])+\s*:/) !== -1) && s.search(regex) !== -1) {
          positions.push(i);
        }
        i++;
      } else {
        i++;
      }
    }
    return positions;
  };

  wishlist.parseWish = function(wishStr) {
    var name, parsed;
    parsed = null;
    name = null;
    [0, 1].forEach(function(round) {
      var brace, bracket, c, dotAffected, i, match, oldDotAffected, oldSlashQuoteReady, parenthesis, quote, s, slashQuoteReady;
      quote = null;
      parenthesis = 0;
      bracket = 0;
      brace = 0;
      slashQuoteReady = true;
      dotAffected = false;
      i = 0;
      while (i < wishStr.length) {
        c = wishStr[i];
        oldSlashQuoteReady = slashQuoteReady;
        if (quote === null) {
          if (("a" <= c && c <= "z") || ("A" <= c && c <= "Z") || ("0" <= c && c <= "9") || c === "_" || c === "$" || c === ")" || c === "]") {
            slashQuoteReady = false;
          } else if (c === " " || c === "\t" || c === "\n" || c === "\r") {

          } else {
            slashQuoteReady = true;
          }
        }
        oldDotAffected = dotAffected;
        if (quote === null) {
          if (c === ".") {
            dotAffected = true;
          } else if (c === " " || c === "\t" || c === "\n" || c === "\r") {

          } else {
            dotAffected = false;
          }
        }
        if (c === "\"" && quote === null) {
          quote = "double";
          i++;
        } else if (c === "'" && quote === null) {
          quote = "single";
          i++;
        } else if (c === "/" && quote === null && oldSlashQuoteReady) {
          quote = "slash";
          i++;
        } else if ((c === "\"" && quote === "double") || (c === "'" && quote === "single") || (c === "/" && quote === "slash")) {
          quote = null;
          i++;
        } else if (c === "\\" && quote !== null) {
          i += 2;
        } else if (c === "(") {
          parenthesis++;
          i++;
        } else if (c === "[") {
          bracket++;
          i++;
        } else if (c === "{") {
          brace++;
          i++;
        } else if (c === ")") {
          parenthesis--;
          i++;
        } else if (c === "]") {
          bracket--;
          i++;
        } else if (c === "}") {
          brace--;
          i++;
        } else if (quote === null && !oldDotAffected && ((parenthesis === bracket && bracket === brace) && brace === 0)) {
          if (round === 0) {
            if (c === ":") {
              name = wishStr.substr(i + 1);
              wishStr = wishStr.substr(0, i);
              break;
            }
          } else if (round === 1) {
            s = wishStr.substr(i);
            if ((match = s.match(/^=([^]+)$/)) != null) {
              parsed = {
                type: "equal",
                components: [wishStr.substr(0, i), match[1]]
              };
              break;
            } else if ((match = s.match(/^<>([^]+)$/)) != null) {
              parsed = {
                type: "notEqual",
                components: [wishStr.substr(0, i), match[1]]
              };
              break;
            } else if ((match = s.match(/^\sis\s([^]+)$/)) != null) {
              parsed = {
                type: "is",
                components: [wishStr.substr(0, i), match[1]]
              };
              break;
            } else if ((match = s.match(/^\sisnt\s([^]+)$/)) != null) {
              parsed = {
                type: "isnt",
                components: [wishStr.substr(0, i), match[1]]
              };
              break;
            } else if ((match = s.match(/^\sthrows(?:\s([^]+))?$/)) != null) {
              parsed = {
                type: "throws",
                components: [wishStr.substr(0, i), match[1] != null ? match[1] : "undefined"]
              };
              break;
            } else if ((match = s.match(/^<=([^]+)$/)) != null) {
              parsed = {
                type: "lessThanOrEqual",
                components: [wishStr.substr(0, i), match[1]]
              };
              break;
            } else if ((match = s.match(/^>=([^]+)$/)) != null) {
              parsed = {
                type: "greaterThanOrEqual",
                components: [wishStr.substr(0, i), match[1]]
              };
              break;
            } else if ((match = s.match(/^<([^]+)$/)) != null) {
              parsed = {
                type: "lessThan",
                components: [wishStr.substr(0, i), match[1]]
              };
              break;
            } else if ((match = s.match(/^>([^]+)$/)) != null) {
              parsed = {
                type: "greaterThan",
                components: [wishStr.substr(0, i), match[1]]
              };
              break;
            }
          }
          i++;
        } else {
          i++;
        }
      }
      if (round === 1) {
        return parsed != null ? parsed : parsed = {
          type: "doesNotThrow",
          components: [wishStr]
        };
      }
    });
    parsed.components.push(JSON.stringify((name != null ? name : wishStr).trim()));
    return parsed;
  };

  wishlist.parseWishes = function(wishesStr) {
    var brace, bracket, c, i, lastIndex, oldSlashQuoteReady, parenthesis, positions, quote, r, s, slashQuoteReady;
    quote = null;
    parenthesis = 0;
    bracket = 0;
    brace = 0;
    slashQuoteReady = true;
    positions = [];
    i = 0;
    while (i < wishesStr.length) {
      c = wishesStr[i];
      oldSlashQuoteReady = slashQuoteReady;
      if (quote === null) {
        if (("a" <= c && c <= "z") || ("A" <= c && c <= "Z") || ("0" <= c && c <= "9") || c === "_" || c === "$" || c === ")" || c === "]") {
          slashQuoteReady = false;
        } else if (c === " " || c === "\t" || c === "\n" || c === "\r") {

        } else {
          slashQuoteReady = true;
        }
      }
      if (c === "\"" && quote === null) {
        quote = "double";
        i++;
      } else if (c === "'" && quote === null) {
        quote = "single";
        i++;
      } else if (c === "/" && quote === null && oldSlashQuoteReady) {
        quote = "slash";
        i++;
      } else if ((c === "\"" && quote === "double") || (c === "'" && quote === "single") || (c === "/" && quote === "slash")) {
        quote = null;
        i++;
      } else if (c === "\\" && quote !== null) {
        i += 2;
      } else if (c === "(") {
        parenthesis++;
        i++;
      } else if (c === "[") {
        bracket++;
        i++;
      } else if (c === "{") {
        brace++;
        i++;
      } else if (c === ")") {
        parenthesis--;
        i++;
      } else if (c === "]") {
        bracket--;
        i++;
      } else if (c === "}") {
        brace--;
        i++;
      } else if (quote === null && ((parenthesis === bracket && bracket === brace) && brace === 0) && c === ";") {
        positions.push(i);
        i++;
      } else {
        i++;
      }
    }
    r = [];
    lastIndex = -1;
    positions.forEach(function(index) {
      var s;
      s = wishesStr.substring(lastIndex + 1, index).trim();
      if (s !== "") {
        r.push(s);
      }
      return lastIndex = index;
    });
    s = wishesStr.substr(lastIndex + 1).trim();
    if (s !== "") {
      r.push(s);
    }
    return r;
  };

  wishlist.sha256 = function(str) {
    var Ch, H, K, M, Maj, N, ROTR, SHR, SIGMA0, SIGMA1, T1, T2, W, a, add, b, bytes, c, d, e, f, g, h, i, j, k, l, offset, paddedLength, sigma0, sigma1, t, wordToString, _i, _j, _k, _l, _m, _n, _ref;
    if (str.length > Math.round(Math.pow(2, 31) - 1)) {
      throw new Error();
    }
    wordToString = function(n) {
      var i;
      return ((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 7; _i >= 0; i = --_i) {
          _results.push(((n >>> (i * 4)) % 16).toString(16));
        }
        return _results;
      })()).join("");
    };
    add = function() {
      var arg, r, _i, _len;
      r = 0;
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        arg = arguments[_i];
        r = (r + arg) % 0x100000000;
      }
      return r;
    };
    ROTR = function(x, n) {
      return x >>> n | x << (32 - n);
    };
    SHR = function(x, n) {
      return x >>> n;
    };
    Ch = function(x, y, z) {
      return (x & y) ^ (~x & z);
    };
    Maj = function(x, y, z) {
      return (x & y) ^ (x & z) ^ (y & z);
    };
    SIGMA0 = function(x) {
      return ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22);
    };
    SIGMA1 = function(x) {
      return ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25);
    };
    sigma0 = function(x) {
      return ROTR(x, 7) ^ ROTR(x, 18) ^ SHR(x, 3);
    };
    sigma1 = function(x) {
      return ROTR(x, 17) ^ ROTR(x, 19) ^ SHR(x, 10);
    };
    K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
    H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
    bytes = str.split("").map(function(m) {
      return m.charCodeAt(0);
    });
    l = str.length * 8;
    k = 448 - l - 1;
    while (k < 0) {
      k += 512;
    }
    paddedLength = l + 1 + k + 64;
    bytes.push(0x80);
    for (i = _i = 0, _ref = Math.round((k - 7) / 8); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      bytes.push(0);
    }
    bytes.push(0);
    bytes.push(0);
    bytes.push(0);
    bytes.push(0);
    bytes.push(l >>> 24);
    bytes.push((l >>> 16) % 256);
    bytes.push((l >>> 8) % 256);
    bytes.push(l % 256);
    N = Math.round(paddedLength / 512);
    M = new Array(N);
    for (i = _j = 0; 0 <= N ? _j < N : _j > N; i = 0 <= N ? ++_j : --_j) {
      M[i] = new Array(16);
      for (j = _k = 0; _k < 16; j = ++_k) {
        offset = i * 64 + j * 4;
        M[i][j] = (bytes[offset] << 24) | (bytes[offset + 1] << 16) | (bytes[offset + 2] << 8) | bytes[offset + 3];
      }
    }
    W = new Array(64);
    for (i = _l = 0; 0 <= N ? _l < N : _l > N; i = 0 <= N ? ++_l : --_l) {
      for (t = _m = 0; _m < 64; t = ++_m) {
        W[t] = t < 16 ? M[i][t] : add(sigma1(W[t - 2]), W[t - 7], sigma0(W[t - 15]), W[t - 16]);
      }
      a = H[0];
      b = H[1];
      c = H[2];
      d = H[3];
      e = H[4];
      f = H[5];
      g = H[6];
      h = H[7];
      for (t = _n = 0; _n < 64; t = ++_n) {
        T1 = add(h, SIGMA1(e), Ch(e, f, g), K[t], W[t]);
        T2 = add(SIGMA0(a), Maj(a, b, c));
        h = g;
        g = f;
        f = e;
        e = add(d, T1);
        d = c;
        c = b;
        b = a;
        a = add(T1, T2);
      }
      H[0] = add(a, H[0]);
      H[1] = add(b, H[1]);
      H[2] = add(c, H[2]);
      H[3] = add(d, H[3]);
      H[4] = add(e, H[4]);
      H[5] = add(f, H[5]);
      H[6] = add(g, H[6]);
      H[7] = add(h, H[7]);
    }
    return H.map(function(m) {
      return wordToString(m);
    }).join("");
  };


  /*
  In `wishlist.Test`, the `wishes` property contains only separated wishes
  (i.e. not including those defined and checked in a test function), but
  the `wishResults` property includes results for all wishes.
  Test names can be duplicate. Wish names can also be duplicate.
  Restriction: On browser it doesn't work well with exceptional tests.
   */

  wishlist.Test = (function() {
    function Test(name) {
      this.name = name != null ? name : "";
      this._children = [];
      this.fun = (function(_this) {
        return function() {};
      })(this);
      this.afterFun = (function(_this) {
        return function() {};
      })(this);
      this.wishes = [];
      this.async = false;
      this.parent = null;
      this.allCount = 1;
      this._resetContext();
    }

    Test.prototype._resetContext = function() {
      this.env = {};
      this.wishResults = [];
      this.result = null;
      return this.endedCount = 0;
    };

    Test.prototype.set = function() {
      var fun, name, normalizeWishes, options, rawWishes, wishes;
      name = fun = wishes = rawWishes = options = void 0;
      normalizeWishes = (function(_this) {
        return function(raw) {
          var combined;
          combined = Array.isArray(raw) ? raw.join(";") : typeof raw === "string" ? raw : "";
          return wishlist.parseWishes(combined);
        };
      })(this);
      if (typeof arguments[0] === "string") {
        name = arguments[0];
        fun = arguments[1];
        if (typeof arguments[2] === "object" && arguments[2] !== null && !Array.isArray(arguments[2])) {
          options = arguments[2];
        } else {
          rawWishes = arguments[2];
          options = arguments[3];
        }
      } else {
        fun = arguments[0];
        if (typeof arguments[1] === "object" && arguments[1] !== null && !Array.isArray(arguments[1])) {
          options = arguments[1];
        } else {
          rawWishes = arguments[1];
          options = arguments[2];
        }
      }
      wishes = normalizeWishes(rawWishes);
      if (options == null) {
        options = {};
      }
      if (name !== void 0) {
        this.name = name;
      }
      this.fun = fun;
      if (rawWishes !== void 0) {
        this.wishes = wishes;
      }
      if (options.async !== void 0) {
        this.async = options.async;
      }
      return this;
    };

    Test.prototype.setAsync = function() {
      var args, lastArg, m, _i, _len;
      args = [];
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        m = arguments[_i];
        args.push(m);
      }
      lastArg = args[args.length - 1];
      if (typeof lastArg === "object" && lastArg !== null && !Array.isArray(lastArg)) {
        lastArg.async = true;
      } else {
        args.push({
          async: true
        });
      }
      return this.set.apply(this, args);
    };

    Test.prototype.after = function(afterFun) {
      this.afterFun = afterFun;
      return this;
    };

    Test.prototype.add = function() {
      var count, newChild;
      newChild = null;
      count = null;
      if (arguments[0] instanceof wishlist.Test) {
        newChild = arguments[0];
        count = newChild.getAll().length;
      } else {
        newChild = new wishlist.Test();
        newChild.set.apply(newChild, arguments);
        count = 1;
      }
      newChild.parent = this;
      this._children.push(newChild);
      this.getAncestorsAndSelf().forEach((function(_this) {
        return function(test) {
          return test.allCount += count;
        };
      })(this));
      return this;
    };

    Test.prototype.addAsync = function() {
      var args, lastArg, m, _i, _len;
      args = [];
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        m = arguments[_i];
        args.push(m);
      }
      lastArg = args[args.length - 1];
      if (typeof lastArg === "object" && lastArg !== null && !Array.isArray(lastArg)) {
        lastArg.async = true;
      } else {
        args.push({
          async: true
        });
      }
      return this.add.apply(this, args);
    };

    Test.prototype.getChildren = function() {
      return this._children.slice(0);
    };

    Test.prototype.getAncestors = function() {
      var r, test;
      test = this;
      r = [];
      while (test.parent !== null) {
        r.push(test.parent);
        test = test.parent;
      }
      return r;
    };

    Test.prototype.getAncestorsAndSelf = function() {
      return [this].concat(this.getAncestors());
    };

    Test.prototype.getAll = function() {
      var r, traverse;
      r = [];
      r.push(this);
      traverse = (function(_this) {
        return function(test) {
          return test.getChildren().forEach(function(m) {
            r.push(m);
            return traverse(m);
          });
        };
      })(this);
      traverse(this);
      return r;
    };

    Test.prototype.run = function(isRoot) {
      var allTests, timer, timerJob;
      if (isRoot == null) {
        isRoot = true;
      }
      if (isRoot) {
        wishlist.currentRootTest = this;
      }
      this._resetContext();
      if (this.parent != null) {
        this.env = wishlist.objectClone(this.parent.env);
      }
      setTimeout((function(_this) {
        return function() {
          var domain;
          if (wishlist.environmentType === "node") {
            domain = require("domain").create();
            domain.on("error", function(error) {
              return _this.end({
                type: false,
                errorMessage: "Error Name: " + error.name + "\nError Message: " + error.message + "\nError Stack: " + error.stack
              });
            });
            return domain.run(function() {
              return process.nextTick(function() {
                _this.fun(_this.env, _this);
                if ((_this.result == null) && !_this.async) {
                  return _this.end({
                    type: true
                  });
                }
              });
            });
          } else {
            try {
              _this.fun(_this.env, _this);
              if ((_this.result == null) && !_this.async) {
                return _this.end({
                  type: true
                });
              }
            } catch (_error) {
              return _this.end({
                type: false
              });
            }
          }
        };
      })(this), 0);
      if (isRoot) {
        allTests = this.getAll();
        console.log();
        timerJob = (function(_this) {
          return function() {
            var exceptionTests, failureCount, mark, markString, okTests, pendingTests, successCount;
            okTests = allTests.filter(function(m) {
              return (m.result != null) && m.result.type === true;
            });
            exceptionTests = allTests.filter(function(m) {
              return (m.result != null) && m.result.type === false;
            });
            pendingTests = allTests.filter(function(m) {
              return m.result == null;
            });
            console.log(("" + (new Date().toISOString()) + " OK: " + okTests.length + ", ") + ("Exception: " + exceptionTests.length + ", Pending: " + pendingTests.length));
            if (pendingTests.length === 0) {
              clearInterval(timer);
              exceptionTests.forEach(function(m) {
                console.log("\n********** Exceptional Test **********");
                console.log("Test: " + m.name);
                console.log("Function: " + (m.fun.toString()));
                if (m.result.errorMessage != null) {
                  return console.log(m.result.errorMessage);
                }
              });
              failureCount = 0;
              successCount = 0;
              markString = "";
              allTests.forEach(function(m) {
                return m.wishResults.forEach(function(n) {
                  var ancestors, longName;
                  markString += " " + n.type.toString();
                  if (n.type === false) {
                    failureCount++;
                    ancestors = m.getAncestors();
                    ancestors.reverse();
                    longName = ancestors.concat([m]).map(function(m) {
                      return m.name;
                    }).join(" --> ");
                    console.log("\n********** Broken Wish **********");
                    console.log("    Test: " + longName);
                    console.log("    Wish: " + n.name);
                    console.log("Expected: " + n.expected);
                    return console.log("  Actual: " + n.actual);
                  } else {
                    return successCount++;
                  }
                });
              });
              markString = markString.trim();
              mark = wishlist.sha256(markString).substr(0, 5);
              console.log("\n" + ((exceptionTests.length === 0 ? "Tests OK." : "" + exceptionTests.length + " tests of " + allTests.length + " exceptional.") + " " + (failureCount === 0 ? "Wishes fulfilled." : "" + failureCount + " wishes of " + (failureCount + successCount) + " broken.") + " " + ("Mark: " + mark)) + "\n");
              return wishlist.currentRootTest = null;
            }
          };
        })(this);
        timer = setInterval(timerJob, 1000);
        setTimeout(timerJob, 10);
      }
      return this;
    };

    Test.prototype.end = function(result) {
      if (this.result == null) {
        this.result = result != null ? result : {
          type: true
        };
        this.wishes.forEach((function(_this) {
          return function(m) {
            return _this._checkWish(m);
          };
        })(this));
        this.getAncestorsAndSelf().forEach((function(_this) {
          return function(test) {
            test.endedCount++;
            if (test.endedCount === test.allCount) {
              return test._tryCallFun(function() {
                return test.afterFun(test.env);
              });
            }
          };
        })(this));
        this.getChildren().forEach((function(_this) {
          return function(m) {
            return m.run(false);
          };
        })(this));
      }
      return this;
    };

    Test.prototype._tryCallFun = function(fun) {
      var domain;
      if (wishlist.environmentType === "node") {
        domain = require("domain").create();
        domain.on("error", (function(_this) {
          return function(error) {
            return console.log(error.stack);
          };
        })(this));
        return domain.run((function(_this) {
          return function() {
            return process.nextTick(fun);
          };
        })(this));
      } else {
        try {
          return fun();
        } catch (_error) {
          return console.log("Error!");
        }
      }
    };

    Test.prototype._checkWish = function(wishStr) {
      var args, interpret, name, parsed, result, that;
      that = this;
      interpret = (function(_this) {
        return function(s) {
          wishlist.parseExpression(s, Object.keys(_this.env)).forEach(function(m, index) {
            var insertedString, pos;
            insertedString = "that.env.";
            pos = m + insertedString.length * index;
            return s = s.substr(0, pos) + insertedString + s.substr(pos);
          });
          return s;
        };
      })(this);
      parsed = wishlist.parseWish(wishStr);
      args = parsed.components.map((function(_this) {
        return function(m, index) {
          if (index === parsed.components.length - 1) {
            return m;
          } else {
            return interpret(m);
          }
        };
      })(this));
      name = JSON.parse(args[args.length - 1]);
      result = (function() {
        try {
          args = args.map((function(_this) {
            return function(m) {
              return eval("((" + m + "))");
            };
          })(this));
          return this["_check_" + parsed.type].apply(this, args);
        } catch (_error) {
          return {
            type: false,
            name: name,
            actual: "unknown",
            expected: "unknown"
          };
        }
      }).call(this);
      return this.wishResults.push(result);
    };

    Test.prototype.wish = function(wishesStr) {
      return wishlist.parseWishes(wishesStr).forEach((function(_this) {
        return function(wishStr) {
          return _this._checkWish(wishStr);
        };
      })(this));
    };

    return Test;

  })();

  wishlist.Test.prototype._check_equal = function(actual, ruler, name) {
    var determine, objects, result;
    if (name == null) {
      name = "";
    }
    objects = [];
    determine = (function(_this) {
      return function(actual, ruler) {
        if (Array.isArray(actual) && Array.isArray(ruler)) {
          if (ruler.every(function(m, index) {
            if (__indexOf.call(objects, m) >= 0) {
              return wishlist.objectIs(actual[index], m);
            } else {
              if (typeof m === "object" && m !== null) {
                objects.push(m);
              }
              return determine(actual[index], m);
            }
          })) {
            return true;
          } else {
            return false;
          }
        } else if (typeof actual === "object" && actual !== null && typeof ruler === "object" && ruler !== null) {
          if (Object.keys(ruler).every(function(m) {
            var _ref;
            if (_ref = ruler[m], __indexOf.call(objects, _ref) >= 0) {
              return wishlist.objectIs(actual[m], ruler[m]);
            } else {
              if (typeof ruler[m] === "object" && ruler[m] !== null) {
                objects.push(ruler[m]);
              }
              return determine(actual[m], ruler[m]);
            }
          })) {
            return true;
          } else {
            return false;
          }
        } else {
          return wishlist.objectIs(actual, ruler);
        }
      };
    })(this);
    result = {
      type: determine(actual, ruler),
      name: name
    };
    if (result.type === false) {
      result.actual = wishlist.valueToMessage(actual);
      result.expected = "= " + wishlist.valueToMessage(ruler);
    }
    return result;
  };

  wishlist.Test.prototype._check_notEqual = function(actual, ruler, name) {
    var determine, objects, result;
    if (name == null) {
      name = "";
    }
    objects = [];
    determine = (function(_this) {
      return function(actual, ruler) {
        if (Array.isArray(actual) && Array.isArray(ruler)) {
          if (ruler.some(function(m, index) {
            if (__indexOf.call(objects, m) >= 0) {
              return !wishlist.objectIs(actual[index], m);
            } else {
              if (typeof m === "object" && m !== null) {
                objects.push(m);
              }
              return determine(actual[index], m);
            }
          })) {
            return true;
          } else {
            return false;
          }
        } else if (typeof actual === "object" && actual !== null && typeof ruler === "object" && ruler !== null) {
          if (Object.keys(ruler).some(function(m) {
            var _ref;
            if (_ref = ruler[m], __indexOf.call(objects, _ref) >= 0) {
              return !wishlist.objectIs(actual[m], ruler[m]);
            } else {
              if (typeof ruler[m] === "object" && ruler[m] !== null) {
                objects.push(ruler[m]);
              }
              return determine(actual[m], ruler[m]);
            }
          })) {
            return true;
          } else {
            return false;
          }
        } else {
          return !wishlist.objectIs(actual, ruler);
        }
      };
    })(this);
    result = {
      type: determine(actual, ruler),
      name: name
    };
    if (result.type === false) {
      result.actual = wishlist.valueToMessage(actual);
      result.expected = " " + wishlist.valueToMessage(ruler);
    }
    return result;
  };

  wishlist.Test.prototype._check_is = function(actual, ruler, name) {
    var result;
    if (name == null) {
      name = "";
    }
    result = {
      type: wishlist.objectIs(actual, ruler),
      name: name
    };
    if (result.type === false) {
      result.actual = wishlist.valueToMessage(actual);
      result.expected = "is " + wishlist.valueToMessage(ruler);
    }
    return result;
  };

  wishlist.Test.prototype._check_isnt = function(actual, ruler, name) {
    var result;
    if (name == null) {
      name = "";
    }
    result = {
      type: !wishlist.objectIs(actual, ruler),
      name: name
    };
    if (result.type === false) {
      result.actual = wishlist.valueToMessage(actual);
      result.expected = "isn't " + wishlist.valueToMessage(ruler);
    }
    return result;
  };

  wishlist.Test.prototype._check_throws = function(fun, ruler, name) {
    var error, passed, result, resultType;
    if (name == null) {
      name = "";
    }
    passed = false;
    resultType = (function() {
      try {
        fun();
        passed = true;
        return false;
      } catch (_error) {
        error = _error;
        if (ruler == null) {
          return true;
        } else if (ruler instanceof RegExp) {
          if (ruler.test(error.message)) {
            return true;
          } else {
            return false;
          }
        } else {
          if (error instanceof ruler) {
            return true;
          } else {
            return false;
          }
        }
      }
    })();
    result = {
      type: resultType,
      name: name
    };
    if (result.type === false) {
      result.actual = passed ? "no exception" : "another exception";
      result.expected = passed ? "exception" : "an exception";
    }
    return result;
  };

  wishlist.Test.prototype._check_doesNotThrow = function(fun, name) {
    var result, resultType;
    if (name == null) {
      name = "";
    }
    resultType = (function() {
      try {
        fun();
        return true;
      } catch (_error) {
        return false;
      }
    })();
    result = {
      type: resultType,
      name: name
    };
    if (result.type === false) {
      result.actual = "exception";
      result.expected = "no exception";
    }
    return result;
  };

  wishlist.Test.prototype._check_lessThan = function(actual, ruler, name) {
    var result;
    if (name == null) {
      name = "";
    }
    result = {
      type: actual < ruler,
      name: name
    };
    if (result.type === false) {
      result.actual = wishlist.valueToMessage(actual);
      result.expected = "< " + wishlist.valueToMessage(ruler);
    }
    return result;
  };

  wishlist.Test.prototype._check_lessThanOrEqual = function(actual, ruler, name) {
    var result;
    if (name == null) {
      name = "";
    }
    result = {
      type: actual <= ruler,
      name: name
    };
    if (result.type === false) {
      result.actual = wishlist.valueToMessage(actual);
      result.expected = "<= " + wishlist.valueToMessage(ruler);
    }
    return result;
  };

  wishlist.Test.prototype._check_greaterThan = function(actual, ruler, name) {
    var result;
    if (name == null) {
      name = "";
    }
    result = {
      type: actual > ruler,
      name: name
    };
    if (result.type === false) {
      result.actual = wishlist.valueToMessage(actual);
      result.expected = "> " + wishlist.valueToMessage(ruler);
    }
    return result;
  };

  wishlist.Test.prototype._check_greaterThanOrEqual = function(actual, ruler, name) {
    var result;
    if (name == null) {
      name = "";
    }
    result = {
      type: actual >= ruler,
      name: name
    };
    if (result.type === false) {
      result.actual = wishlist.valueToMessage(actual);
      result.expected = ">= " + wishlist.valueToMessage(ruler);
    }
    return result;
  };

  if (wishlist.environmentType === "browser") {
    window.npmWishlist = wishlist;
  }

  if (wishlist.moduleSystem === "commonjs") {
    module.exports = wishlist;
  }

}).call(this);


},
nameIndexes: {},
result: initialModResult_386389655257694535
}
,
{
fun: function(exports, module, require) {

module.exports =

{
    "name": "mate",
    "version": "0.11.2",
    "description": "Array extensions, ES6 shims, testing, timers, events, etc. It extends the native JavaScript/CoffeeScript.",
    "keywords": [
        "event", "coffeescript", "timer", "math", "javascript", "js", "coffee",
        "es6", "shim", "test", "testing"
    ],
    "author": "Zhenzhen Zhan <zhanzhenzhen@hotmail.com>",
    "homepage": "http://zizisoft.com/mate/",
    "license": "MIT",
    "repository": {
        "type": "git",
        "url": "https://github.com/zhanzhenzhen/mate.git"
    },
    "dependencies": {
        "wishlist": "0.3.2"
    },
    "devDependencies": {
        "coffee-script": "1.8.0",
        "uglify-js": "2.4.15",
        "js-bundler": "0.5.0"
    },
    "main": "mate"
}


;


},
nameIndexes: {},
result: initialModResult_386389655257694535
}

    ];

    // This wrapper is to prevent naming conflicts.
    (function() {
        var initialModResult = initialModResult_386389655257694535;
        var mods = mods_386389655257694535;
        var run = function(index) {
            var mod = mods[index];
            var theExports = {};
            var theModule = {exports: theExports};
            var theRequire = function(name) {

                // half-way result, for caching & preventing infinite loops
                mod.result = theModule.exports;

                var newIndex = mod.nameIndexes[name];
                if (newIndex === undefined) {
                    throw new Error("Cannot find module " + JSON.stringify(name) + ".");
                }
                if (mods[newIndex].result === initialModResult) {
                    run(newIndex);
                }
                return mods[newIndex].result;
            };
            mod.fun.apply(theExports, [theExports, theModule, theRequire]);
            mod.result = theModule.exports; // for caching
        };
        run(0);
    })();
})();
