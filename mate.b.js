
/* @license
Mate
https://github.com/zhanzhenzhen/mate
Copyright 2015 Zhenzhen Zhan
Released under the MIT license
*/

// This wrapper is to prevent global variable assignments. It's not to
// prevent naming conflicts ("674497323404793172" already does), but to
// work better with minification tools.
(function() {
    // `{}` is to guarantee that any subsequent `mod.result` assignment will make
    // the variable different from the initial value.
    var initialModResult_674497323404793172 = {};

    var mods_674497323404793172 = [
    {fun: function(exports, module, require) {


// *****
// ***** file-674497323404793172
// ***** (((

// Generated by CoffeeScript 1.9.1
(function() {
  var ArrayLazyWrapper, getter, mate, setter, web,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    slice = [].slice,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  require("es6-shim");

  mate = {};

  mate.packageInfo = require("./package.json");

  mate.environmentType = ((typeof process !== "undefined" && process !== null ? process.execPath : void 0) != null) && typeof process.execPath === "string" && process.execPath.search(/node/i) !== -1 ? "node" : (typeof window !== "undefined" && window !== null) && (typeof navigator !== "undefined" && navigator !== null) && (typeof HTMLElement !== "undefined" && HTMLElement !== null) ? "browser" : void 0;

  if (mate.environmentType === "browser") {
    window.global = window;
  }

  global.npmMate = mate;

  global.Test = require("wishlist").Test;

  global.compose = function(functions) {
    if (arguments.length > 1) {
      functions = Array.from(arguments);
    }
    return function() {
      var args, j, len, m;
      args = arguments;
      for (j = 0, len = functions.length; j < len; j++) {
        m = functions[j];
        args = [m.apply(this, args)];
      }
      return args[0];
    };
  };

  global.fail = function(errorMessage) {
    throw new Error(errorMessage);
  };

  global.assert = function(condition, message) {
    if (!condition) {
      return fail(message);
    }
  };

  global.repeat = function(iterator, times) {
    var i, j, ref, ref1, results1;
    if (typeof iterator === "number") {
      ref = [iterator, times], times = ref[0], iterator = ref[1];
    }
    results1 = [];
    for (i = j = 0, ref1 = times; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
      results1.push(iterator());
    }
    return results1;
  };

  global.spread = function(value, count) {
    var i, j, ref, results1;
    results1 = [];
    for (i = j = 0, ref = count; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
      results1.push(value);
    }
    return results1;
  };

  getter = function(obj, prop, fun) {
    return Object.defineProperty(obj, prop, {
      get: fun,
      configurable: true
    });
  };

  setter = function(obj, prop, fun) {
    return Object.defineProperty(obj, prop, {
      set: fun,
      configurable: true
    });
  };

  global.eventField = function() {
    var f;
    f = function(method, arg) {
      if (typeof method === "function") {
        arg = method;
        method = "bind";
      }
      assert(typeof method === "string");
      f[method](arg);
      return this;
    };
    f._listeners = [];
    f.getListeners = function() {
      return f._listeners.clone();
    };
    f.bind = function(listener) {
      if (indexOf.call(f._listeners, listener) < 0) {
        f._listeners.push(listener);
      }
      return f;
    };
    f.unbind = function(listener) {
      f._listeners.removeAll(listener);
      return f;
    };
    f.unbindAll = function() {
      f._listeners = [];
      return f;
    };
    f.fire = function(arg) {
      var j, len, listener, ref;
      ref = f._listeners;
      for (j = 0, len = ref.length; j < len; j++) {
        listener = ref[j];
        if (arg != null ? arg.blocksListeners : void 0) {
          break;
        }
        listener(arg);
      }
      return f;
    };
    return f;
  };

  mate.EventedObject = (function() {
    function EventedObject() {
      this._eventList = {};
    }

    EventedObject.prototype.on = function(eventName, listener) {
      var base;
      if ((base = this._eventList)[eventName] == null) {
        base[eventName] = [];
      }
      if (indexOf.call(this._eventList[eventName], listener) < 0) {
        this._eventList[eventName].push(listener);
      }
      return this;
    };

    EventedObject.prototype.off = function(eventName, listener) {
      this._eventList[eventName].removeAll(listener);
      return this;
    };

    EventedObject.prototype.fire = function(eventName, arg) {
      var base, j, len, m, ref;
      if ((base = this._eventList)[eventName] == null) {
        base[eventName] = [];
      }
      ref = this._eventList[eventName];
      for (j = 0, len = ref.length; j < len; j++) {
        m = ref[j];
        m(arg);
      }
      return this;
    };

    EventedObject.prototype.listeners = function(eventName) {
      return this._eventList[eventName];
    };

    return EventedObject;

  })();

  ArrayLazyWrapper = (function() {
    function ArrayLazyWrapper(value, chainToCopy, itemToPush) {
      this._value = value;
      this._chain = (chainToCopy != null ? chainToCopy : []).slice(0);
      if (itemToPush != null) {
        this._chain.push(itemToPush);
      }
      getter(this, "length", (function(_this) {
        return function() {
          return _this.force().length;
        };
      })(this));
    }

    ArrayLazyWrapper.prototype.force = function() {
      var j, len, m, n, ref;
      n = this._value;
      ref = this._chain;
      for (j = 0, len = ref.length; j < len; j++) {
        m = ref[j];
        n = m.fun.apply(n, m.args);
      }
      return n;
    };

    ArrayLazyWrapper.prototype.map = function() {
      return this._pushChain(Array.prototype.map, arguments);
    };

    ArrayLazyWrapper.prototype.filter = function() {
      return this._pushChain(Array.prototype.filter, arguments);
    };

    ArrayLazyWrapper.prototype.concat = function() {
      return this._pushChain(Array.prototype.concat, arguments);
    };

    ArrayLazyWrapper.prototype.portion = function() {
      return this._pushChain(Array.prototype.portion, arguments);
    };

    ArrayLazyWrapper.prototype.funSort = function() {
      return this._pushChain(Array.prototype.funSort, arguments);
    };

    ArrayLazyWrapper.prototype.funSortDescending = function() {
      return this._pushChain(Array.prototype.funSortDescending, arguments);
    };

    ArrayLazyWrapper.prototype.funReverse = function() {
      return this._pushChain(Array.prototype.funReverse, arguments);
    };

    ArrayLazyWrapper.prototype.except = function() {
      return this._pushChain(Array.prototype.except, arguments);
    };

    ArrayLazyWrapper.prototype.distinct = function() {
      return this._pushChain(Array.prototype.distinct, arguments);
    };

    ArrayLazyWrapper.prototype.union = function() {
      return this._pushChain(Array.prototype.union, arguments);
    };

    ArrayLazyWrapper.prototype.intersect = function() {
      return this._pushChain(Array.prototype.intersect, arguments);
    };

    ArrayLazyWrapper.prototype.group = function() {
      return this._pushChain(Array.prototype.group, arguments);
    };

    ArrayLazyWrapper.prototype.flatten = function() {
      return this._pushChain(Array.prototype.flatten, arguments);
    };

    ArrayLazyWrapper.prototype.random = function() {
      return this._pushChain(Array.prototype.random, arguments);
    };

    ArrayLazyWrapper.prototype.some = function() {
      return this._unwrapAndDo(Array.prototype.some, arguments);
    };

    ArrayLazyWrapper.prototype.every = function() {
      return this._unwrapAndDo(Array.prototype.every, arguments);
    };

    ArrayLazyWrapper.prototype.isEmpty = function() {
      return this._unwrapAndDo(Array.prototype.isEmpty, arguments);
    };

    ArrayLazyWrapper.prototype.at = function() {
      return this._unwrapAndDo(Array.prototype.at, arguments);
    };

    ArrayLazyWrapper.prototype.atOrNull = function() {
      return this._unwrapAndDo(Array.prototype.atOrNull, arguments);
    };

    ArrayLazyWrapper.prototype.atOrVoid = function() {
      return this._unwrapAndDo(Array.prototype.atOrVoid, arguments);
    };

    ArrayLazyWrapper.prototype.contains = function() {
      return this._unwrapAndDo(Array.prototype.contains, arguments);
    };

    ArrayLazyWrapper.prototype.first = function() {
      return this._unwrapAndDo(Array.prototype.first, arguments);
    };

    ArrayLazyWrapper.prototype.firstOrNull = function() {
      return this._unwrapAndDo(Array.prototype.firstOrNull, arguments);
    };

    ArrayLazyWrapper.prototype.firstOrVoid = function() {
      return this._unwrapAndDo(Array.prototype.firstOrVoid, arguments);
    };

    ArrayLazyWrapper.prototype.last = function() {
      return this._unwrapAndDo(Array.prototype.last, arguments);
    };

    ArrayLazyWrapper.prototype.lastOrNull = function() {
      return this._unwrapAndDo(Array.prototype.lastOrNull, arguments);
    };

    ArrayLazyWrapper.prototype.lastOrVoid = function() {
      return this._unwrapAndDo(Array.prototype.lastOrVoid, arguments);
    };

    ArrayLazyWrapper.prototype.single = function() {
      return this._unwrapAndDo(Array.prototype.single, arguments);
    };

    ArrayLazyWrapper.prototype.singleOrNull = function() {
      return this._unwrapAndDo(Array.prototype.singleOrNull, arguments);
    };

    ArrayLazyWrapper.prototype.singleOrVoid = function() {
      return this._unwrapAndDo(Array.prototype.singleOrVoid, arguments);
    };

    ArrayLazyWrapper.prototype.withMax = function() {
      return this._unwrapAndDo(Array.prototype.withMax, arguments);
    };

    ArrayLazyWrapper.prototype.withMin = function() {
      return this._unwrapAndDo(Array.prototype.withMin, arguments);
    };

    ArrayLazyWrapper.prototype.max = function() {
      return this._unwrapAndDo(Array.prototype.max, arguments);
    };

    ArrayLazyWrapper.prototype.min = function() {
      return this._unwrapAndDo(Array.prototype.min, arguments);
    };

    ArrayLazyWrapper.prototype.sum = function() {
      return this._unwrapAndDo(Array.prototype.sum, arguments);
    };

    ArrayLazyWrapper.prototype.average = function() {
      return this._unwrapAndDo(Array.prototype.average, arguments);
    };

    ArrayLazyWrapper.prototype.median = function() {
      return this._unwrapAndDo(Array.prototype.median, arguments);
    };

    ArrayLazyWrapper.prototype.product = function() {
      return this._unwrapAndDo(Array.prototype.product, arguments);
    };

    ArrayLazyWrapper.prototype.randomOne = function() {
      return this._unwrapAndDo(Array.prototype.randomOne, arguments);
    };

    ArrayLazyWrapper.prototype._pushChain = function(fun, args) {
      return new ArrayLazyWrapper(this._value, this._chain, {
        fun: fun,
        args: args
      });
    };

    ArrayLazyWrapper.prototype._unwrapAndDo = function(fun, args) {
      return fun.apply(this.force(), args);
    };

    return ArrayLazyWrapper;

  })();

  Array._elementOrUseSelector = function(element, selector) {
    if (selector != null) {
      return selector(element);
    } else {
      return element;
    }
  };

  Array.prototype._ratioToIndex = function(ratio) {
    var r;
    r = Math.round(ratio * this.length - 0.5);
    if (r <= 0) {
      return 0;
    } else if (r > this.length - 1) {
      return this.length - 1;
    } else {
      return r;
    }
  };

  Array.prototype._ratioToLength = function(ratio) {
    var r;
    r = Math.round(ratio * (this.length + 1) - 0.5);
    if (r <= 0) {
      return 0;
    } else if (r > this.length) {
      return this.length;
    } else {
      return r;
    }
  };

  Array.prototype._reverseToIndex = function(reverseIndex) {
    return this.length - 1 - reverseIndex;
  };

  Array.prototype._positionToIndex = function(pos) {
    var ref;
    if (typeof pos === "number") {
      if ((0 < pos && pos < 1)) {
        pos = {
          Ratio: pos
        };
      } else if ((-1 < pos && pos < 0)) {
        pos = {
          Reverse: {
            Ratio: -pos
          }
        };
      } else if (pos < 0) {
        pos = {
          Reverse: -pos - 1
        };
      }
    }
    if (typeof pos === "number") {
      return pos;
    } else if ((pos != null ? (ref = pos.Reverse) != null ? ref.Ratio : void 0 : void 0) != null) {
      return this._reverseToIndex(this._ratioToIndex(pos.Reverse.Ratio));
    } else if ((pos != null ? pos.Reverse : void 0) != null) {
      return this._reverseToIndex(pos.Reverse);
    } else if ((pos != null ? pos.Ratio : void 0) != null) {
      return this._ratioToIndex(pos.Ratio);
    } else {
      return fail();
    }
  };

  Array.prototype._amountToLength = function(amount) {
    if (typeof amount === "number") {
      if ((0 < amount && amount < 1)) {
        amount = {
          Ratio: amount
        };
      }
    }
    if (typeof amount === "number") {
      return amount;
    } else if ((amount != null ? amount.Ratio : void 0) != null) {
      return this._ratioToLength(amount.Ratio);
    } else {
      return fail();
    }
  };

  Array.prototype.clone = function() {
    return this.slice(0);
  };

  Array.prototype.isEmpty = function() {
    return this.length === 0;
  };

  Array.prototype.lazy = function() {
    return ArrayLazyWrapper(this);
  };

  Array.prototype.portion = function(startIndex, length, endIndex) {
    startIndex = this._positionToIndex(startIndex);
    if (length != null) {
      length = this._amountToLength(length);
    }
    if (endIndex != null) {
      endIndex = this._positionToIndex(endIndex);
    }
    return this.slice(startIndex, length != null ? startIndex + length : endIndex + 1);
  };

  Array.prototype.at = function(index) {
    index = this._positionToIndex(index);
    assert(Number.isInteger(index) && (0 <= index && index < this.length));
    return this[index];
  };

  Array.prototype.atOrNull = function(index) {
    try {
      return this.at(index);
    } catch (_error) {
      return null;
    }
  };

  Array.prototype.atOrVoid = function(index) {
    try {
      return this.at(index);
    } catch (_error) {
      return void 0;
    }
  };

  Array.prototype.contains = function(value) {
    return indexOf.call(this, value) >= 0;
  };

  Array.prototype.first = function(predicate) {
    var queryResult;
    queryResult = predicate != null ? this.filter(predicate) : this;
    return queryResult.at(0);
  };

  Array.prototype.firstOrNull = function(predicate) {
    try {
      return this.first(predicate);
    } catch (_error) {
      return null;
    }
  };

  Array.prototype.firstOrVoid = function(predicate) {
    try {
      return this.first(predicate);
    } catch (_error) {
      return void 0;
    }
  };

  Array.prototype.last = function(predicate) {
    var queryResult;
    queryResult = predicate != null ? this.filter(predicate) : this;
    return queryResult.at(queryResult.length - 1);
  };

  Array.prototype.lastOrNull = function(predicate) {
    try {
      return this.last(predicate);
    } catch (_error) {
      return null;
    }
  };

  Array.prototype.lastOrVoid = function(predicate) {
    try {
      return this.last(predicate);
    } catch (_error) {
      return void 0;
    }
  };

  Array.prototype.single = function(predicate) {
    var queryResult;
    queryResult = predicate != null ? this.filter(predicate) : this;
    assert(queryResult.length === 1);
    return queryResult.at(0);
  };

  Array.prototype.singleOrNull = function(predicate) {
    try {
      return this.single(predicate);
    } catch (_error) {
      return null;
    }
  };

  Array.prototype.singleOrVoid = function(predicate) {
    try {
      return this.single(predicate);
    } catch (_error) {
      return void 0;
    }
  };

  Array.prototype.withMax = function(selector) {
    return this.reduce((function(_this) {
      return function(a, b, index) {
        if (Array._elementOrUseSelector(a, selector) > Array._elementOrUseSelector(b, selector)) {
          return a;
        } else {
          return b;
        }
      };
    })(this));
  };

  Array.prototype.withMin = function(selector) {
    return this.reduce((function(_this) {
      return function(a, b, index) {
        if (Array._elementOrUseSelector(a, selector) < Array._elementOrUseSelector(b, selector)) {
          return a;
        } else {
          return b;
        }
      };
    })(this));
  };

  Array.prototype.max = function(selector) {
    return Array._elementOrUseSelector(this.withMax(selector), selector);
  };

  Array.prototype.min = function(selector) {
    return Array._elementOrUseSelector(this.withMin(selector), selector);
  };

  Array.prototype.sum = function(selector) {
    if (this.length === 1) {
      return Array._elementOrUseSelector(this.first(), selector);
    } else {
      return this.reduce((function(_this) {
        return function(a, b, index) {
          return (index === 1 ? Array._elementOrUseSelector(a, selector) : a) + Array._elementOrUseSelector(b, selector);
        };
      })(this));
    }
  };

  Array.prototype.average = function(selector) {
    return this.sum(selector) / this.length;
  };

  Array.prototype.median = function(selector) {
    var a, b, m, n, sorted;
    sorted = this.funSort(selector);
    a = sorted.at(0.5 - Number.EPSILON);
    b = sorted.at(0.5 + Number.EPSILON);
    m = Array._elementOrUseSelector(a, selector);
    n = Array._elementOrUseSelector(b, selector);
    return (m + n) / 2;
  };

  Array.prototype.product = function(selector) {
    if (this.length === 1) {
      return Array._elementOrUseSelector(this.first(), selector);
    } else {
      return this.reduce((function(_this) {
        return function(a, b, index) {
          return (index === 1 ? Array._elementOrUseSelector(a, selector) : a) * Array._elementOrUseSelector(b, selector);
        };
      })(this));
    }
  };

  Array.prototype.group = function(keySelector, valueSelector) {
    var comparedKey, elements, j, key, len, m, results, sorted;
    if (this.isEmpty()) {
      return [];
    }
    sorted = this.funSort(keySelector);
    results = [];
    comparedKey = Array._elementOrUseSelector(sorted.first(), keySelector);
    elements = [];
    for (j = 0, len = sorted.length; j < len; j++) {
      m = sorted[j];
      key = Array._elementOrUseSelector(m, keySelector);
      if (key !== comparedKey) {
        results.push([comparedKey, Array._elementOrUseSelector(elements, valueSelector)]);
        comparedKey = key;
        elements = [];
      }
      elements.push(m);
    }
    results.push([comparedKey, Array._elementOrUseSelector(elements, valueSelector)]);
    return results;
  };

  Array.prototype._sort = function(keySelector, isDescending) {
    return this.clone().sort((function(_this) {
      return function(a, b) {
        var a1, b1;
        a1 = Array._elementOrUseSelector(a, keySelector);
        b1 = Array._elementOrUseSelector(b, keySelector);
        if (a1 < b1) {
          if (isDescending) {
            return 1;
          } else {
            return -1;
          }
        } else if (a1 > b1) {
          if (isDescending) {
            return -1;
          } else {
            return 1;
          }
        } else {
          return 0;
        }
      };
    })(this));
  };

  Array.prototype.funSort = function(keySelector) {
    return this._sort(keySelector, false);
  };

  Array.prototype.funSortDescending = function(keySelector) {
    return this._sort(keySelector, true);
  };

  Array.prototype.funReverse = function() {
    return this.clone().reverse();
  };

  Array.prototype.except = function(array, equalityComparer) {
    if (equalityComparer == null) {
      equalityComparer = (function(_this) {
        return function(a, b) {
          return a === b;
        };
      })(this);
    }
    return this.filter((function(_this) {
      return function(m) {
        return !array.some(function(n) {
          return equalityComparer(n, m);
        });
      };
    })(this));
  };

  Array.prototype.distinct = function(equalityComparer) {
    var r;
    if (equalityComparer == null) {
      equalityComparer = (function(_this) {
        return function(a, b) {
          return a === b;
        };
      })(this);
    }
    r = [];
    this.forEach((function(_this) {
      return function(m) {
        if (!r.some(function(n) {
          return equalityComparer(n, m);
        })) {
          return r.push(m);
        }
      };
    })(this));
    return r;
  };

  Array.prototype.union = function(arr, equalityComparer) {
    return this.concat(arr).distinct(equalityComparer);
  };

  Array.prototype.intersect = function(arr, equalityComparer) {
    var r;
    if (equalityComparer == null) {
      equalityComparer = (function(_this) {
        return function(a, b) {
          return a === b;
        };
      })(this);
    }
    r = [];
    this.distinct(equalityComparer).forEach((function(_this) {
      return function(m) {
        if (arr.some(function(n) {
          return equalityComparer(n, m);
        })) {
          return r.push(m);
        }
      };
    })(this));
    return r;
  };

  Array.prototype.flatten = function(level) {
    var canContinue, j, k, len, len1, m, n, r;
    if (level <= 0) {
      return fail();
    } else {
      r = [];
      canContinue = false;
      for (j = 0, len = this.length; j < len; j++) {
        m = this[j];
        if (Array.isArray(m)) {
          canContinue = true;
          for (k = 0, len1 = m.length; k < len1; k++) {
            n = m[k];
            r.push(n);
          }
        } else {
          r.push(m);
        }
      }
      if (canContinue) {
        if (level != null) {
          if (level === 1) {
            return r;
          } else {
            return r.flatten(level - 1);
          }
        } else {
          return r.flatten();
        }
      } else {
        return r;
      }
    }
  };

  Array.prototype.toObject = function() {
    var r;
    r = {};
    this.forEach((function(_this) {
      return function(element) {
        return r[element[0]] = element[1];
      };
    })(this));
    return r;
  };

  Array.prototype.deepJoin = function() {
    var args;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    if (args.length <= 1) {
      return this.join(args[0]);
    } else {
      return this.map((function(_this) {
        return function(arr) {
          return arr.deepJoin.apply(arr, args.slice(0, -1));
        };
      })(this)).join(args.last());
    }
  };

  Array.prototype.randomOne = function() {
    return this[Math.randomInt(this.length)];
  };

  Array.prototype.random = function(count) {
    return this.clone().takeRandom(count);
  };

  Array.prototype.takeRandomOne = function() {
    var index, r;
    index = Math.randomInt(this.length);
    r = this[index];
    this.removeAt(index);
    return r;
  };

  Array.prototype.takeRandom = function(count) {
    if (count == null) {
      count = this.length;
    }
    count = this._amountToLength(count);
    return repeat(count, (function(_this) {
      return function() {
        return _this.takeRandomOne();
      };
    })(this));
  };

  Array.prototype.removeAt = function(index) {
    this.splice(index, 1);
    return this;
  };

  Array.prototype.remove = function(element) {
    var index;
    index = this.indexOf(element);
    assert(index > -1);
    return this.removeAt(index);
  };

  Array.prototype.removeAll = function(element) {
    var index;
    while (true) {
      index = this.indexOf(element);
      if (index === -1) {
        break;
      }
      this.removeAt(index);
    }
    return this;
  };

  Array.prototype.removeMatch = function(predicate) {
    var index;
    index = this.findIndex(predicate);
    assert(index > -1);
    return this.removeAt(index);
  };

  Array.prototype.removeAllMatch = function(predicate) {
    var index;
    while (true) {
      index = this.findIndex(predicate);
      if (index === -1) {
        break;
      }
      this.removeAt(index);
    }
    return this;
  };

  if (String.prototype.contains === void 0) {
    String.prototype.contains = String.prototype.includes;
  }

  if (global.setImmediate === void 0) {
    global.setImmediate = function(callback, args) {
      return setTimeout(callback, 0, args);
    };
  }

  if (global.clearImmediate === void 0) {
    global.clearImmediate = clearTimeout;
  }

  Math.approxEquals = function(a, b) {
    var ref, threshold;
    threshold = 1 + 1 / 8388608;
    return (1 / threshold < (ref = a / b) && ref < threshold);
  };

  Math.approxGreaterThan = function(a, b) {
    return a > b || Math.approxEquals(a, b);
  };

  Math.approxLessThan = function(a, b) {
    return a < b || Math.approxEquals(a, b);
  };

  Math.radiansToDegrees = function(radians) {
    return radians / Math.PI * 180;
  };

  Math.degreesToRadians = function(degrees) {
    return degrees / 180 * Math.PI;
  };

  Math.principalRadians = function(radians) {
    var t;
    t = radians % (2 * Math.PI);
    if (t <= -Math.PI) {
      return t + 2 * Math.PI;
    } else if (t > Math.PI) {
      return t - 2 * Math.PI;
    } else {
      return t;
    }
  };

  Math.principalDegrees = function(degrees) {
    var t;
    t = degrees % 360;
    if (t <= -180) {
      return t + 360;
    } else if (t > 180) {
      return t - 360;
    } else {
      return t;
    }
  };

  Math.roundDecimal = function(x, digitCount) {
    var factor;
    if (digitCount == null) {
      digitCount = 0;
    }
    factor = Math.pow(10, digitCount);
    return Math.round(x * factor) / factor;
  };

  Math.randomNumber = function(m, n) {
    if (m < n) {
      return m + Math.random() * (n - m);
    } else {
      return fail();
    }
  };

  Math.randomInt = function(m, n) {
    var max, min;
    min = n === void 0 ? 0 : m;
    max = n === void 0 ? m : n;
    return Math.floor(Math.randomNumber(min, max));
  };

  global.Point = (function() {
    function Point(x1, y1) {
      this.x = x1;
      this.y = y1;
    }

    Point.from = function(value, second) {
      if (typeof value === "number") {
        if (typeof second === "number") {
          return new Point(value, second);
        } else {
          return new Point(value, 0);
        }
      } else if (value instanceof Point) {
        return value.clone();
      } else if (typeof value === "string") {
        return Point.fromString(value);
      } else if (Array.isArray(value)) {
        return Point.fromArray(value);
      } else {
        return fail();
      }
    };

    Point.fromArray = function(array) {
      return new Point(array[0], array[1]);
    };

    Point.fromString = function(s) {
      var adjustedString, complexMatch, imaginary, normalMatch, real, ref, ref1;
      adjustedString = s.replace(/[\x20()]/g, "");
      normalMatch = adjustedString.match(/^([^,]*),(.*)$/);
      if (normalMatch != null) {
        return new Point(Number.parseFloatExt(normalMatch[1]), Number.parseFloatExt(normalMatch[2]));
      } else {
        complexMatch = adjustedString.match(/^([+-]?[0-9]*\.?[0-9]*(?:[Ee][+-]?[0-9]+)?(?![i0-9Ee.]))?(?:([+-]?[0-9]*\.?[0-9]*(?:[Ee][+-]?[0-9]+)?)i)?$/);
        if (complexMatch != null) {
          real = (ref = complexMatch[1]) != null ? ref : "0";
          imaginary = (ref1 = complexMatch[2]) != null ? ref1 : "0";
          if (real === "") {
            real = "1";
          }
          if (imaginary === "") {
            imaginary = "1";
          }
          if (real === "+") {
            real = "1";
          }
          if (imaginary === "+") {
            imaginary = "1";
          }
          if (real === "-") {
            real = "-1";
          }
          if (imaginary === "-") {
            imaginary = "-1";
          }
          return new Point(parseFloat(real), parseFloat(imaginary));
        } else {
          return fail();
        }
      }
    };

    Point.fromPolar = function(r, angle) {
      return new Point(r * Math.cos(angle), r * Math.sin(angle));
    };

    Point.fromPolarInDegrees = function(r, angle) {
      switch (Math.principalDegrees(angle)) {
        case 0:
          return new Point(r, 0);
        case 90:
          return new Point(0, r);
        case -90:
          return new Point(0, -r);
        case 180:
          return new Point(-r, 0);
        default:
          return Point.fromPolar(r, Math.degreesToRadians(angle));
      }
    };

    Point.prototype.real = function() {
      return this.x;
    };

    Point.prototype.imaginary = function() {
      return this.y;
    };

    Point.prototype.toString = function() {
      return "(" + this.x + "," + this.y + ")";
    };

    Point.prototype.toComplexString = function() {
      var sign;
      sign = this.y >= 0 ? "+" : "-";
      return "" + this.x + sign + (Math.abs(this.y)) + "i";
    };

    Point.prototype.clone = function() {
      return new Point(this.x, this.y);
    };

    Point.prototype.equals = function(p) {
      return cmath.equals(this, p);
    };

    Point.prototype.approxEquals = function(p) {
      return cmath.approxEquals(this, p);
    };

    Point.prototype.opposite = function() {
      return cmath.opposite(this);
    };

    Point.prototype.reciprocal = function() {
      return cmath.reciprocal(this);
    };

    Point.prototype.conjugate = function() {
      return cmath.conjugate(this);
    };

    Point.prototype.abs = function() {
      return cmath.abs(this);
    };

    Point.prototype.add = function(p) {
      return cmath.add(this, p);
    };

    Point.prototype.subtract = function(p) {
      return cmath.subtract(this, p);
    };

    Point.prototype.multiply = function(p) {
      return cmath.multiply(this, p);
    };

    Point.prototype.divide = function(p) {
      return cmath.divide(this, p);
    };

    Point.prototype.distance = function(p) {
      return cmath.distance(this, p);
    };

    Point.prototype.dotProduct = function(p) {
      p = Point.from(p);
      return this.x * p.x + this.y * p.y;
    };

    Point.prototype.crossProduct = function(p) {
      p = Point.from(p);
      return this.x * p.y - this.y * p.x;
    };

    Point.prototype.isOppositeTo = function(p) {
      return this.opposite().equals(p);
    };

    Point.prototype.phase = function() {
      return cmath.phase(this);
    };

    Point.prototype.phaseTo = function(p) {
      p = Point.from(p);
      return Math.principalRadians(p.phase() - this.phase());
    };

    Point.prototype.phaseInDegrees = function() {
      return cmath.phaseInDegrees(this);
    };

    Point.prototype.phaseInDegreesTo = function(p) {
      p = Point.from(p);
      return Math.principalDegrees(p.phaseInDegrees() - this.phaseInDegrees());
    };

    Point.prototype.scale = function(size) {
      size = Point.from(size);
      return new Point(this.x * size.x, this.y * size.y);
    };

    Point.prototype.rotate = function(angle) {
      return this.multiply(Point.fromPolar(1, angle));
    };

    Point.prototype.rotateDegrees = function(angle) {
      return this.multiply(Point.fromPolarInDegrees(1, angle));
    };

    return Point;

  })();

  global.cmath = {
    equals: function(a, b) {
      a = Point.from(a);
      b = Point.from(b);
      return a.x === b.x && a.y === b.y;
    },
    approxEquals: function(a, b) {
      a = Point.from(a);
      b = Point.from(b);
      return a.x.approxEquals(b.x) && a.y.approxEquals(b.y);
    },
    opposite: function(p) {
      p = Point.from(p);
      return new Point(-p.x, -p.y);
    },
    reciprocal: function(p) {
      var n;
      p = Point.from(p);
      n = p.x * p.x + p.y * p.y;
      return new Point(p.x / n, -p.y / n);
    },
    conjugate: function(p) {
      p = Point.from(p);
      return new Point(p.x, -p.y);
    },
    abs: function(p) {
      p = Point.from(p);
      if (p.x === 0) {
        return Math.abs(p.y);
      } else if (p.y === 0) {
        return Math.abs(p.x);
      } else {
        return Math.sqrt(p.x * p.x + p.y * p.y);
      }
    },
    phase: function(p) {
      p = Point.from(p);
      return Math.atan2(p.y, p.x);
    },
    phaseInDegrees: function(p) {
      var d;
      p = Point.from(p);
      if (p.x === 0 && p.y === 0) {
        return 0;
      } else if (p.x === 0 && p.y > 0) {
        return 90;
      } else if (p.x === 0 && p.y < 0) {
        return -90;
      } else if (p.x > 0 && p.y === 0) {
        return 0;
      } else if (p.x < 0 && p.y === 0) {
        return 180;
      } else {
        d = Math.radiansToDegrees(cmath.phase(p));
        if (d <= -180) {
          return 180;
        } else {
          return d;
        }
      }
    },
    add: function(a, b) {
      a = Point.from(a);
      b = Point.from(b);
      return new Point(a.x + b.x, a.y + b.y);
    },
    subtract: function(a, b) {
      return cmath.add(a, cmath.opposite(b));
    },
    multiply: function(a, b) {
      a = Point.from(a);
      b = Point.from(b);
      return new Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
    },
    divide: function(a, b) {
      return cmath.multiply(a, cmath.reciprocal(b));
    },
    distance: function(a, b) {
      return cmath.abs(cmath.subtract(a, b));
    },
    exp: function(p) {
      p = Point.from(p);
      return Point.fromPolar(Math.exp(p.x), p.y);
    },
    log: function(p) {
      return new Point(Math.log(cmath.abs(p)), cmath.phase(p));
    },
    pow: function(a, b) {
      return cmath.exp(cmath.multiply(cmath.log(a), b));
    },
    sqrt: function(p) {
      var r;
      p = Point.from(p);
      r = cmath.abs(p);
      return new Point(Math.sqrt((r + p.x) / 2), Math.sign(p.y) * Math.sqrt((r - p.x) / 2));
    },
    cos: function(p) {
      return cmath.divide(cmath.add(cmath.exp(cmath.multiply(p, new Point(0, 1))), cmath.exp(cmath.multiply(cmath.opposite(p), new Point(0, 1)))), 2);
    },
    sin: function(p) {
      return cmath.divide(cmath.subtract(cmath.exp(cmath.multiply(p, new Point(0, 1))), cmath.exp(cmath.multiply(cmath.opposite(p), new Point(0, 1)))), new Point(0, 2));
    },
    tan: function(p) {
      return cmath.divide(cmath.sin(p), cmath.cos(p));
    },
    acos: function(p) {
      return cmath.opposite(cmath.multiply(cmath.log(cmath.add(p, cmath.multiply(cmath.sqrt(cmath.add(cmath.opposite(cmath.multiply(p, p)), 1)), new Point(0, 1)))), new Point(0, 1)));
    },
    asin: function(p) {
      return cmath.opposite(cmath.multiply(cmath.log(cmath.add(cmath.multiply(p, new Point(0, 1)), cmath.sqrt(cmath.add(cmath.opposite(cmath.multiply(p, p)), 1)))), new Point(0, 1)));
    },
    atan: function(p) {
      return cmath.multiply(cmath.subtract(cmath.log(cmath.subtract(1, cmath.multiply(p, new Point(0, 1)))), cmath.log(cmath.add(1, cmath.multiply(p, new Point(0, 1))))), new Point(0, 0.5));
    }
  };

  JSON.clone = function(x) {
    return JSON.parse(JSON.stringify(x));
  };

  Date.prototype.add = function(x) {
    return new Date(this - (-x));
  };

  Date.prototype.subtract = function(x) {
    if (typeof x === "number") {
      return new Date(this - x);
    } else {
      return this - x;
    }
  };

  Date.prototype.equals = function(x) {
    return (x <= this && this <= x);
  };

  console.logt = function() {
    return console.log.apply(console, [new Date().toISOString()].concat(Array.from(arguments)));
  };

  Number.isFraction = function(x) {
    return typeof x === "number" && isFinite(x) && Math.floor(x) !== x;
  };

  Number.parseFloatExt = function(s) {
    return parseFloat(s) * (s.endsWith("%") ? 0.01 : 1);
  };

  Number.prototype.approxEquals = function(x) {
    return Math.approxEquals(this.valueOf(), x);
  };

  Number.prototype.approxGreaterThan = function(x) {
    return Math.approxGreaterThan(this.valueOf(), x);
  };

  Number.prototype.approxLessThan = function(x) {
    return Math.approxLessThan(this.valueOf(), x);
  };

  Number.prototype.pad = function(integerSize, fractionalSize) {
    return this.valueOf().format({
      integerSize: integerSize,
      fractionalSize: fractionalSize
    });
  };

  Number.prototype.format = function(options) {
    var ePos, forcesSign, fractionalGroupEnabled, fractionalGroupSeparator, fractionalGroupSize, fractionalSize, integerGroupEnabled, integerGroupSeparator, integerGroupSize, integerSize, isNegative, radix, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, s, t, x;
    integerSize = (ref = options != null ? options.integerSize : void 0) != null ? ref : 1;
    fractionalSize = (ref1 = options != null ? options.fractionalSize : void 0) != null ? ref1 : 0;
    forcesSign = (ref2 = options != null ? options.forcesSign : void 0) != null ? ref2 : false;
    radix = (ref3 = options != null ? options.radix : void 0) != null ? ref3 : 10;
    integerGroupEnabled = (ref4 = options != null ? options.integerGroupEnabled : void 0) != null ? ref4 : false;
    integerGroupSeparator = (ref5 = options != null ? options.integerGroupSeparator : void 0) != null ? ref5 : ",";
    integerGroupSize = (ref6 = options != null ? options.integerGroupSize : void 0) != null ? ref6 : 3;
    fractionalGroupEnabled = (ref7 = options != null ? options.fractionalGroupEnabled : void 0) != null ? ref7 : false;
    fractionalGroupSeparator = (ref8 = options != null ? options.fractionalGroupSeparator : void 0) != null ? ref8 : " ";
    fractionalGroupSize = (ref9 = options != null ? options.fractionalGroupSize : void 0) != null ? ref9 : 3;
    if (radix !== 10) {
      fractionalSize = 0;
    }
    x = this.valueOf();
    if (integerSize > 80 || fractionalSize > 20 || x >= 1e21 || x <= -1e21 || integerGroupSize < 1 || fractionalGroupSize < 1) {
      fail("Number or argument out of range");
    }
    s = radix === 10 ? (t = Math.roundDecimal(x, fractionalSize).toString(), ePos = t.indexOf("e"), ePos === -1 ? t : t[ePos + 1] === "+" ? fail("Number too large") : x.toFixed(fractionalSize)) : Math.round(x).toString(radix);
    isNegative = s[0] === "-";
    if (s[0] === "+" || s[0] === "-") {
      s = s.remove(0);
    }
    (function(_this) {
      return (function() {
        var fractionalMissing, integerMissing, pos, rawFractionalSize, rawIntegerSize;
        pos = s.indexOf(".");
        rawIntegerSize = pos === -1 ? s.length : pos;
        integerMissing = Math.max(integerSize - rawIntegerSize, 0);
        rawFractionalSize = pos === -1 ? 0 : s.length - 1 - pos;
        fractionalMissing = fractionalSize - rawFractionalSize;
        s = s.substr(0, s.length + fractionalMissing);
        if (s[s.length - 1] === ".") {
          s = s.substr(0, s.length - 1);
        }
        if (pos === -1 && fractionalSize > 0) {
          s += ".";
        }
        return s = "0".repeat(integerMissing) + s + "0".repeat(Math.max(fractionalMissing, 0));
      });
    })(this)();
    if (integerGroupEnabled || fractionalGroupEnabled) {
      (function(_this) {
        return (function() {
          var fractionalStart, i, integerStart, pos;
          pos = s.indexOf(".");
          if (fractionalGroupEnabled) {
            fractionalStart = (pos === -1 ? s.length : pos) + 1 + fractionalGroupSize;
            ((function() {
              var j, ref10, ref11, ref12, results1;
              results1 = [];
              for (i = j = ref10 = fractionalStart, ref11 = s.length - 1, ref12 = fractionalGroupSize; ref12 > 0 ? j <= ref11 : j >= ref11; i = j += ref12) {
                results1.push(i);
              }
              return results1;
            })()).funReverse().forEach(function(i) {
              return s = s.insert(i, fractionalGroupSeparator);
            });
          }
          if (integerGroupEnabled) {
            integerStart = (pos === -1 ? s.length : pos) - integerGroupSize;
            return ((function() {
              var j, ref10, ref11, results1;
              results1 = [];
              for (i = j = ref10 = integerStart, ref11 = -integerGroupSize; ref11 > 0 ? j <= 1 : j >= 1; i = j += ref11) {
                results1.push(i);
              }
              return results1;
            })()).forEach(function(i) {
              return s = s.insert(i, integerGroupSeparator);
            });
          }
        });
      })(this)();
    }
    if (forcesSign) {
      if (isNegative) {
        s = "-" + s;
      } else {
        s = "+" + s;
      }
    } else {
      if (isNegative) {
        s = "-" + s;
      }
    }
    return s;
  };

  Object.isObject = function(x) {
    var ref;
    return ((ref = typeof x) === "object" || ref === "function") && x !== null;
  };

  Object.isNormalObject = function(x) {
    return Object.isObject(x) && typeof x !== "function" && !Array.isArray(x);
  };

  Object.clone = function(x) {
    var j, key, len, ref, y;
    y = {};
    ref = Object.keys(x);
    for (j = 0, len = ref.length; j < len; j++) {
      key = ref[j];
      y[key] = x[key];
    }
    return y;
  };

  Object.allKeys = function(x) {
    var key, results1;
    results1 = [];
    for (key in x) {
      results1.push(key);
    }
    return results1;
  };

  Object.keyValues = function(x) {
    return Object.keys(x).map(function(key) {
      return [key, x[key]];
    });
  };

  Object.allKeyValues = function(x) {
    return Object.allKeys(x).map(function(key) {
      return [key, x[key]];
    });
  };

  Object.forEach = function(x, callback) {
    return Object.keys(x).forEach(function(key) {
      return callback(key, x[key]);
    });
  };

  Object.forEachOfAll = function(x, callback) {
    return Object.allKeys(x).forEach(function(key) {
      return callback(key, x[key]);
    });
  };

  Object.deepAssign = function() {
    var sources, target;
    target = arguments[0], sources = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    sources.forEach(function(source) {
      var deepAssign;
      deepAssign = function(target, source) {
        return Object.forEach(source, function(key, value) {
          if (Object.isObject(value) && !Array.isArray(value) && Object.isObject(target[key]) && !Array.isArray(target[key])) {
            return deepAssign(target[key], value);
          } else {
            return target[key] = Object.deepClone(value);
          }
        });
      };
      return deepAssign(target, source);
    });
    return target;
  };

  Object.absorb = function() {
    var objects, subject;
    subject = arguments[0], objects = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    objects.forEach(function(object) {
      return Object.forEach(object, function(key, value) {
        if (subject[key] === void 0) {
          return subject[key] = value;
        }
      });
    });
    return subject;
  };

  Object.deepAbsorb = function() {
    var objects, subject;
    subject = arguments[0], objects = 2 <= arguments.length ? slice.call(arguments, 1) : [];
    objects.forEach(function(object) {
      var deepAbsorb;
      deepAbsorb = function(subject, object) {
        return Object.forEach(object, function(key, value) {
          if (Object.isObject(value) && !Array.isArray(value) && Object.isObject(subject[key]) && !Array.isArray(subject[key])) {
            return deepAbsorb(subject[key], value);
          } else {
            if (subject[key] === void 0) {
              return subject[key] = Object.deepClone(value);
            }
          }
        });
      };
      return deepAbsorb(subject, object);
    });
    return subject;
  };

  Object.deepClone = function(x) {
    var deepCopyFrom, target;
    if (Object.isObject(x)) {
      target = Array.isArray(x) ? [] : {};
      deepCopyFrom = function(target, source) {
        return Object.forEach(source, function(key, value) {
          if (Object.isObject(value)) {
            target[key] = Array.isArray(value) ? [] : {};
            return deepCopyFrom(target[key], value);
          } else {
            return target[key] = value;
          }
        });
      };
      deepCopyFrom(target, x);
      return target;
    } else {
      return x;
    }
  };

  String.prototype.format = function() {
    var cur, i, m, next, s;
    s = this.valueOf();
    m = [];
    i = 0;
    while (i < s.length) {
      cur = s[i];
      next = s[i + 1];
      if (cur === "{" && next === "{") {
        m.push("{", "");
        i++;
      } else if (cur === "}" && next === "}") {
        m.push("}", "");
        i++;
      } else if (cur === "{" && next >= "0" && next <= "9" && s[i + 2] === "}") {
        m.push(arguments[parseInt(next, 10)].toString(), "", "");
        i += 2;
      } else {
        m.push(cur);
      }
      i++;
    }
    return m.join("");
  };

  String.prototype.insert = function(index, value) {
    var s;
    s = this.valueOf();
    return s.substr(0, index) + value + s.substr(index);
  };

  String.prototype.remove = function(start, length) {
    var s;
    if (length == null) {
      length = 1;
    }
    s = this.valueOf();
    return s.substr(0, start) + s.substr(start + length);
  };

  String.prototype.matches = function(regex) {
    var adjustedRegex, match, result;
    adjustedRegex = new RegExp(regex.source, "g");
    result = [];
    while (true) {
      match = adjustedRegex.exec(this.valueOf());
      if (match != null) {
        result.push(match);
      } else {
        break;
      }
    }
    return result;
  };

  String.prototype.capitalize = function() {
    return this.charAt(0).toUpperCase() + this.substr(1);
  };

  String.prototype.deepSplit = function() {
    var args, arr;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    arr = this.split(args[0]);
    if (args.length === 2 && typeof args[1] === "number") {
      if (args[1] === 0) {
        return [arr.join(args[0])];
      } else if (args[1] <= arr.length - 2) {
        return arr.slice(0, +(args[1] - 1) + 1 || 9e9).concat([arr.slice(args[1]).join(args[0])]);
      } else {
        return arr;
      }
    } else if (args.length <= 1) {
      return arr;
    } else {
      return arr.map((function(_this) {
        return function(s) {
          return s.deepSplit.apply(s, args.slice(1));
        };
      })(this));
    }
  };

  String.prototype.stripTrailingNewline = function() {
    if (this[this.length - 2] === "\r" && this[this.length - 1] === "\n") {
      return this.substr(0, this.length - 2);
    } else if (this[this.length - 1] === "\n") {
      return this.substr(0, this.length - 1);
    } else {
      return this.valueOf();
    }
  };

  String.prototype.ensureTrailingNewline = function() {
    if (this[this.length - 1] !== "\n") {
      return this.valueOf() + "\n";
    } else {
      return this.valueOf();
    }
  };

  Date.Timer = (function() {
    Timer._endOfTime = new Date("9999-12-30T00:00:00Z");

    Timer._precision = 30;

    Timer._enable = function() {
      return this._internalTimer != null ? this._internalTimer : this._internalTimer = setInterval((function(_this) {
        return function() {
          return _this._onCheck.fire();
        };
      })(this), this._precision);
    };

    Timer._disable = function() {
      if (this._internalTimer != null) {
        clearInterval(this._internalTimer);
      }
      return this._internalTimer = null;
    };

    Timer.setPrecision = function(precision) {
      if (this._internalTimer != null) {
        this._disable();
        this._precision = precision;
        this._enable();
      } else {
        this._precision = precision;
      }
      return void 0;
    };

    Timer.getPrecision = function() {
      return this._precision;
    };

    Timer._onCheck = eventField();

    function Timer(options) {
      var ref, ref1;
      this.targetTime = (ref = options != null ? options.targetTime : void 0) != null ? ref : Date.Timer._endOfTime;
      this.allowsEqual = (ref1 = options != null ? options.allowsEqual : void 0) != null ? ref1 : true;
      this._counter = 0;
      this._running = false;
      this.onArrive = eventField();
      this.run();
    }

    Timer.prototype.run = function() {
      if (this._running) {
        return this;
      }
      this._running = true;
      Date.Timer._enable();
      this._checker = (function(_this) {
        return function() {
          var lastTargetTime, nowTime;
          nowTime = new Date();
          if ((_this.allowsEqual ? nowTime >= _this.targetTime : nowTime > _this.targetTime)) {
            _this._counter++;
            lastTargetTime = _this.targetTime;
            _this.targetTime = Date.Timer._endOfTime;
            return _this.onArrive.fire({
              idealTime: lastTargetTime,
              nowTime: nowTime,
              index: _this._counter - 1
            });
          }
        };
      })(this);
      Date.Timer._onCheck.bind(this._checker);
      return this;
    };

    Timer.prototype.stop = function() {
      if (!this._running) {
        return this;
      }
      this._running = false;
      Date.Timer._onCheck.unbind(this._checker);
      if (Date.Timer._onCheck.getListeners().isEmpty()) {
        Date.Timer._disable();
      }
      return this;
    };

    Timer.prototype.getRunning = function() {
      return this._running;
    };

    Timer.prototype.resetCounter = function() {
      this._counter = 0;
      return this;
    };

    Timer.prototype.getCounter = function() {
      return this._counter;
    };

    return Timer;

  })();

  Date.IntervalTimer = (function(superClass) {
    extend(IntervalTimer, superClass);

    function IntervalTimer(options) {
      var ref, ref1, ref2, ref3, ref4, ref5;
      IntervalTimer.__super__.constructor.call(this, options);
      this.interval = (ref = options != null ? options.interval : void 0) != null ? ref : 1000;
      this.startTime = (ref1 = options != null ? options.startTime : void 0) != null ? ref1 : new Date();
      this.endTime = (ref2 = options != null ? options.endTime : void 0) != null ? ref2 : Date.Timer._endOfTime.subtract(1000);
      this.includesStart = (ref3 = options != null ? options.includesStart : void 0) != null ? ref3 : true;
      this.includesEnd = (ref4 = options != null ? options.includesEnd : void 0) != null ? ref4 : false;
      this.skipsPast = (ref5 = options != null ? options.skipsPast : void 0) != null ? ref5 : false;
      this.targetTime = this.startTime;
      this._started = false;
      this.onStart = eventField();
      this.onArrive.bind((function(_this) {
        return function(event) {
          var now;
          if (_this.interval < Date.Timer.getPrecision() * 2) {
            _this.stop();
            return;
          }
          now = new Date();
          _this.targetTime = _this.skipsPast ? now - (now - event.idealTime) % _this.interval + _this.interval : event.idealTime.add(_this.interval);
          if (!_this._started) {
            _this._started = true;
            if (!_this.includesStart) {
              _this.resetCounter();
              event.blocksListeners = true;
            }
            _this.onStart.fire();
          }
          if ((_this.includesEnd ? _this.targetTime > _this.endTime : _this.targetTime >= _this.endTime)) {
            return _this.stop();
          }
        };
      })(this));
    }

    return IntervalTimer;

  })(Date.Timer);

  Date.Observer = (function(superClass) {
    extend(Observer, superClass);

    Observer._error = new Error();

    function Observer() {
      var clonedOptions, fun, options, ref;
      ref = typeof arguments[0] === "object" ? [arguments[0], arguments[1]] : [arguments[1], arguments[0]], options = ref[0], fun = ref[1];
      clonedOptions = options != null ? Object.clone(options) : {};
      if (clonedOptions.interval == null) {
        clonedOptions.interval = 100;
      }
      if (clonedOptions.skipsPast == null) {
        clonedOptions.skipsPast = true;
      }
      Observer.__super__.constructor.call(this, clonedOptions);
      this._fun = fun;
      this.onChange = eventField();
      this.onUpdate = eventField();
      this.onArrive.bind((function(_this) {
        return function() {
          var newValue;
          newValue = (function() {
            try {
              return this._fun();
            } catch (_error) {
              return Date.Observer._error;
            }
          }).call(_this);
          if (newValue === void 0) {
            newValue = Date.Observer._error;
          }
          if (_this._oldValue === void 0 || !Object.is(newValue, _this._oldValue)) {
            _this.onUpdate.fire({
              value: newValue
            });
            if (_this._oldValue !== void 0) {
              _this.onChange.fire({
                oldValue: _this._oldValue,
                newValue: newValue
              });
            }
            return _this._oldValue = newValue;
          }
        };
      })(this));
    }

    return Observer;

  })(Date.IntervalTimer);

  mate.web = web = {};

  web.request = function(options) {
    return new Promise(function(resolve, reject) {
      var body, ex, headerFields, method, ref, ref1, ref2, ref3, responseBodyType, timeout, uri;
      try {
        method = options.method;
        uri = options.uri;
        headerFields = (ref = options.headerFields) != null ? ref : null;
        body = (ref1 = options.body) != null ? ref1 : null;
        timeout = (ref2 = options.timeout) != null ? ref2 : null;
        responseBodyType = (ref3 = options.responseBodyType) != null ? ref3 : "text";
        if (method == null) {
          fail();
        }
        if (uri == null) {
          fail();
        }
        if ((body != null) && typeof body !== "string" && !(body instanceof Uint8Array)) {
          fail();
        }
        if (responseBodyType !== "binary" && responseBodyType !== "text" && responseBodyType !== "json") {
          fail();
        }
        if (mate.environmentType === "browser") {
          return (function() {
            var xhr;
            xhr = new XMLHttpRequest();
            xhr.open(method, uri);
            if (headerFields != null) {
              Object.forEach(headerFields, function(key, value) {
                return xhr.setRequestHeader(key, value);
              });
            }
            xhr.responseType = responseBodyType === "binary" ? "arraybuffer" : responseBodyType === "text" ? "text" : responseBodyType === "json" ? "text" : void 0;
            xhr.timeout = timeout != null ? timeout : 0;
            xhr.onload = function() {
              var ref4, response;
              response = {
                statusCode: xhr.status,
                statusReason: xhr.statusText,
                headerFields: xhr.getAllResponseHeaders().stripTrailingNewline().deepSplit("\r\n", ": ", 1).map(function(field) {
                  return [field[0].toLowerCase(), field[1]];
                }).toObject(),
                body: responseBodyType === "binary" ? new Uint8Array(xhr.response) : responseBodyType === "text" ? xhr.response : responseBodyType === "json" ? JSON.parse(xhr.response) : void 0
              };
              if ((200 <= (ref4 = response.statusCode) && ref4 < 300)) {
                return resolve(response);
              } else {
                return reject(response);
              }
            };
            xhr.onerror = function() {
              return reject(new Error());
            };
            xhr.ontimeout = function() {
              return reject(new Error("timeout"));
            };
            return xhr.send(body);
          })();
        } else {
          return (function() {
            var http, httpOrHttps, https, parsedUri, rawRequest, urlMod;
            http = module.require("http");
            https = module.require("https");
            urlMod = module.require("url");
            parsedUri = urlMod.parse(uri);
            httpOrHttps = parsedUri.protocol === "https:" ? https : http;
            rawRequest = httpOrHttps.request({
              method: method,
              hostname: parsedUri.hostname,
              port: parsedUri.port,
              path: parsedUri.path,
              headers: headerFields
            }, function(rawResponse) {
              var data;
              data = new Buffer(0);
              rawResponse.on("data", function(chunk) {
                return data = Buffer.concat([data, chunk]);
              });
              return rawResponse.on("end", function() {
                var ref4, response;
                response = {
                  statusCode: rawResponse.statusCode,
                  statusReason: rawResponse.statusMessage,
                  headerFields: rawResponse.headers,
                  body: responseBodyType === "binary" ? new Uint8Array(data) : responseBodyType === "text" ? data.toString() : responseBodyType === "json" ? JSON.parse(data.toString()) : void 0
                };
                if ((200 <= (ref4 = response.statusCode) && ref4 < 300)) {
                  return resolve(response);
                } else {
                  return reject(response);
                }
              });
            });
            if (timeout != null) {
              rawRequest.setTimeout(timeout, function() {
                rawRequest.abort();
                return reject(new Error("timeout"));
              });
            }
            return rawRequest.on("error", function(e) {
              return reject(new Error());
            }).end(body instanceof Uint8Array ? new Buffer(body) : body);
          })();
        }
      } catch (_error) {
        ex = _error;
        return reject(ex);
      }
    });
  };

  web.get = function(uri, options) {
    var actualOptions;
    actualOptions = {
      method: "GET",
      uri: uri
    };
    Object.assign(actualOptions, options);
    return web.request(actualOptions);
  };

  web.jsonGet = function(uri, options) {
    var actualOptions;
    actualOptions = {
      method: "GET",
      uri: uri,
      responseBodyType: "json"
    };
    Object.assign(actualOptions, options);
    return web.request(actualOptions);
  };

  web.binaryGet = function(uri, options) {
    var actualOptions;
    actualOptions = {
      method: "GET",
      uri: uri,
      responseBodyType: "binary"
    };
    Object.assign(actualOptions, options);
    return web.request(actualOptions);
  };

  web.post = function(uri, body, options) {
    var actualOptions;
    actualOptions = {
      method: "POST",
      uri: uri,
      body: body
    };
    Object.assign(actualOptions, options);
    return web.request(actualOptions);
  };

  web.jsonPost = function(uri, body, options) {
    var actualOptions;
    actualOptions = {
      method: "POST",
      uri: uri,
      headerFields: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(body),
      responseBodyType: "json"
    };
    Object.assign(actualOptions, options);
    return web.request(actualOptions);
  };

  module.exports = mate;

}).call(this);

// ***** ))) file end


}, nameIndexes: {"es6-shim":1,"./package.json":2,"wishlist":3}, result: initialModResult_674497323404793172}, {fun: function(exports, module, require) {


// *****
// ***** file-674497323404793172
// ***** (((

 /*!
  * https://github.com/paulmillr/es6-shim
  * @license es6-shim Copyright 2013-2015 by Paul Miller (http://paulmillr.com)
  *   and contributors,  MIT License
  * es6-shim: v0.27.1
  * see https://github.com/paulmillr/es6-shim/blob/0.27.1/LICENSE
  * Details and documentation:
  * https://github.com/paulmillr/es6-shim/
  */

// UMD (Universal Module Definition)
// see https://github.com/umdjs/umd/blob/master/returnExports.js
(function (root, factory) {
  /*global define, module, exports */
  if (typeof define === 'function' && define.amd) {
    // AMD. Register as an anonymous module.
    define(factory);
  } else if (typeof exports === 'object') {
    // Node. Does not work with strict CommonJS, but
    // only CommonJS-like enviroments that support module.exports,
    // like Node.
    module.exports = factory();
  } else {
    // Browser globals (root is window)
    root.returnExports = factory();
  }
}(this, function () {
  'use strict';

  var isCallableWithoutNew = function (func) {
    try {
      func();
    } catch (e) {
      return false;
    }
    return true;
  };

  var supportsSubclassing = function (C, f) {
    /* jshint proto:true */
    try {
      var Sub = function () { C.apply(this, arguments); };
      if (!Sub.__proto__) { return false; /* skip test on IE < 11 */ }
      Object.setPrototypeOf(Sub, C);
      Sub.prototype = Object.create(C.prototype, {
        constructor: { value: C }
      });
      return f(Sub);
    } catch (e) {
      return false;
    }
  };

  var arePropertyDescriptorsSupported = function () {
    try {
      Object.defineProperty({}, 'x', {});
      return true;
    } catch (e) { /* this is IE 8. */
      return false;
    }
  };

  var startsWithRejectsRegex = function () {
    var rejectsRegex = false;
    if (String.prototype.startsWith) {
      try {
        '/a/'.startsWith(/a/);
      } catch (e) { /* this is spec compliant */
        rejectsRegex = true;
      }
    }
    return rejectsRegex;
  };

  /*jshint evil: true */
  var getGlobal = new Function('return this;');
  /*jshint evil: false */

  var globals = getGlobal();
  var global_isFinite = globals.isFinite;
  var supportsDescriptors = !!Object.defineProperty && arePropertyDescriptorsSupported();
  var startsWithIsCompliant = startsWithRejectsRegex();
  var _indexOf = Function.call.bind(String.prototype.indexOf);
  var _toString = Function.call.bind(Object.prototype.toString);
  var _hasOwnProperty = Function.call.bind(Object.prototype.hasOwnProperty);
  var ArrayIterator; // make our implementation private
  var noop = function () {};

  var Symbol = globals.Symbol || {};
  var symbolSpecies = Symbol.species || '@@species';
  var Type = {
    object: function (x) { return x !== null && typeof x === 'object'; },
    string: function (x) { return _toString(x) === '[object String]'; },
    regex: function (x) { return _toString(x) === '[object RegExp]'; },
    symbol: function (x) {
      /*jshint notypeof: true */
      return typeof globals.Symbol === 'function' && typeof x === 'symbol';
      /*jshint notypeof: false */
    }
  };

  var defineProperty = function (object, name, value, force) {
    if (!force && name in object) { return; }
    if (supportsDescriptors) {
      Object.defineProperty(object, name, {
        configurable: true,
        enumerable: false,
        writable: true,
        value: value
      });
    } else {
      object[name] = value;
    }
  };

  var Value = {
    getter: function (object, name, getter) {
      if (!supportsDescriptors) {
        throw new TypeError('getters require true ES5 support');
      }
      Object.defineProperty(object, name, {
        configurable: true,
        enumerable: false,
        get: getter
      });
    },
    proxy: function (originalObject, key, targetObject) {
      if (!supportsDescriptors) {
        throw new TypeError('getters require true ES5 support');
      }
      var originalDescriptor = Object.getOwnPropertyDescriptor(originalObject, key);
      Object.defineProperty(targetObject, key, {
        configurable: originalDescriptor.configurable,
        enumerable: originalDescriptor.enumerable,
        get: function getKey() { return originalObject[key]; },
        set: function setKey(value) { originalObject[key] = value; }
      });
    },
    redefine: function (object, property, newValue) {
      if (supportsDescriptors) {
        var descriptor = Object.getOwnPropertyDescriptor(object, property);
        descriptor.value = newValue;
        Object.defineProperty(object, property, descriptor);
      } else {
        object[property] = newValue;
      }
    },
    preserveToString: function (target, source) {
      defineProperty(target, 'toString', source.toString.bind(source), true);
    }
  };

  // Define configurable, writable and non-enumerable props
  // if they dont exist.
  var defineProperties = function (object, map) {
    Object.keys(map).forEach(function (name) {
      var method = map[name];
      defineProperty(object, name, method, false);
    });
  };

  // Simple shim for Object.create on ES3 browsers
  // (unlike real shim, no attempt to support `prototype === null`)
  var create = Object.create || function (prototype, properties) {
    function Prototype() {}
    Prototype.prototype = prototype;
    var object = new Prototype();
    if (typeof properties !== 'undefined') {
      defineProperties(object, properties);
    }
    return object;
  };

  // This is a private name in the es6 spec, equal to '[Symbol.iterator]'
  // we're going to use an arbitrary _-prefixed name to make our shims
  // work properly with each other, even though we don't have full Iterator
  // support.  That is, `Array.from(map.keys())` will work, but we don't
  // pretend to export a "real" Iterator interface.
  var $iterator$ = Type.symbol(Symbol.iterator) ? Symbol.iterator : '_es6-shim iterator_';
  // Firefox ships a partial implementation using the name @@iterator.
  // https://bugzilla.mozilla.org/show_bug.cgi?id=907077#c14
  // So use that name if we detect it.
  if (globals.Set && typeof new globals.Set()['@@iterator'] === 'function') {
    $iterator$ = '@@iterator';
  }
  var addIterator = function (prototype, impl) {
    if (!impl) { impl = function iterator() { return this; }; }
    var o = {};
    o[$iterator$] = impl;
    defineProperties(prototype, o);
    if (!prototype[$iterator$] && Type.symbol($iterator$)) {
      // implementations are buggy when $iterator$ is a Symbol
      prototype[$iterator$] = impl;
    }
  };

  // taken directly from https://github.com/ljharb/is-arguments/blob/master/index.js
  // can be replaced with require('is-arguments') if we ever use a build process instead
  var isArguments = function isArguments(value) {
    var str = _toString(value);
    var result = str === '[object Arguments]';
    if (!result) {
      result = str !== '[object Array]' &&
        value !== null &&
        typeof value === 'object' &&
        typeof value.length === 'number' &&
        value.length >= 0 &&
        _toString(value.callee) === '[object Function]';
    }
    return result;
  };

  var safeApply = Function.call.bind(Function.apply);

  var ES = {
    // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-call-f-v-args
    Call: function Call(F, V) {
      var args = arguments.length > 2 ? arguments[2] : [];
      if (!ES.IsCallable(F)) {
        throw new TypeError(F + ' is not a function');
      }
      return safeApply(F, V, args);
    },

    RequireObjectCoercible: function (x, optMessage) {
      /* jshint eqnull:true */
      if (x == null) {
        throw new TypeError(optMessage || 'Cannot call method on ' + x);
      }
    },

    TypeIsObject: function (x) {
      /* jshint eqnull:true */
      // this is expensive when it returns false; use this function
      // when you expect it to return true in the common case.
      return x != null && Object(x) === x;
    },

    ToObject: function (o, optMessage) {
      ES.RequireObjectCoercible(o, optMessage);
      return Object(o);
    },

    IsCallable: function (x) {
      // some versions of IE say that typeof /abc/ === 'function'
      return typeof x === 'function' && _toString(x) === '[object Function]';
    },

    ToInt32: function (x) {
      return ES.ToNumber(x) >> 0;
    },

    ToUint32: function (x) {
      return ES.ToNumber(x) >>> 0;
    },

    ToNumber: function (value) {
      if (_toString(value) === '[object Symbol]') {
        throw new TypeError('Cannot convert a Symbol value to a number');
      }
      return +value;
    },

    ToInteger: function (value) {
      var number = ES.ToNumber(value);
      if (Number.isNaN(number)) { return 0; }
      if (number === 0 || !Number.isFinite(number)) { return number; }
      return (number > 0 ? 1 : -1) * Math.floor(Math.abs(number));
    },

    ToLength: function (value) {
      var len = ES.ToInteger(value);
      if (len <= 0) { return 0; } // includes converting -0 to +0
      if (len > Number.MAX_SAFE_INTEGER) { return Number.MAX_SAFE_INTEGER; }
      return len;
    },

    SameValue: function (a, b) {
      if (a === b) {
        // 0 === -0, but they are not identical.
        if (a === 0) { return 1 / a === 1 / b; }
        return true;
      }
      return Number.isNaN(a) && Number.isNaN(b);
    },

    SameValueZero: function (a, b) {
      // same as SameValue except for SameValueZero(+0, -0) == true
      return (a === b) || (Number.isNaN(a) && Number.isNaN(b));
    },

    IsIterable: function (o) {
      return ES.TypeIsObject(o) && (typeof o[$iterator$] !== 'undefined' || isArguments(o));
    },

    GetIterator: function (o) {
      if (isArguments(o)) {
        // special case support for `arguments`
        return new ArrayIterator(o, 'value');
      }
      var itFn = o[$iterator$];
      if (!ES.IsCallable(itFn)) {
        throw new TypeError('value is not an iterable');
      }
      var it = itFn.call(o);
      if (!ES.TypeIsObject(it)) {
        throw new TypeError('bad iterator');
      }
      return it;
    },

    IteratorNext: function (it) {
      var result = arguments.length > 1 ? it.next(arguments[1]) : it.next();
      if (!ES.TypeIsObject(result)) {
        throw new TypeError('bad iterator');
      }
      return result;
    },

    Construct: function (C, args) {
      // CreateFromConstructor
      var obj;
      if (ES.IsCallable(C[symbolSpecies])) {
        obj = C[symbolSpecies]();
      } else {
        // OrdinaryCreateFromConstructor
        obj = create(C.prototype || null);
      }
      // Mark that we've used the es6 construct path
      // (see emulateES6construct)
      defineProperties(obj, { _es6construct: true });
      // Call the constructor.
      var result = ES.Call(C, obj, args);
      return ES.TypeIsObject(result) ? result : obj;
    },

    CreateHTML: function (string, tag, attribute, value) {
      var S = String(string);
      var p1 = '<' + tag;
      if (attribute !== '') {
        var V = String(value);
        var escapedV = V.replace(/"/g, '&quot;');
        p1 += ' ' + attribute + '="' + escapedV + '"';
      }
      var p2 = p1 + '>';
      var p3 = p2 + S;
      return p3 + '</' + tag + '>';
    }
  };

  var emulateES6construct = function (o) {
    if (!ES.TypeIsObject(o)) { throw new TypeError('bad object'); }
    // es5 approximation to es6 subclass semantics: in es6, 'new Foo'
    // would invoke Foo.@@species to allocation/initialize the new object.
    // In es5 we just get the plain object.  So if we detect an
    // uninitialized object, invoke o.constructor.@@species
    if (!o._es6construct) {
      if (o.constructor && ES.IsCallable(o.constructor[symbolSpecies])) {
        o = o.constructor[symbolSpecies](o);
      }
      defineProperties(o, { _es6construct: true });
    }
    return o;
  };


  var numberConversion = (function () {
    // from https://github.com/inexorabletash/polyfill/blob/master/typedarray.js#L176-L266
    // with permission and license, per https://twitter.com/inexorabletash/status/372206509540659200

    function roundToEven(n) {
      var w = Math.floor(n), f = n - w;
      if (f < 0.5) {
        return w;
      }
      if (f > 0.5) {
        return w + 1;
      }
      return w % 2 ? w + 1 : w;
    }

    function packIEEE754(v, ebits, fbits) {
      var bias = (1 << (ebits - 1)) - 1,
        s, e, f,
        i, bits, str, bytes;

      // Compute sign, exponent, fraction
      if (v !== v) {
        // NaN
        // http://dev.w3.org/2006/webapi/WebIDL/#es-type-mapping
        e = (1 << ebits) - 1;
        f = Math.pow(2, fbits - 1);
        s = 0;
      } else if (v === Infinity || v === -Infinity) {
        e = (1 << ebits) - 1;
        f = 0;
        s = (v < 0) ? 1 : 0;
      } else if (v === 0) {
        e = 0;
        f = 0;
        s = (1 / v === -Infinity) ? 1 : 0;
      } else {
        s = v < 0;
        v = Math.abs(v);

        if (v >= Math.pow(2, 1 - bias)) {
          e = Math.min(Math.floor(Math.log(v) / Math.LN2), 1023);
          f = roundToEven(v / Math.pow(2, e) * Math.pow(2, fbits));
          if (f / Math.pow(2, fbits) >= 2) {
            e = e + 1;
            f = 1;
          }
          if (e > bias) {
            // Overflow
            e = (1 << ebits) - 1;
            f = 0;
          } else {
            // Normal
            e = e + bias;
            f = f - Math.pow(2, fbits);
          }
        } else {
          // Subnormal
          e = 0;
          f = roundToEven(v / Math.pow(2, 1 - bias - fbits));
        }
      }

      // Pack sign, exponent, fraction
      bits = [];
      for (i = fbits; i; i -= 1) {
        bits.push(f % 2 ? 1 : 0);
        f = Math.floor(f / 2);
      }
      for (i = ebits; i; i -= 1) {
        bits.push(e % 2 ? 1 : 0);
        e = Math.floor(e / 2);
      }
      bits.push(s ? 1 : 0);
      bits.reverse();
      str = bits.join('');

      // Bits to bytes
      bytes = [];
      while (str.length) {
        bytes.push(parseInt(str.slice(0, 8), 2));
        str = str.slice(8);
      }
      return bytes;
    }

    function unpackIEEE754(bytes, ebits, fbits) {
      // Bytes to bits
      var bits = [], i, j, b, str,
          bias, s, e, f;

      for (i = bytes.length; i; i -= 1) {
        b = bytes[i - 1];
        for (j = 8; j; j -= 1) {
          bits.push(b % 2 ? 1 : 0);
          b = b >> 1;
        }
      }
      bits.reverse();
      str = bits.join('');

      // Unpack sign, exponent, fraction
      bias = (1 << (ebits - 1)) - 1;
      s = parseInt(str.slice(0, 1), 2) ? -1 : 1;
      e = parseInt(str.slice(1, 1 + ebits), 2);
      f = parseInt(str.slice(1 + ebits), 2);

      // Produce number
      if (e === (1 << ebits) - 1) {
        return f !== 0 ? NaN : s * Infinity;
      } else if (e > 0) {
        // Normalized
        return s * Math.pow(2, e - bias) * (1 + f / Math.pow(2, fbits));
      } else if (f !== 0) {
        // Denormalized
        return s * Math.pow(2, -(bias - 1)) * (f / Math.pow(2, fbits));
      } else {
        return s < 0 ? -0 : 0;
      }
    }

    function unpackFloat64(b) { return unpackIEEE754(b, 11, 52); }
    function packFloat64(v) { return packIEEE754(v, 11, 52); }
    function unpackFloat32(b) { return unpackIEEE754(b, 8, 23); }
    function packFloat32(v) { return packIEEE754(v, 8, 23); }

    var conversions = {
      toFloat32: function (num) { return unpackFloat32(packFloat32(num)); }
    };
    if (typeof Float32Array !== 'undefined') {
      var float32array = new Float32Array(1);
      conversions.toFloat32 = function (num) {
        float32array[0] = num;
        return float32array[0];
      };
    }
    return conversions;
  }());

  defineProperties(String, {
    fromCodePoint: function fromCodePoint(codePoints) {
      var result = [];
      var next;
      for (var i = 0, length = arguments.length; i < length; i++) {
        next = Number(arguments[i]);
        if (!ES.SameValue(next, ES.ToInteger(next)) || next < 0 || next > 0x10FFFF) {
          throw new RangeError('Invalid code point ' + next);
        }

        if (next < 0x10000) {
          result.push(String.fromCharCode(next));
        } else {
          next -= 0x10000;
          result.push(String.fromCharCode((next >> 10) + 0xD800));
          result.push(String.fromCharCode((next % 0x400) + 0xDC00));
        }
      }
      return result.join('');
    },

    raw: function raw(callSite) {
      var cooked = ES.ToObject(callSite, 'bad callSite');
      var rawValue = cooked.raw;
      var rawString = ES.ToObject(rawValue, 'bad raw value');
      var len = rawString.length;
      var literalsegments = ES.ToLength(len);
      if (literalsegments <= 0) {
        return '';
      }

      var stringElements = [];
      var nextIndex = 0;
      var nextKey, next, nextSeg, nextSub;
      while (nextIndex < literalsegments) {
        nextKey = String(nextIndex);
        next = rawString[nextKey];
        nextSeg = String(next);
        stringElements.push(nextSeg);
        if (nextIndex + 1 >= literalsegments) {
          break;
        }
        next = nextIndex + 1 < arguments.length ? arguments[nextIndex + 1] : '';
        nextSub = String(next);
        stringElements.push(nextSub);
        nextIndex++;
      }
      return stringElements.join('');
    }
  });

  // Firefox 31 reports this function's length as 0
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1062484
  if (String.fromCodePoint.length !== 1) {
    var originalFromCodePoint = Function.apply.bind(String.fromCodePoint);
    defineProperty(String, 'fromCodePoint', function fromCodePoint(codePoints) { return originalFromCodePoint(this, arguments); }, true);
  }

  // Fast repeat, uses the `Exponentiation by squaring` algorithm.
  // Perf: http://jsperf.com/string-repeat2/2
  var stringRepeat = function repeat(s, times) {
    if (times < 1) { return ''; }
    if (times % 2) { return repeat(s, times - 1) + s; }
    var half = repeat(s, times / 2);
    return half + half;
  };
  var stringMaxLength = Infinity;

  var StringShims = {
    repeat: function repeat(times) {
      ES.RequireObjectCoercible(this);
      var thisStr = String(this);
      times = ES.ToInteger(times);
      if (times < 0 || times >= stringMaxLength) {
        throw new RangeError('repeat count must be less than infinity and not overflow maximum string size');
      }
      return stringRepeat(thisStr, times);
    },

    startsWith: function (searchStr) {
      ES.RequireObjectCoercible(this);
      var thisStr = String(this);
      if (Type.regex(searchStr)) {
        throw new TypeError('Cannot call method "startsWith" with a regex');
      }
      searchStr = String(searchStr);
      var startArg = arguments.length > 1 ? arguments[1] : void 0;
      var start = Math.max(ES.ToInteger(startArg), 0);
      return thisStr.slice(start, start + searchStr.length) === searchStr;
    },

    endsWith: function (searchStr) {
      ES.RequireObjectCoercible(this);
      var thisStr = String(this);
      if (Type.regex(searchStr)) {
        throw new TypeError('Cannot call method "endsWith" with a regex');
      }
      searchStr = String(searchStr);
      var thisLen = thisStr.length;
      var posArg = arguments.length > 1 ? arguments[1] : void 0;
      var pos = typeof posArg === 'undefined' ? thisLen : ES.ToInteger(posArg);
      var end = Math.min(Math.max(pos, 0), thisLen);
      return thisStr.slice(end - searchStr.length, end) === searchStr;
    },

    includes: function includes(searchString) {
      var position = arguments.length > 1 ? arguments[1] : void 0;
      // Somehow this trick makes method 100% compat with the spec.
      return _indexOf(this, searchString, position) !== -1;
    },

    codePointAt: function (pos) {
      ES.RequireObjectCoercible(this);
      var thisStr = String(this);
      var position = ES.ToInteger(pos);
      var length = thisStr.length;
      if (position >= 0 && position < length) {
        var first = thisStr.charCodeAt(position);
        var isEnd = (position + 1 === length);
        if (first < 0xD800 || first > 0xDBFF || isEnd) { return first; }
        var second = thisStr.charCodeAt(position + 1);
        if (second < 0xDC00 || second > 0xDFFF) { return first; }
        return ((first - 0xD800) * 1024) + (second - 0xDC00) + 0x10000;
      }
    }
  };
  defineProperties(String.prototype, StringShims);

  var hasStringTrimBug = '\u0085'.trim().length !== 1;
  if (hasStringTrimBug) {
    delete String.prototype.trim;
    // whitespace from: http://es5.github.io/#x15.5.4.20
    // implementation from https://github.com/es-shims/es5-shim/blob/v3.4.0/es5-shim.js#L1304-L1324
    var ws = [
      '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u180E\u2000\u2001\u2002\u2003',
      '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028',
      '\u2029\uFEFF'
    ].join('');
    var trimRegexp = new RegExp('(^[' + ws + ']+)|([' + ws + ']+$)', 'g');
    defineProperties(String.prototype, {
      trim: function () {
        if (typeof this === 'undefined' || this === null) {
          throw new TypeError("can't convert " + this + ' to object');
        }
        return String(this).replace(trimRegexp, '');
      }
    });
  }

  // see https://people.mozilla.org/~jorendorff/es6-draft.html#sec-string.prototype-@@iterator
  var StringIterator = function (s) {
    ES.RequireObjectCoercible(s);
    this._s = String(s);
    this._i = 0;
  };
  StringIterator.prototype.next = function () {
    var s = this._s, i = this._i;
    if (typeof s === 'undefined' || i >= s.length) {
      this._s = void 0;
      return { value: void 0, done: true };
    }
    var first = s.charCodeAt(i), second, len;
    if (first < 0xD800 || first > 0xDBFF || (i + 1) === s.length) {
      len = 1;
    } else {
      second = s.charCodeAt(i + 1);
      len = (second < 0xDC00 || second > 0xDFFF) ? 1 : 2;
    }
    this._i = i + len;
    return { value: s.substr(i, len), done: false };
  };
  addIterator(StringIterator.prototype);
  addIterator(String.prototype, function () {
    return new StringIterator(this);
  });

  if (!startsWithIsCompliant) {
    // Firefox has a noncompliant startsWith implementation
    defineProperty(String.prototype, 'startsWith', StringShims.startsWith, true);
    defineProperty(String.prototype, 'endsWith', StringShims.endsWith, true);
  }

  var ArrayShims = {
    from: function from(iterable) {
      var mapFn = arguments.length > 1 ? arguments[1] : void 0;

      var list = ES.ToObject(iterable, 'bad iterable');
      if (typeof mapFn !== 'undefined' && !ES.IsCallable(mapFn)) {
        throw new TypeError('Array.from: when provided, the second argument must be a function');
      }

      var hasThisArg = arguments.length > 2;
      var thisArg = hasThisArg ? arguments[2] : void 0;

      var usingIterator = ES.IsIterable(list);
      // does the spec really mean that Arrays should use ArrayIterator?
      // https://bugs.ecmascript.org/show_bug.cgi?id=2416
      //if (Array.isArray(list)) { usingIterator=false; }

      var length;
      var result, i, value;
      if (usingIterator) {
        i = 0;
        result = ES.IsCallable(this) ? Object(new this()) : [];
        var it = usingIterator ? ES.GetIterator(list) : null;
        var iterationValue;

        do {
          iterationValue = ES.IteratorNext(it);
          if (!iterationValue.done) {
            value = iterationValue.value;
            if (mapFn) {
              result[i] = hasThisArg ? mapFn.call(thisArg, value, i) : mapFn(value, i);
            } else {
              result[i] = value;
            }
            i += 1;
          }
        } while (!iterationValue.done);
        length = i;
      } else {
        length = ES.ToLength(list.length);
        result = ES.IsCallable(this) ? Object(new this(length)) : new Array(length);
        for (i = 0; i < length; ++i) {
          value = list[i];
          if (mapFn) {
            result[i] = hasThisArg ? mapFn.call(thisArg, value, i) : mapFn(value, i);
          } else {
            result[i] = value;
          }
        }
      }

      result.length = length;
      return result;
    },

    of: function of() {
      return Array.from.call(this, arguments);
    }
  };
  defineProperties(Array, ArrayShims);

  var arrayFromSwallowsNegativeLengths = function () {
    try {
      return Array.from({ length: -1 }).length === 0;
    } catch (e) {
      return false;
    }
  };
  // Fixes a Firefox bug in v32
  // https://bugzilla.mozilla.org/show_bug.cgi?id=1063993
  if (!arrayFromSwallowsNegativeLengths()) {
    defineProperty(Array, 'from', ArrayShims.from, true);
  }

  // Given an argument x, it will return an IteratorResult object,
  // with value set to x and done to false.
  // Given no arguments, it will return an iterator completion object.
  var iterator_result = function (x) {
    return { value: x, done: arguments.length === 0 };
  };

  // Our ArrayIterator is private; see
  // https://github.com/paulmillr/es6-shim/issues/252
  ArrayIterator = function (array, kind) {
      this.i = 0;
      this.array = array;
      this.kind = kind;
  };

  defineProperties(ArrayIterator.prototype, {
    next: function () {
      var i = this.i, array = this.array;
      if (!(this instanceof ArrayIterator)) {
        throw new TypeError('Not an ArrayIterator');
      }
      if (typeof array !== 'undefined') {
        var len = ES.ToLength(array.length);
        for (; i < len; i++) {
          var kind = this.kind;
          var retval;
          if (kind === 'key') {
            retval = i;
          } else if (kind === 'value') {
            retval = array[i];
          } else if (kind === 'entry') {
            retval = [i, array[i]];
          }
          this.i = i + 1;
          return { value: retval, done: false };
        }
      }
      this.array = void 0;
      return { value: void 0, done: true };
    }
  });
  addIterator(ArrayIterator.prototype);

  var ObjectIterator = function (object, kind) {
    this.object = object;
    // Don't generate keys yet.
    this.array = null;
    this.kind = kind;
  };

  function getAllKeys(object) {
    var keys = [];

    for (var key in object) {
      keys.push(key);
    }

    return keys;
  }

  defineProperties(ObjectIterator.prototype, {
    next: function () {
      var key, array = this.array;

      if (!(this instanceof ObjectIterator)) {
        throw new TypeError('Not an ObjectIterator');
      }

      // Keys not generated
      if (array === null) {
        array = this.array = getAllKeys(this.object);
      }

      // Find next key in the object
      while (ES.ToLength(array.length) > 0) {
        key = array.shift();

        // The candidate key isn't defined on object.
        // Must have been deleted, or object[[Prototype]]
        // has been modified.
        if (!(key in this.object)) {
          continue;
        }

        if (this.kind === 'key') {
          return iterator_result(key);
        } else if (this.kind === 'value') {
          return iterator_result(this.object[key]);
        } else {
          return iterator_result([key, this.object[key]]);
        }
      }

      return iterator_result();
    }
  });
  addIterator(ObjectIterator.prototype);

  var ArrayPrototypeShims = {
    copyWithin: function copyWithin(target, start) {
      var end = arguments[2]; // copyWithin.length must be 2
      var o = ES.ToObject(this);
      var len = ES.ToLength(o.length);
      target = ES.ToInteger(target);
      start = ES.ToInteger(start);
      var to = target < 0 ? Math.max(len + target, 0) : Math.min(target, len);
      var from = start < 0 ? Math.max(len + start, 0) : Math.min(start, len);
      end = typeof end === 'undefined' ? len : ES.ToInteger(end);
      var fin = end < 0 ? Math.max(len + end, 0) : Math.min(end, len);
      var count = Math.min(fin - from, len - to);
      var direction = 1;
      if (from < to && to < (from + count)) {
        direction = -1;
        from += count - 1;
        to += count - 1;
      }
      while (count > 0) {
        if (_hasOwnProperty(o, from)) {
          o[to] = o[from];
        } else {
          delete o[from];
        }
        from += direction;
        to += direction;
        count -= 1;
      }
      return o;
    },

    fill: function fill(value) {
      var start = arguments.length > 1 ? arguments[1] : void 0;
      var end = arguments.length > 2 ? arguments[2] : void 0;
      var O = ES.ToObject(this);
      var len = ES.ToLength(O.length);
      start = ES.ToInteger(typeof start === 'undefined' ? 0 : start);
      end = ES.ToInteger(typeof end === 'undefined' ? len : end);

      var relativeStart = start < 0 ? Math.max(len + start, 0) : Math.min(start, len);
      var relativeEnd = end < 0 ? len + end : end;

      for (var i = relativeStart; i < len && i < relativeEnd; ++i) {
        O[i] = value;
      }
      return O;
    },

    find: function find(predicate) {
      var list = ES.ToObject(this);
      var length = ES.ToLength(list.length);
      if (!ES.IsCallable(predicate)) {
        throw new TypeError('Array#find: predicate must be a function');
      }
      var thisArg = arguments.length > 1 ? arguments[1] : null;
      for (var i = 0, value; i < length; i++) {
        value = list[i];
        if (thisArg) {
          if (predicate.call(thisArg, value, i, list)) { return value; }
        } else if (predicate(value, i, list)) {
          return value;
        }
      }
    },

    findIndex: function findIndex(predicate) {
      var list = ES.ToObject(this);
      var length = ES.ToLength(list.length);
      if (!ES.IsCallable(predicate)) {
        throw new TypeError('Array#findIndex: predicate must be a function');
      }
      var thisArg = arguments.length > 1 ? arguments[1] : null;
      for (var i = 0; i < length; i++) {
        if (thisArg) {
          if (predicate.call(thisArg, list[i], i, list)) { return i; }
        } else if (predicate(list[i], i, list)) {
          return i;
        }
      }
      return -1;
    },

    keys: function keys() {
      return new ArrayIterator(this, 'key');
    },

    values: function values() {
      return new ArrayIterator(this, 'value');
    },

    entries: function entries() {
      return new ArrayIterator(this, 'entry');
    }
  };
  // Safari 7.1 defines Array#keys and Array#entries natively,
  // but the resulting ArrayIterator objects don't have a "next" method.
  if (Array.prototype.keys && !ES.IsCallable([1].keys().next)) {
    delete Array.prototype.keys;
  }
  if (Array.prototype.entries && !ES.IsCallable([1].entries().next)) {
    delete Array.prototype.entries;
  }

  // Chrome 38 defines Array#keys and Array#entries, and Array#@@iterator, but not Array#values
  if (Array.prototype.keys && Array.prototype.entries && !Array.prototype.values && Array.prototype[$iterator$]) {
    defineProperties(Array.prototype, {
      values: Array.prototype[$iterator$]
    });
    if (Type.symbol(Symbol.unscopables)) {
      Array.prototype[Symbol.unscopables].values = true;
    }
  }
  // Chrome 40 defines Array#values with the incorrect name, although Array#{keys,entries} have the correct name
  if (Array.prototype.values && Array.prototype.values.name !== 'values') {
    var originalArrayPrototypeValues = Array.prototype.values;
    defineProperty(Array.prototype, 'values', function values() { return originalArrayPrototypeValues.call(this); }, true);
    defineProperty(Array.prototype, $iterator$, Array.prototype.values, true);
    Value.preserveToString(Array.prototype.values, originalArrayPrototypeValues);
  }
  defineProperties(Array.prototype, ArrayPrototypeShims);

  addIterator(Array.prototype, function () { return this.values(); });
  // Chrome defines keys/values/entries on Array, but doesn't give us
  // any way to identify its iterator.  So add our own shimmed field.
  if (Object.getPrototypeOf) {
    addIterator(Object.getPrototypeOf([].values()));
  }

  var maxSafeInteger = Math.pow(2, 53) - 1;
  defineProperties(Number, {
    MAX_SAFE_INTEGER: maxSafeInteger,
    MIN_SAFE_INTEGER: -maxSafeInteger,
    EPSILON: 2.220446049250313e-16,

    parseInt: globals.parseInt,
    parseFloat: globals.parseFloat,

    isFinite: function (value) {
      return typeof value === 'number' && global_isFinite(value);
    },

    isInteger: function (value) {
      return Number.isFinite(value) && ES.ToInteger(value) === value;
    },

    isSafeInteger: function (value) {
      return Number.isInteger(value) && Math.abs(value) <= Number.MAX_SAFE_INTEGER;
    },

    isNaN: function (value) {
      // NaN !== NaN, but they are identical.
      // NaNs are the only non-reflexive value, i.e., if x !== x,
      // then x is NaN.
      // isNaN is broken: it converts its argument to number, so
      // isNaN('foo') => true
      return value !== value;
    }
  });

  // Work around bugs in Array#find and Array#findIndex -- early
  // implementations skipped holes in sparse arrays. (Note that the
  // implementations of find/findIndex indirectly use shimmed
  // methods of Number, so this test has to happen down here.)
  /*jshint elision: true */
  if (![, 1].find(function (item, idx) { return idx === 0; })) {
    defineProperty(Array.prototype, 'find', ArrayPrototypeShims.find, true);
  }
  if ([, 1].findIndex(function (item, idx) { return idx === 0; }) !== 0) {
    defineProperty(Array.prototype, 'findIndex', ArrayPrototypeShims.findIndex, true);
  }
  /*jshint elision: false */

  if (supportsDescriptors) {
    defineProperties(Object, {
      // 19.1.3.1
      assign: function (target, source) {
        if (!ES.TypeIsObject(target)) {
          throw new TypeError('target must be an object');
        }
        return Array.prototype.reduce.call(arguments, function (target, source) {
          return Object.keys(Object(source)).reduce(function (target, key) {
            target[key] = source[key];
            return target;
          }, target);
        });
      },

      is: function (a, b) {
        return ES.SameValue(a, b);
      },

      // 19.1.3.9
      // shim from https://gist.github.com/WebReflection/5593554
      setPrototypeOf: (function (Object, magic) {
        var set;

        var checkArgs = function (O, proto) {
          if (!ES.TypeIsObject(O)) {
            throw new TypeError('cannot set prototype on a non-object');
          }
          if (!(proto === null || ES.TypeIsObject(proto))) {
            throw new TypeError('can only set prototype to an object or null' + proto);
          }
        };

        var setPrototypeOf = function (O, proto) {
          checkArgs(O, proto);
          set.call(O, proto);
          return O;
        };

        try {
          // this works already in Firefox and Safari
          set = Object.getOwnPropertyDescriptor(Object.prototype, magic).set;
          set.call({}, null);
        } catch (e) {
          if (Object.prototype !== {}[magic]) {
            // IE < 11 cannot be shimmed
            return;
          }
          // probably Chrome or some old Mobile stock browser
          set = function (proto) {
            this[magic] = proto;
          };
          // please note that this will **not** work
          // in those browsers that do not inherit
          // __proto__ by mistake from Object.prototype
          // in these cases we should probably throw an error
          // or at least be informed about the issue
          setPrototypeOf.polyfill = setPrototypeOf(
            setPrototypeOf({}, null),
            Object.prototype
          ) instanceof Object;
          // setPrototypeOf.polyfill === true means it works as meant
          // setPrototypeOf.polyfill === false means it's not 100% reliable
          // setPrototypeOf.polyfill === undefined
          // or
          // setPrototypeOf.polyfill ==  null means it's not a polyfill
          // which means it works as expected
          // we can even delete Object.prototype.__proto__;
        }
        return setPrototypeOf;
      }(Object, '__proto__'))
    });
  }

  // Workaround bug in Opera 12 where setPrototypeOf(x, null) doesn't work,
  // but Object.create(null) does.
  if (Object.setPrototypeOf && Object.getPrototypeOf &&
      Object.getPrototypeOf(Object.setPrototypeOf({}, null)) !== null &&
      Object.getPrototypeOf(Object.create(null)) === null) {
    (function () {
      var FAKENULL = Object.create(null);
      var gpo = Object.getPrototypeOf, spo = Object.setPrototypeOf;
      Object.getPrototypeOf = function (o) {
        var result = gpo(o);
        return result === FAKENULL ? null : result;
      };
      Object.setPrototypeOf = function (o, p) {
        if (p === null) { p = FAKENULL; }
        return spo(o, p);
      };
      Object.setPrototypeOf.polyfill = false;
    }());
  }

  var objectKeysAcceptsPrimitives = (function () {
    try {
      Object.keys('foo');
      return true;
    } catch (e) {
      return false;
    }
  }());
  if (!objectKeysAcceptsPrimitives) {
    var originalObjectKeys = Object.keys;
    defineProperty(Object, 'keys', function keys(value) {
      return originalObjectKeys(ES.ToObject(value));
    }, true);
    Value.preserveToString(Object.keys, originalObjectKeys);
  }

  if (Object.getOwnPropertyNames) {
    var objectGOPNAcceptsPrimitives = (function () {
      try {
        Object.getOwnPropertyNames('foo');
        return true;
      } catch (e) {
        return false;
      }
    }());
    if (!objectGOPNAcceptsPrimitives) {
      var originalObjectGetOwnPropertyNames = Object.getOwnPropertyNames;
      defineProperty(Object, 'getOwnPropertyNames', function getOwnPropertyNames(value) {
        return originalObjectGetOwnPropertyNames(ES.ToObject(value));
      }, true);
      Value.preserveToString(Object.getOwnPropertyNames, originalObjectGetOwnPropertyNames);
    }
  }
  if (Object.getOwnPropertyDescriptor) {
    var objectGOPDAcceptsPrimitives = (function () {
      try {
        Object.getOwnPropertyDescriptor('foo', 'bar');
        return true;
      } catch (e) {
        return false;
      }
    }());
    if (!objectGOPDAcceptsPrimitives) {
      var originalObjectGetOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;
      defineProperty(Object, 'getOwnPropertyDescriptor', function getOwnPropertyDescriptor(value, property) {
        return originalObjectGetOwnPropertyDescriptor(ES.ToObject(value), property);
      }, true);
      Value.preserveToString(Object.getOwnPropertyDescriptor, originalObjectGetOwnPropertyDescriptor);
    }
  }
  if (Object.seal) {
    var objectSealAcceptsPrimitives = (function () {
      try {
        Object.seal('foo');
        return true;
      } catch (e) {
        return false;
      }
    }());
    if (!objectSealAcceptsPrimitives) {
      var originalObjectSeal = Object.seal;
      defineProperty(Object, 'seal', function seal(value) {
        if (!Type.object(value)) { return value; }
        return originalObjectSeal(value);
      }, true);
      Value.preserveToString(Object.seal, originalObjectSeal);
    }
  }
  if (Object.isSealed) {
    var objectIsSealedAcceptsPrimitives = (function () {
      try {
        Object.isSealed('foo');
        return true;
      } catch (e) {
        return false;
      }
    }());
    if (!objectIsSealedAcceptsPrimitives) {
      var originalObjectIsSealed = Object.isSealed;
      defineProperty(Object, 'isSealed', function isSealed(value) {
        if (!Type.object(value)) { return true; }
        return originalObjectIsSealed(value);
      }, true);
      Value.preserveToString(Object.isSealed, originalObjectIsSealed);
    }
  }
  if (Object.freeze) {
    var objectFreezeAcceptsPrimitives = (function () {
      try {
        Object.freeze('foo');
        return true;
      } catch (e) {
        return false;
      }
    }());
    if (!objectFreezeAcceptsPrimitives) {
      var originalObjectFreeze = Object.freeze;
      defineProperty(Object, 'freeze', function freeze(value) {
        if (!Type.object(value)) { return value; }
        return originalObjectFreeze(value);
      }, true);
      Value.preserveToString(Object.freeze, originalObjectFreeze);
    }
  }
  if (Object.isFrozen) {
    var objectIsFrozenAcceptsPrimitives = (function () {
      try {
        Object.isFrozen('foo');
        return true;
      } catch (e) {
        return false;
      }
    }());
    if (!objectIsFrozenAcceptsPrimitives) {
      var originalObjectIsFrozen = Object.isFrozen;
      defineProperty(Object, 'isFrozen', function isFrozen(value) {
        if (!Type.object(value)) { return true; }
        return originalObjectIsFrozen(value);
      }, true);
      Value.preserveToString(Object.isFrozen, originalObjectIsFrozen);
    }
  }
  if (Object.preventExtensions) {
    var objectPreventExtensionsAcceptsPrimitives = (function () {
      try {
        Object.preventExtensions('foo');
        return true;
      } catch (e) {
        return false;
      }
    }());
    if (!objectPreventExtensionsAcceptsPrimitives) {
      var originalObjectPreventExtensions = Object.preventExtensions;
      defineProperty(Object, 'preventExtensions', function preventExtensions(value) {
        if (!Type.object(value)) { return value; }
        return originalObjectPreventExtensions(value);
      }, true);
      Value.preserveToString(Object.preventExtensions, originalObjectPreventExtensions);
    }
  }
  if (Object.isExtensible) {
    var objectIsExtensibleAcceptsPrimitives = (function () {
      try {
        Object.isExtensible('foo');
        return true;
      } catch (e) {
        return false;
      }
    }());
    if (!objectIsExtensibleAcceptsPrimitives) {
      var originalObjectIsExtensible = Object.isExtensible;
      defineProperty(Object, 'isExtensible', function isExtensible(value) {
        if (!Type.object(value)) { return false; }
        return originalObjectIsExtensible(value);
      }, true);
      Value.preserveToString(Object.isExtensible, originalObjectIsExtensible);
    }
  }
  if (Object.getPrototypeOf) {
    var objectGetProtoAcceptsPrimitives = (function () {
      try {
        Object.getPrototypeOf('foo');
        return true;
      } catch (e) {
        return false;
      }
    }());
    if (!objectGetProtoAcceptsPrimitives) {
      var originalGetProto = Object.getPrototypeOf;
      defineProperty(Object, 'getPrototypeOf', function getPrototypeOf(value) {
        return originalGetProto(ES.ToObject(value));
      }, true);
      Value.preserveToString(Object.getPrototypeOf, originalGetProto);
    }
  }

  if (!RegExp.prototype.flags && supportsDescriptors) {
    var regExpFlagsGetter = function flags() {
      if (!ES.TypeIsObject(this)) {
        throw new TypeError('Method called on incompatible type: must be an object.');
      }
      var result = '';
      if (this.global) {
        result += 'g';
      }
      if (this.ignoreCase) {
        result += 'i';
      }
      if (this.multiline) {
        result += 'm';
      }
      if (this.unicode) {
        result += 'u';
      }
      if (this.sticky) {
        result += 'y';
      }
      return result;
    };

    Value.getter(RegExp.prototype, 'flags', regExpFlagsGetter);
  }

  var regExpSupportsFlagsWithRegex = (function () {
    try {
      return String(new RegExp(/a/g, 'i')) === '/a/i';
    } catch (e) {
      return false;
    }
  }());

  if (!regExpSupportsFlagsWithRegex && supportsDescriptors) {
    var OrigRegExp = RegExp;
    var RegExpShim = function RegExp(pattern, flags) {
      if (Type.regex(pattern) && Type.string(flags)) {
        return new RegExp(pattern.source, flags);
      }
      return new OrigRegExp(pattern, flags);
    };
    Value.preserveToString(RegExpShim, OrigRegExp);
    if (Object.setPrototypeOf) {
      // sets up proper prototype chain where possible
      Object.setPrototypeOf(OrigRegExp, RegExpShim);
    }
    Object.getOwnPropertyNames(OrigRegExp).forEach(function (key) {
      if (key === '$input') { return; } // Chrome < v39 & Opera < 26 have a nonstandard "$input" property
      if (key in noop) { return; }
      Value.proxy(OrigRegExp, key, RegExpShim);
    });
    RegExpShim.prototype = OrigRegExp.prototype;
    Value.redefine(OrigRegExp.prototype, 'constructor', RegExpShim);
    /*globals RegExp: true */
    RegExp = RegExpShim;
    Value.redefine(globals, 'RegExp', RegExpShim);
    /*globals RegExp: false */
  }

  var MathShims = {
    acosh: function (value) {
      var x = Number(value);
      if (Number.isNaN(x) || value < 1) { return NaN; }
      if (x === 1) { return 0; }
      if (x === Infinity) { return x; }
      return Math.log(x / Math.E + Math.sqrt(x + 1) * Math.sqrt(x - 1) / Math.E) + 1;
    },

    asinh: function (value) {
      value = Number(value);
      if (value === 0 || !global_isFinite(value)) {
        return value;
      }
      return value < 0 ? -Math.asinh(-value) : Math.log(value + Math.sqrt(value * value + 1));
    },

    atanh: function (value) {
      value = Number(value);
      if (Number.isNaN(value) || value < -1 || value > 1) {
        return NaN;
      }
      if (value === -1) { return -Infinity; }
      if (value === 1) { return Infinity; }
      if (value === 0) { return value; }
      return 0.5 * Math.log((1 + value) / (1 - value));
    },

    cbrt: function (value) {
      value = Number(value);
      if (value === 0) { return value; }
      var negate = value < 0, result;
      if (negate) { value = -value; }
      result = Math.pow(value, 1 / 3);
      return negate ? -result : result;
    },

    clz32: function (value) {
      // See https://bugs.ecmascript.org/show_bug.cgi?id=2465
      value = Number(value);
      var number = ES.ToUint32(value);
      if (number === 0) {
        return 32;
      }
      return 32 - (number).toString(2).length;
    },

    cosh: function (value) {
      value = Number(value);
      if (value === 0) { return 1; } // +0 or -0
      if (Number.isNaN(value)) { return NaN; }
      if (!global_isFinite(value)) { return Infinity; }
      if (value < 0) { value = -value; }
      if (value > 21) { return Math.exp(value) / 2; }
      return (Math.exp(value) + Math.exp(-value)) / 2;
    },

    expm1: function (value) {
      var x = Number(value);
      if (x === -Infinity) { return -1; }
      if (!global_isFinite(x) || value === 0) { return x; }
      if (Math.abs(x) > 0.5) {
        return Math.exp(x) - 1;
      }
      // A more precise approximation using Taylor series expansion
      // from https://github.com/paulmillr/es6-shim/issues/314#issuecomment-70293986
      var t = x;
      var sum = 0;
      var n = 1;
      while (sum + t !== sum) {
        sum += t;
        n += 1;
        t *= x / n;
      }
      return sum;
    },

    hypot: function (x, y) {
      var anyNaN = false;
      var allZero = true;
      var anyInfinity = false;
      var numbers = [];
      Array.prototype.every.call(arguments, function (arg) {
        var num = Number(arg);
        if (Number.isNaN(num)) {
          anyNaN = true;
        } else if (num === Infinity || num === -Infinity) {
          anyInfinity = true;
        } else if (num !== 0) {
          allZero = false;
        }
        if (anyInfinity) {
          return false;
        } else if (!anyNaN) {
          numbers.push(Math.abs(num));
        }
        return true;
      });
      if (anyInfinity) { return Infinity; }
      if (anyNaN) { return NaN; }
      if (allZero) { return 0; }

      numbers.sort(function (a, b) { return b - a; });
      var largest = numbers[0];
      var divided = numbers.map(function (number) { return number / largest; });
      var sum = divided.reduce(function (sum, number) { return sum + (number * number); }, 0);
      return largest * Math.sqrt(sum);
    },

    log2: function (value) {
      return Math.log(value) * Math.LOG2E;
    },

    log10: function (value) {
      return Math.log(value) * Math.LOG10E;
    },

    log1p: function (value) {
      var x = Number(value);
      if (x < -1 || Number.isNaN(x)) { return NaN; }
      if (x === 0 || x === Infinity) { return x; }
      if (x === -1) { return -Infinity; }

      return (1 + x) - 1 === 0 ? x : x * (Math.log(1 + x) / ((1 + x) - 1));
    },

    sign: function (value) {
      var number = +value;
      if (number === 0) { return number; }
      if (Number.isNaN(number)) { return number; }
      return number < 0 ? -1 : 1;
    },

    sinh: function (value) {
      var x = Number(value);
      if (!global_isFinite(value) || value === 0) { return value; }

      if (Math.abs(x) < 1) {
        return (Math.expm1(x) - Math.expm1(-x)) / 2;
      }
      return (Math.exp(x - 1) - Math.exp(-x - 1)) * Math.E / 2;
    },

    tanh: function (value) {
      var x = Number(value);
      if (Number.isNaN(value) || x === 0) { return x; }
      if (x === Infinity) { return 1; }
      if (x === -Infinity) { return -1; }
      var a = Math.expm1(x);
      var b = Math.expm1(-x);
      if (a === Infinity) { return 1; }
      if (b === Infinity) { return -1; }
      return (a - b) / (Math.exp(x) + Math.exp(-x));
    },

    trunc: function (value) {
      var number = Number(value);
      return number < 0 ? -Math.floor(-number) : Math.floor(number);
    },

    imul: function (x, y) {
      // taken from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/imul
      x = ES.ToUint32(x);
      y = ES.ToUint32(y);
      var ah = (x >>> 16) & 0xffff;
      var al = x & 0xffff;
      var bh = (y >>> 16) & 0xffff;
      var bl = y & 0xffff;
      // the shift by 0 fixes the sign on the high part
      // the final |0 converts the unsigned value into a signed value
      return ((al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0);
    },

    fround: function (x) {
      if (x === 0 || x === Infinity || x === -Infinity || Number.isNaN(x)) {
        return x;
      }
      var num = Number(x);
      return numberConversion.toFloat32(num);
    }
  };
  defineProperties(Math, MathShims);
  // Chrome 40 has an imprecise Math.tanh with very small numbers
  defineProperty(Math, 'tanh', MathShims.tanh, Math.tanh(-2e-17) !== -2e-17);
  // Chrome 40 loses Math.acosh precision with high numbers
  defineProperty(Math, 'acosh', MathShims.acosh, Math.acosh(Number.MAX_VALUE) === Infinity);
  // node 0.11 has an imprecise Math.sinh with very small numbers
  defineProperty(Math, 'sinh', MathShims.sinh, Math.sinh(-2e-17) !== -2e-17);
  // FF 35 on Linux reports 22025.465794806725 for Math.expm1(10)
  var expm1OfTen = Math.expm1(10);
  defineProperty(Math, 'expm1', MathShims.expm1, expm1OfTen > 22025.465794806719 || expm1OfTen < 22025.4657948067165168);

  var roundHandlesBoundaryConditions = Math.round(0.5 - Number.EPSILON / 4) === 0 && Math.round(-0.5 + Number.EPSILON / 3.99) === 1;
  var origMathRound = Math.round;
  defineProperty(Math, 'round', function round(x) {
    if (-0.5 <= x && x < 0.5 && x !== 0) {
      return Math.sign(x * 0);
    }
    return origMathRound(x);
  }, !roundHandlesBoundaryConditions);

  if (Math.imul(0xffffffff, 5) !== -5) {
    // Safari 6.1, at least, reports "0" for this value
    Math.imul = MathShims.imul;
  }

  // Promises
  // Simplest possible implementation; use a 3rd-party library if you
  // want the best possible speed and/or long stack traces.
  var PromiseShim = (function () {

    var Promise, Promise$prototype;

    ES.IsPromise = function (promise) {
      if (!ES.TypeIsObject(promise)) {
        return false;
      }
      if (!promise._promiseConstructor) {
        // _promiseConstructor is a bit more unique than _status, so we'll
        // check that instead of the [[PromiseStatus]] internal field.
        return false;
      }
      if (typeof promise._status === 'undefined') {
        return false; // uninitialized
      }
      return true;
    };

    // "PromiseCapability" in the spec is what most promise implementations
    // call a "deferred".
    var PromiseCapability = function (C) {
      if (!ES.IsCallable(C)) {
        throw new TypeError('bad promise constructor');
      }
      var capability = this;
      var resolver = function (resolve, reject) {
        capability.resolve = resolve;
        capability.reject = reject;
      };
      capability.promise = ES.Construct(C, [resolver]);
      // see https://bugs.ecmascript.org/show_bug.cgi?id=2478
      if (!capability.promise._es6construct) {
        throw new TypeError('bad promise constructor');
      }
      if (!(ES.IsCallable(capability.resolve) && ES.IsCallable(capability.reject))) {
        throw new TypeError('bad promise constructor');
      }
    };

    // find an appropriate setImmediate-alike
    var setTimeout = globals.setTimeout;
    var makeZeroTimeout;
    /*global window */
    if (typeof window !== 'undefined' && ES.IsCallable(window.postMessage)) {
      makeZeroTimeout = function () {
        // from http://dbaron.org/log/20100309-faster-timeouts
        var timeouts = [];
        var messageName = 'zero-timeout-message';
        var setZeroTimeout = function (fn) {
          timeouts.push(fn);
          window.postMessage(messageName, '*');
        };
        var handleMessage = function (event) {
          if (event.source === window && event.data === messageName) {
            event.stopPropagation();
            if (timeouts.length === 0) { return; }
            var fn = timeouts.shift();
            fn();
          }
        };
        window.addEventListener('message', handleMessage, true);
        return setZeroTimeout;
      };
    }
    var makePromiseAsap = function () {
      // An efficient task-scheduler based on a pre-existing Promise
      // implementation, which we can use even if we override the
      // global Promise below (in order to workaround bugs)
      // https://github.com/Raynos/observ-hash/issues/2#issuecomment-35857671
      var P = globals.Promise;
      return P && P.resolve && function (task) {
        return P.resolve().then(task);
      };
    };
    /*global process */
    var enqueue = ES.IsCallable(globals.setImmediate) ?
      globals.setImmediate.bind(globals) :
      typeof process === 'object' && process.nextTick ? process.nextTick :
      makePromiseAsap() ||
      (ES.IsCallable(makeZeroTimeout) ? makeZeroTimeout() :
      function (task) { setTimeout(task, 0); }); // fallback

    var updatePromiseFromPotentialThenable = function (x, capability) {
      if (!ES.TypeIsObject(x)) {
        return false;
      }
      var resolve = capability.resolve;
      var reject = capability.reject;
      try {
        var then = x.then; // only one invocation of accessor
        if (!ES.IsCallable(then)) { return false; }
        then.call(x, resolve, reject);
      } catch (e) {
        reject(e);
      }
      return true;
    };

    var triggerPromiseReactions = function (reactions, x) {
      reactions.forEach(function (reaction) {
        enqueue(function () {
          // PromiseReactionTask
          var handler = reaction.handler;
          var capability = reaction.capability;
          var resolve = capability.resolve;
          var reject = capability.reject;
          try {
            var result = handler(x);
            if (result === capability.promise) {
              throw new TypeError('self resolution');
            }
            var updateResult =
              updatePromiseFromPotentialThenable(result, capability);
            if (!updateResult) {
              resolve(result);
            }
          } catch (e) {
            reject(e);
          }
        });
      });
    };

    var promiseResolutionHandler = function (promise, onFulfilled, onRejected) {
      return function (x) {
        if (x === promise) {
          return onRejected(new TypeError('self resolution'));
        }
        var C = promise._promiseConstructor;
        var capability = new PromiseCapability(C);
        var updateResult = updatePromiseFromPotentialThenable(x, capability);
        if (updateResult) {
          return capability.promise.then(onFulfilled, onRejected);
        } else {
          return onFulfilled(x);
        }
      };
    };

    Promise = function (resolver) {
      var promise = this;
      promise = emulateES6construct(promise);
      if (!promise._promiseConstructor) {
        // we use _promiseConstructor as a stand-in for the internal
        // [[PromiseStatus]] field; it's a little more unique.
        throw new TypeError('bad promise');
      }
      if (typeof promise._status !== 'undefined') {
        throw new TypeError('promise already initialized');
      }
      // see https://bugs.ecmascript.org/show_bug.cgi?id=2482
      if (!ES.IsCallable(resolver)) {
        throw new TypeError('not a valid resolver');
      }
      promise._status = 'unresolved';
      promise._resolveReactions = [];
      promise._rejectReactions = [];

      var resolve = function (resolution) {
        if (promise._status !== 'unresolved') { return; }
        var reactions = promise._resolveReactions;
        promise._result = resolution;
        promise._resolveReactions = void 0;
        promise._rejectReactions = void 0;
        promise._status = 'has-resolution';
        triggerPromiseReactions(reactions, resolution);
      };
      var reject = function (reason) {
        if (promise._status !== 'unresolved') { return; }
        var reactions = promise._rejectReactions;
        promise._result = reason;
        promise._resolveReactions = void 0;
        promise._rejectReactions = void 0;
        promise._status = 'has-rejection';
        triggerPromiseReactions(reactions, reason);
      };
      try {
        resolver(resolve, reject);
      } catch (e) {
        reject(e);
      }
      return promise;
    };
    Promise$prototype = Promise.prototype;
    var _promiseAllResolver = function (index, values, capability, remaining) {
      var done = false;
      return function (x) {
        if (done) { return; } // protect against being called multiple times
        done = true;
        values[index] = x;
        if ((--remaining.count) === 0) {
          var resolve = capability.resolve;
          resolve(values); // call w/ this===undefined
        }
      };
    };

    defineProperty(Promise, symbolSpecies, function (obj) {
      var constructor = this;
      // AllocatePromise
      // The `obj` parameter is a hack we use for es5
      // compatibility.
      var prototype = constructor.prototype || Promise$prototype;
      obj = obj || create(prototype);
      defineProperties(obj, {
        _status: void 0,
        _result: void 0,
        _resolveReactions: void 0,
        _rejectReactions: void 0,
        _promiseConstructor: void 0
      });
      obj._promiseConstructor = constructor;
      return obj;
    });
    defineProperties(Promise, {
      all: function all(iterable) {
        var C = this;
        var capability = new PromiseCapability(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        try {
          if (!ES.IsIterable(iterable)) {
            throw new TypeError('bad iterable');
          }
          var it = ES.GetIterator(iterable);
          var values = [], remaining = { count: 1 };
          for (var index = 0; ; index++) {
            var next = ES.IteratorNext(it);
            if (next.done) {
              break;
            }
            var nextPromise = C.resolve(next.value);
            var resolveElement = _promiseAllResolver(
              index, values, capability, remaining
            );
            remaining.count++;
            nextPromise.then(resolveElement, capability.reject);
          }
          if ((--remaining.count) === 0) {
            resolve(values); // call w/ this===undefined
          }
        } catch (e) {
          reject(e);
        }
        return capability.promise;
      },

      race: function race(iterable) {
        var C = this;
        var capability = new PromiseCapability(C);
        var resolve = capability.resolve;
        var reject = capability.reject;
        try {
          if (!ES.IsIterable(iterable)) {
            throw new TypeError('bad iterable');
          }
          var it = ES.GetIterator(iterable);
          while (true) {
            var next = ES.IteratorNext(it);
            if (next.done) {
              // If iterable has no items, resulting promise will never
              // resolve; see:
              // https://github.com/domenic/promises-unwrapping/issues/75
              // https://bugs.ecmascript.org/show_bug.cgi?id=2515
              break;
            }
            var nextPromise = C.resolve(next.value);
            nextPromise.then(resolve, reject);
          }
        } catch (e) {
          reject(e);
        }
        return capability.promise;
      },

      reject: function reject(reason) {
        var C = this;
        var capability = new PromiseCapability(C);
        var rejectPromise = capability.reject;
        rejectPromise(reason); // call with this===undefined
        return capability.promise;
      },

      resolve: function resolve(v) {
        var C = this;
        if (ES.IsPromise(v)) {
          var constructor = v._promiseConstructor;
          if (constructor === C) { return v; }
        }
        var capability = new PromiseCapability(C);
        var resolvePromise = capability.resolve;
        resolvePromise(v); // call with this===undefined
        return capability.promise;
      }
    });

    defineProperties(Promise$prototype, {
      'catch': function (onRejected) {
        return this.then(void 0, onRejected);
      },

      then: function then(onFulfilled, onRejected) {
        var promise = this;
        if (!ES.IsPromise(promise)) { throw new TypeError('not a promise'); }
        // this.constructor not this._promiseConstructor; see
        // https://bugs.ecmascript.org/show_bug.cgi?id=2513
        var C = this.constructor;
        var capability = new PromiseCapability(C);
        if (!ES.IsCallable(onRejected)) {
          onRejected = function (e) { throw e; };
        }
        if (!ES.IsCallable(onFulfilled)) {
          onFulfilled = function (x) { return x; };
        }
        var resolutionHandler = promiseResolutionHandler(promise, onFulfilled, onRejected);
        var resolveReaction = { capability: capability, handler: resolutionHandler };
        var rejectReaction = { capability: capability, handler: onRejected };
        switch (promise._status) {
          case 'unresolved':
            promise._resolveReactions.push(resolveReaction);
            promise._rejectReactions.push(rejectReaction);
            break;
          case 'has-resolution':
            triggerPromiseReactions([resolveReaction], promise._result);
            break;
          case 'has-rejection':
            triggerPromiseReactions([rejectReaction], promise._result);
            break;
          default:
            throw new TypeError('unexpected');
        }
        return capability.promise;
      }
    });

    return Promise;
  }());

  // Chrome's native Promise has extra methods that it shouldn't have. Let's remove them.
  if (globals.Promise) {
    delete globals.Promise.accept;
    delete globals.Promise.defer;
    delete globals.Promise.prototype.chain;
  }

  // export the Promise constructor.
  defineProperties(globals, { Promise: PromiseShim });
  // In Chrome 33 (and thereabouts) Promise is defined, but the
  // implementation is buggy in a number of ways.  Let's check subclassing
  // support to see if we have a buggy implementation.
  var promiseSupportsSubclassing = supportsSubclassing(globals.Promise, function (S) {
    return S.resolve(42) instanceof S;
  });
  var promiseIgnoresNonFunctionThenCallbacks = (function () {
    try {
      globals.Promise.reject(42).then(null, 5).then(null, noop);
      return true;
    } catch (ex) {
      return false;
    }
  }());
  var promiseRequiresObjectContext = (function () {
    /*global Promise */
    try { Promise.call(3, noop); } catch (e) { return true; }
    return false;
  }());
  if (!promiseSupportsSubclassing || !promiseIgnoresNonFunctionThenCallbacks || !promiseRequiresObjectContext) {
    /*globals Promise: true */
    Promise = PromiseShim;
    /*globals Promise: false */
    defineProperty(globals, 'Promise', PromiseShim, true);
  }

  // Map and Set require a true ES5 environment
  // Their fast path also requires that the environment preserve
  // property insertion order, which is not guaranteed by the spec.
  var testOrder = function (a) {
    var b = Object.keys(a.reduce(function (o, k) {
      o[k] = true;
      return o;
    }, {}));
    return a.join(':') === b.join(':');
  };
  var preservesInsertionOrder = testOrder(['z', 'a', 'bb']);
  // some engines (eg, Chrome) only preserve insertion order for string keys
  var preservesNumericInsertionOrder = testOrder(['z', 1, 'a', '3', 2]);

  if (supportsDescriptors) {

    var fastkey = function fastkey(key) {
      if (!preservesInsertionOrder) {
        return null;
      }
      var type = typeof key;
      if (type === 'string') {
        return '$' + key;
      } else if (type === 'number') {
        // note that -0 will get coerced to "0" when used as a property key
        if (!preservesNumericInsertionOrder) {
          return 'n' + key;
        }
        return key;
      }
      return null;
    };

    var emptyObject = function emptyObject() {
      // accomodate some older not-quite-ES5 browsers
      return Object.create ? Object.create(null) : {};
    };

    var collectionShims = {
      Map: (function () {

        var empty = {};

        function MapEntry(key, value) {
          this.key = key;
          this.value = value;
          this.next = null;
          this.prev = null;
        }

        MapEntry.prototype.isRemoved = function () {
          return this.key === empty;
        };

        function MapIterator(map, kind) {
          this.head = map._head;
          this.i = this.head;
          this.kind = kind;
        }

        MapIterator.prototype = {
          next: function () {
            var i = this.i, kind = this.kind, head = this.head, result;
            if (typeof this.i === 'undefined') {
              return { value: void 0, done: true };
            }
            while (i.isRemoved() && i !== head) {
              // back up off of removed entries
              i = i.prev;
            }
            // advance to next unreturned element.
            while (i.next !== head) {
              i = i.next;
              if (!i.isRemoved()) {
                if (kind === 'key') {
                  result = i.key;
                } else if (kind === 'value') {
                  result = i.value;
                } else {
                  result = [i.key, i.value];
                }
                this.i = i;
                return { value: result, done: false };
              }
            }
            // once the iterator is done, it is done forever.
            this.i = void 0;
            return { value: void 0, done: true };
          }
        };
        addIterator(MapIterator.prototype);

        function Map(iterable) {
          var map = this;
          if (!ES.TypeIsObject(map)) {
            throw new TypeError("Constructor Map requires 'new'");
          }
          map = emulateES6construct(map);
          if (!map._es6map) {
            throw new TypeError('bad map');
          }

          var head = new MapEntry(null, null);
          // circular doubly-linked list.
          head.next = head.prev = head;

          defineProperties(map, {
            _head: head,
            _storage: emptyObject(),
            _size: 0
          });

          // Optionally initialize map from iterable
          if (typeof iterable !== 'undefined' && iterable !== null) {
            var it = ES.GetIterator(iterable);
            var adder = map.set;
            if (!ES.IsCallable(adder)) { throw new TypeError('bad map'); }
            while (true) {
              var next = ES.IteratorNext(it);
              if (next.done) { break; }
              var nextItem = next.value;
              if (!ES.TypeIsObject(nextItem)) {
                throw new TypeError('expected iterable of pairs');
              }
              adder.call(map, nextItem[0], nextItem[1]);
            }
          }
          return map;
        }
        var Map$prototype = Map.prototype;
        defineProperty(Map, symbolSpecies, function (obj) {
          var constructor = this;
          var prototype = constructor.prototype || Map$prototype;
          obj = obj || create(prototype);
          defineProperties(obj, { _es6map: true });
          return obj;
        });

        Value.getter(Map.prototype, 'size', function () {
          if (typeof this._size === 'undefined') {
            throw new TypeError('size method called on incompatible Map');
          }
          return this._size;
        });

        defineProperties(Map.prototype, {
          get: function (key) {
            var fkey = fastkey(key);
            if (fkey !== null) {
              // fast O(1) path
              var entry = this._storage[fkey];
              if (entry) {
                return entry.value;
              } else {
                return;
              }
            }
            var head = this._head, i = head;
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                return i.value;
              }
            }
          },

          has: function (key) {
            var fkey = fastkey(key);
            if (fkey !== null) {
              // fast O(1) path
              return typeof this._storage[fkey] !== 'undefined';
            }
            var head = this._head, i = head;
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                return true;
              }
            }
            return false;
          },

          set: function (key, value) {
            var head = this._head, i = head, entry;
            var fkey = fastkey(key);
            if (fkey !== null) {
              // fast O(1) path
              if (typeof this._storage[fkey] !== 'undefined') {
                this._storage[fkey].value = value;
                return this;
              } else {
                entry = this._storage[fkey] = new MapEntry(key, value);
                i = head.prev;
                // fall through
              }
            }
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                i.value = value;
                return this;
              }
            }
            entry = entry || new MapEntry(key, value);
            if (ES.SameValue(-0, key)) {
              entry.key = +0; // coerce -0 to +0 in entry
            }
            entry.next = this._head;
            entry.prev = this._head.prev;
            entry.prev.next = entry;
            entry.next.prev = entry;
            this._size += 1;
            return this;
          },

          'delete': function (key) {
            var head = this._head, i = head;
            var fkey = fastkey(key);
            if (fkey !== null) {
              // fast O(1) path
              if (typeof this._storage[fkey] === 'undefined') {
                return false;
              }
              i = this._storage[fkey].prev;
              delete this._storage[fkey];
              // fall through
            }
            while ((i = i.next) !== head) {
              if (ES.SameValueZero(i.key, key)) {
                i.key = i.value = empty;
                i.prev.next = i.next;
                i.next.prev = i.prev;
                this._size -= 1;
                return true;
              }
            }
            return false;
          },

          clear: function () {
            this._size = 0;
            this._storage = emptyObject();
            var head = this._head, i = head, p = i.next;
            while ((i = p) !== head) {
              i.key = i.value = empty;
              p = i.next;
              i.next = i.prev = head;
            }
            head.next = head.prev = head;
          },

          keys: function () {
            return new MapIterator(this, 'key');
          },

          values: function () {
            return new MapIterator(this, 'value');
          },

          entries: function () {
            return new MapIterator(this, 'key+value');
          },

          forEach: function (callback) {
            var context = arguments.length > 1 ? arguments[1] : null;
            var it = this.entries();
            for (var entry = it.next(); !entry.done; entry = it.next()) {
              if (context) {
                callback.call(context, entry.value[1], entry.value[0], this);
              } else {
                callback(entry.value[1], entry.value[0], this);
              }
            }
          }
        });
        addIterator(Map.prototype, function () { return this.entries(); });

        return Map;
      }()),

      Set: (function () {
        // Creating a Map is expensive.  To speed up the common case of
        // Sets containing only string or numeric keys, we use an object
        // as backing storage and lazily create a full Map only when
        // required.
        var SetShim = function Set(iterable) {
          var set = this;
          if (!ES.TypeIsObject(set)) {
            throw new TypeError("Constructor Set requires 'new'");
          }
          set = emulateES6construct(set);
          if (!set._es6set) {
            throw new TypeError('bad set');
          }

          defineProperties(set, {
            '[[SetData]]': null,
            _storage: emptyObject()
          });

          // Optionally initialize map from iterable
          if (typeof iterable !== 'undefined' && iterable !== null) {
            var it = ES.GetIterator(iterable);
            var adder = set.add;
            if (!ES.IsCallable(adder)) { throw new TypeError('bad set'); }
            while (true) {
              var next = ES.IteratorNext(it);
              if (next.done) { break; }
              var nextItem = next.value;
              adder.call(set, nextItem);
            }
          }
          return set;
        };
        var Set$prototype = SetShim.prototype;
        defineProperty(SetShim, symbolSpecies, function (obj) {
          var constructor = this;
          var prototype = constructor.prototype || Set$prototype;
          obj = obj || create(prototype);
          defineProperties(obj, { _es6set: true });
          return obj;
        });

        // Switch from the object backing storage to a full Map.
        var ensureMap = function ensureMap(set) {
          if (!set['[[SetData]]']) {
            var m = set['[[SetData]]'] = new collectionShims.Map();
            Object.keys(set._storage).forEach(function (k) {
              // fast check for leading '$'
              if (k.charCodeAt(0) === 36) {
                k = k.slice(1);
              } else if (k.charAt(0) === 'n') {
                k = +k.slice(1);
              } else {
                k = +k;
              }
              m.set(k, k);
            });
            set._storage = null; // free old backing storage
          }
        };

        Value.getter(SetShim.prototype, 'size', function () {
          if (typeof this._storage === 'undefined') {
            // https://github.com/paulmillr/es6-shim/issues/176
            throw new TypeError('size method called on incompatible Set');
          }
          ensureMap(this);
          return this['[[SetData]]'].size;
        });

        defineProperties(SetShim.prototype, {
          has: function (key) {
            var fkey;
            if (this._storage && (fkey = fastkey(key)) !== null) {
              return !!this._storage[fkey];
            }
            ensureMap(this);
            return this['[[SetData]]'].has(key);
          },

          add: function (key) {
            var fkey;
            if (this._storage && (fkey = fastkey(key)) !== null) {
              this._storage[fkey] = true;
              return this;
            }
            ensureMap(this);
            this['[[SetData]]'].set(key, key);
            return this;
          },

          'delete': function (key) {
            var fkey;
            if (this._storage && (fkey = fastkey(key)) !== null) {
              var hasFKey = _hasOwnProperty(this._storage, fkey);
              return (delete this._storage[fkey]) && hasFKey;
            }
            ensureMap(this);
            return this['[[SetData]]']['delete'](key);
          },

          clear: function () {
            if (this._storage) {
              this._storage = emptyObject();
            } else {
              this['[[SetData]]'].clear();
            }
          },

          values: function () {
            ensureMap(this);
            return this['[[SetData]]'].values();
          },

          entries: function () {
            ensureMap(this);
            return this['[[SetData]]'].entries();
          },

          forEach: function (callback) {
            var context = arguments.length > 1 ? arguments[1] : null;
            var entireSet = this;
            ensureMap(entireSet);
            this['[[SetData]]'].forEach(function (value, key) {
              if (context) {
                callback.call(context, key, key, entireSet);
              } else {
                callback(key, key, entireSet);
              }
            });
          }
        });
        defineProperty(SetShim, 'keys', SetShim.values, true);
        addIterator(SetShim.prototype, function () { return this.values(); });

        return SetShim;
      }())
    };
    defineProperties(globals, collectionShims);

    if (globals.Map || globals.Set) {
      /*
        - In Firefox < 23, Map#size is a function.
        - In all current Firefox, Set#entries/keys/values & Map#clear do not exist
        - https://bugzilla.mozilla.org/show_bug.cgi?id=869996
        - In Firefox 24, Map and Set do not implement forEach
        - In Firefox 25 at least, Map and Set are callable without "new"
      */
      if (
        typeof globals.Map.prototype.clear !== 'function' ||
        new globals.Set().size !== 0 ||
        new globals.Map().size !== 0 ||
        typeof globals.Map.prototype.keys !== 'function' ||
        typeof globals.Set.prototype.keys !== 'function' ||
        typeof globals.Map.prototype.forEach !== 'function' ||
        typeof globals.Set.prototype.forEach !== 'function' ||
        isCallableWithoutNew(globals.Map) ||
        isCallableWithoutNew(globals.Set) ||
        !supportsSubclassing(globals.Map, function (M) {
          var m = new M([]);
          // Firefox 32 is ok with the instantiating the subclass but will
          // throw when the map is used.
          m.set(42, 42);
          return m instanceof M;
        })
      ) {
        globals.Map = collectionShims.Map;
        globals.Set = collectionShims.Set;
      }
    }
    if (globals.Set.prototype.keys !== globals.Set.prototype.values) {
      defineProperty(globals.Set.prototype, 'keys', globals.Set.prototype.values, true);
    }
    // Shim incomplete iterator implementations.
    addIterator(Object.getPrototypeOf((new globals.Map()).keys()));
    addIterator(Object.getPrototypeOf((new globals.Set()).keys()));
  }

  // Reflect
  if (!globals.Reflect) {
    defineProperty(globals, 'Reflect', {});
  }
  var Reflect = globals.Reflect;

  var throwUnlessTargetIsObject = function throwUnlessTargetIsObject(target) {
    if (!ES.TypeIsObject(target)) {
      throw new TypeError('target must be an object');
    }
  };

  // Some Reflect methods are basically the same as
  // those on the Object global, except that a TypeError is thrown if
  // target isn't an object. As well as returning a boolean indicating
  // the success of the operation.
  defineProperties(globals.Reflect, {
    // Apply method in a functional form.
    apply: function apply() {
      return ES.Call.apply(null, arguments);
    },

    // New operator in a functional form.
    construct: function construct(constructor, args) {
      if (!ES.IsCallable(constructor)) {
        throw new TypeError('First argument must be callable.');
      }

      return ES.Construct(constructor, args);
    },

    // When deleting a non-existent or configurable property,
    // true is returned.
    // When attempting to delete a non-configurable property,
    // it will return false.
    deleteProperty: function deleteProperty(target, key) {
      throwUnlessTargetIsObject(target);
      if (supportsDescriptors) {
        var desc = Object.getOwnPropertyDescriptor(target, key);

        if (desc && !desc.configurable) {
          return false;
        }
      }

      // Will return true.
      return delete target[key];
    },

    enumerate: function enumerate(target) {
      throwUnlessTargetIsObject(target);
      return new ObjectIterator(target, 'key');
    },

    has: function has(target, key) {
      throwUnlessTargetIsObject(target);
      return key in target;
    }
  });

  if (Object.getOwnPropertyNames) {
    defineProperties(globals.Reflect, {
      // Basically the result of calling the internal [[OwnPropertyKeys]].
      // Concatenating propertyNames and propertySymbols should do the trick.
      // This should continue to work together with a Symbol shim
      // which overrides Object.getOwnPropertyNames and implements
      // Object.getOwnPropertySymbols.
      ownKeys: function ownKeys(target) {
        throwUnlessTargetIsObject(target);
        var keys = Object.getOwnPropertyNames(target);

        if (ES.IsCallable(Object.getOwnPropertySymbols)) {
          keys.push.apply(keys, Object.getOwnPropertySymbols(target));
        }

        return keys;
      }
    });
  }

  if (Object.preventExtensions) {
    defineProperties(globals.Reflect, {
      isExtensible: function isExtensible(target) {
        throwUnlessTargetIsObject(target);
        return Object.isExtensible(target);
      },
      preventExtensions: function preventExtensions(target) {
        throwUnlessTargetIsObject(target);
        return callAndCatchException(function () {
          Object.preventExtensions(target);
        });
      }
    });
  }

  if (supportsDescriptors) {
    var internal_get = function get(target, key, receiver) {
      var desc = Object.getOwnPropertyDescriptor(target, key);

      if (!desc) {
        var parent = Object.getPrototypeOf(target);

        if (parent === null) {
          return undefined;
        }

        return internal_get(parent, key, receiver);
      }

      if ('value' in desc) {
        return desc.value;
      }

      if (desc.get) {
        return desc.get.call(receiver);
      }

      return undefined;
    };

    var internal_set = function set(target, key, value, receiver) {
      var desc = Object.getOwnPropertyDescriptor(target, key);

      if (!desc) {
        var parent = Object.getPrototypeOf(target);

        if (parent !== null) {
          return internal_set(parent, key, value, receiver);
        }

        desc = {
          value: void 0,
          writable: true,
          enumerable: true,
          configurable: true
        };
      }

      if ('value' in desc) {
        if (!desc.writable) {
          return false;
        }

        if (!ES.TypeIsObject(receiver)) {
          return false;
        }

        var existingDesc = Object.getOwnPropertyDescriptor(receiver, key);

        if (existingDesc) {
          return Reflect.defineProperty(receiver, key, {
            value: value
          });
        } else {
          return Reflect.defineProperty(receiver, key, {
            value: value,
            writable: true,
            enumerable: true,
            configurable: true
          });
        }
      }

      if (desc.set) {
        desc.set.call(receiver, value);
        return true;
      }

      return false;
    };

    var callAndCatchException = function ConvertExceptionToBoolean(func) {
      try { func(); } catch (_) { return false; }
      return true;
    };

    defineProperties(globals.Reflect, {
      defineProperty: function defineProperty(target, propertyKey, attributes) {
        throwUnlessTargetIsObject(target);
        return callAndCatchException(function () {
          Object.defineProperty(target, propertyKey, attributes);
        });
      },

      getOwnPropertyDescriptor: function getOwnPropertyDescriptor(target, propertyKey) {
        throwUnlessTargetIsObject(target);
        return Object.getOwnPropertyDescriptor(target, propertyKey);
      },

      // Syntax in a functional form.
      get: function get(target, key) {
        throwUnlessTargetIsObject(target);
        var receiver = arguments.length > 2 ? arguments[2] : target;

        return internal_get(target, key, receiver);
      },

      set: function set(target, key, value) {
        throwUnlessTargetIsObject(target);
        var receiver = arguments.length > 3 ? arguments[3] : target;

        return internal_set(target, key, value, receiver);
      }
    });
  }

  if (Object.getPrototypeOf) {
    var objectDotGetPrototypeOf = Object.getPrototypeOf;
    defineProperties(globals.Reflect, {
      getPrototypeOf: function getPrototypeOf(target) {
        throwUnlessTargetIsObject(target);
        return objectDotGetPrototypeOf(target);
      }
    });
  }

  if (Object.setPrototypeOf) {
    var willCreateCircularPrototype = function (object, proto) {
      while (proto) {
        if (object === proto) {
          return true;
        }
        proto = Reflect.getPrototypeOf(proto);
      }
      return false;
    };

    defineProperties(globals.Reflect, {
      // Sets the prototype of the given object.
      // Returns true on success, otherwise false.
      setPrototypeOf: function setPrototypeOf(object, proto) {
        throwUnlessTargetIsObject(object);
        if (proto !== null && !ES.TypeIsObject(proto)) {
          throw new TypeError('proto must be an object or null');
        }

        // If they already are the same, we're done.
        if (proto === Reflect.getPrototypeOf(object)) {
          return true;
        }

        // Cannot alter prototype if object not extensible.
        if (Reflect.isExtensible && !Reflect.isExtensible(object)) {
          return false;
        }

        // Ensure that we do not create a circular prototype chain.
        if (willCreateCircularPrototype(object, proto)) {
          return false;
        }

        Object.setPrototypeOf(object, proto);

        return true;
      }
    });
  }

  if (String(new Date(NaN)) !== 'Invalid Date') {
    var dateToString = Date.prototype.toString;
    var shimmedDateToString = function toString() {
      var valueOf = +this;
      if (valueOf !== valueOf) {
        return 'Invalid Date';
      }
      return dateToString.call(this);
    };
    defineProperty(shimmedDateToString, 'toString', dateToString.toString, true);
    defineProperty(Date.prototype, 'toString', shimmedDateToString, true);
  }

  // Annex B HTML methods
  // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-additional-properties-of-the-string.prototype-object
  var stringHTMLshims = {
    anchor: function anchor(name) { return ES.CreateHTML(this, 'a', 'name', name); },
    big: function big() { return ES.CreateHTML(this, 'big', '', ''); },
    blink: function blink() { return ES.CreateHTML(this, 'blink', '', ''); },
    bold: function bold() { return ES.CreateHTML(this, 'b', '', ''); },
    fixed: function fixed() { return ES.CreateHTML(this, 'tt', '', ''); },
    fontcolor: function fontcolor(color) { return ES.CreateHTML(this, 'font', 'color', color); },
    fontsize: function fontsize(size) { return ES.CreateHTML(this, 'font', 'size', size); },
    italics: function italics() { return ES.CreateHTML(this, 'i', '', ''); },
    link: function link(url) { return ES.CreateHTML(this, 'a', 'href', url); },
    small: function small() { return ES.CreateHTML(this, 'small', '', ''); },
    strike: function strike() { return ES.CreateHTML(this, 'strike', '', ''); },
    sub: function sub() { return ES.CreateHTML(this, 'sub', '', ''); },
    sup: function sub() { return ES.CreateHTML(this, 'sup', '', ''); }
  };
  defineProperties(String.prototype, stringHTMLshims);
  Object.keys(stringHTMLshims).forEach(function (key) {
    var method = String.prototype[key];
    var shouldOverwrite = false;
    if (ES.IsCallable(method)) {
      var output = method.call('', ' " ');
      var quotesCount = [].concat(output.match(/"/g)).length;
      shouldOverwrite = output !== output.toLowerCase() || quotesCount > 2;
    } else {
      shouldOverwrite = true;
    }
    if (shouldOverwrite) {
      defineProperty(String.prototype, key, stringHTMLshims[key], true);
    }
  });

  return globals;
}));

// ***** ))) file end


}, nameIndexes: {}, result: initialModResult_674497323404793172}, {fun: function(exports, module, require) {


// *****
// ***** file-674497323404793172
// ***** (((

module.exports =

{
    "name": "mate",
    "version": "0.20.2",
    "description": "HTTP request, array extension, ES6 shim, event, observer, test, timer, etc. It extends the native JavaScript / CoffeeScript.",
    "keywords": [
        "event", "coffeescript", "timer", "observer", "observe", "binding",
        "array", "math", "complex", "javascript", "js", "coffee",
        "es6", "shim", "test", "testing", "request", "http", "promise",
        "es6 shims", "es6 shim",
        "array extensions", "array extension",
        "complex math", "complex number",
        "http request", "web request",
        "data binding"
    ],
    "author": "Zhenzhen Zhan <zhanzhenzhen@hotmail.com>",
    "homepage": "http://zizisoft.com/mate",
    "license": "MIT",
    "repository": {
        "type": "git",
        "url": "https://github.com/zhanzhenzhen/mate.git"
    },
    "dependencies": {
        "es6-shim": "0.27.1",
        "wishlist": "0.3.4"
    },
    "devDependencies": {
        "coffee-script": "1.9.1",
        "uglify-js": "2.4.19",
        "js-bundler": "0.6.0"
    },
    "main": "mate"
}


;

// ***** ))) file end


}, nameIndexes: {}, result: initialModResult_674497323404793172}, {fun: function(exports, module, require) {


// *****
// ***** file-674497323404793172
// ***** (((

// Generated by CoffeeScript 1.9.1

/* @license
Wishlist
https://github.com/zhanzhenzhen/wishlist
Copyright 2015 Zhenzhen Zhan
Released under the MIT license
 */

(function() {
  var wishlist,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };

  wishlist = {};

  wishlist.environmentType = (typeof exports !== "undefined" && exports !== null) && ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) && ((typeof process !== "undefined" && process !== null ? process.execPath : void 0) != null) && typeof process.execPath === "string" && process.execPath.search(/node/i) !== -1 ? "node" : (typeof window !== "undefined" && window !== null) && (typeof navigator !== "undefined" && navigator !== null) && (typeof HTMLElement !== "undefined" && HTMLElement !== null) ? "browser" : void 0;

  wishlist.moduleSystem = (typeof exports !== "undefined" && exports !== null) && ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) ? "commonjs" : null;

  wishlist.objectIs = function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      if (a === 0 && b === 0) {
        return 1 / a === 1 / b;
      } else if (isNaN(a) && isNaN(b)) {
        return true;
      } else {
        return a === b;
      }
    } else {
      return a === b;
    }
  };

  wishlist.objectClone = function(x) {
    var key, len, o, ref, y;
    y = {};
    ref = Object.keys(x);
    for (o = 0, len = ref.length; o < len; o++) {
      key = ref[o];
      y[key] = x[key];
    }
    return y;
  };

  wishlist.hasSameKeys = function(obj1, obj2) {
    var keys1, keys2;
    keys1 = Object.keys(obj1);
    keys2 = Object.keys(obj2);
    if (keys1.length !== keys2.length) {
      return false;
    } else {
      keys1.sort();
      keys2.sort();
      return keys1.every(function(key, index) {
        return keys2[index] === key;
      });
    }
  };

  wishlist.valueToMessage = function(value) {
    var internal, r;
    internal = function(value, maxLevel) {
      if (value === void 0) {
        return "undefined";
      } else if (value === null) {
        return "null";
      } else if (Array.isArray(value)) {
        if (maxLevel > 0) {
          return "[" + value.map(function(m) {
            return internal(m, maxLevel - 1);
          }).join(",") + "]";
        } else {
          return "[Array]";
        }
      } else if (typeof value === "function") {
        return "[Function]";
      } else if (typeof value === "object") {
        if (maxLevel > 0) {
          return "{" + Object.keys(value).map(function(m) {
            return ((JSON.stringify(m)) + ":") + internal(value[m], maxLevel - 1);
          }).join(",") + "}";
        } else {
          return "[Object]";
        }
      } else if (typeof value === "string") {
        return JSON.stringify(value.toString());
      } else if (typeof value === "number") {
        if (wishlist.objectIs(value, -0)) {
          return "-0";
        } else {
          return value.toString();
        }
      } else {
        return value.toString();
      }
    };
    r = internal(value, 3);
    if (r.length > 1000) {
      r = internal(value, 2);
    }
    if (r.length > 1000) {
      r = internal(value, 1);
    }
    if (r.length > 1000) {
      r = internal(value, 0);
    }
    return r;
  };

  wishlist.currentRootTest = null;

  wishlist.parseExpression = function(expStr, envNames) {
    var c, dotAffected, i, objectKeyReady, oldDotAffected, oldObjectKeyReady, oldSlashQuoteReady, oldWordStarted, positions, quote, regex, s, slashQuoteReady, wordStarted;
    expStr += " ";
    if (envNames.length === 0) {
      return [];
    }
    regex = new RegExp("^(" + envNames.join("|") + ")[^a-zA-Z0-9_$]", "g");
    positions = [];
    quote = null;
    slashQuoteReady = true;
    wordStarted = false;
    dotAffected = false;
    objectKeyReady = false;
    i = 0;
    while (i < expStr.length - 1) {
      c = expStr[i];
      oldSlashQuoteReady = slashQuoteReady;
      if (quote === null) {
        if (("a" <= c && c <= "z") || ("A" <= c && c <= "Z") || ("0" <= c && c <= "9") || c === "_" || c === "$" || c === ")" || c === "]") {
          slashQuoteReady = false;
        } else if (c === " " || c === "\t" || c === "\n" || c === "\r") {

        } else {
          slashQuoteReady = true;
        }
      }
      oldWordStarted = wordStarted;
      if (quote === null) {
        if (("a" <= c && c <= "z") || ("A" <= c && c <= "Z") || ("0" <= c && c <= "9") || c === "_" || c === "$" || c === ".") {
          wordStarted = true;
        } else {
          wordStarted = false;
        }
      }
      oldDotAffected = dotAffected;
      if (quote === null) {
        if (c === ".") {
          dotAffected = true;
        } else if (c === " " || c === "\t" || c === "\n" || c === "\r") {

        } else {
          dotAffected = false;
        }
      }
      oldObjectKeyReady = objectKeyReady;
      if (quote === null) {
        if (c === "{" || c === ",") {
          objectKeyReady = true;
        } else if (c === " " || c === "\t" || c === "\n" || c === "\r") {

        } else {
          objectKeyReady = false;
        }
      }
      if (c === "\"" && quote === null) {
        quote = "double";
        i++;
      } else if (c === "'" && quote === null) {
        quote = "single";
        i++;
      } else if (c === "/" && quote === null && oldSlashQuoteReady) {
        quote = "slash";
        i++;
      } else if ((c === "\"" && quote === "double") || (c === "'" && quote === "single") || (c === "/" && quote === "slash")) {
        quote = null;
        i++;
      } else if (c === "\\" && quote !== null) {
        i += 2;
      } else if (quote === null && !oldWordStarted && !oldDotAffected && (("a" <= c && c <= "z") || ("A" <= c && c <= "Z"))) {
        s = expStr.substr(i, 31);
        if (!(oldObjectKeyReady && s.search(/^([a-zA-Z0-9_$])+\s*:/) !== -1) && s.search(regex) !== -1) {
          positions.push(i);
        }
        i++;
      } else {
        i++;
      }
    }
    return positions;
  };

  wishlist.parseWish = function(wishStr) {
    var name, parsed;
    parsed = null;
    name = null;
    [0, 1].forEach(function(round) {
      var brace, bracket, c, dotAffected, i, match, oldDotAffected, oldSlashQuoteReady, parenthesis, quote, s, slashQuoteReady;
      quote = null;
      parenthesis = 0;
      bracket = 0;
      brace = 0;
      slashQuoteReady = true;
      dotAffected = false;
      i = 0;
      while (i < wishStr.length) {
        c = wishStr[i];
        oldSlashQuoteReady = slashQuoteReady;
        if (quote === null) {
          if (("a" <= c && c <= "z") || ("A" <= c && c <= "Z") || ("0" <= c && c <= "9") || c === "_" || c === "$" || c === ")" || c === "]") {
            slashQuoteReady = false;
          } else if (c === " " || c === "\t" || c === "\n" || c === "\r") {

          } else {
            slashQuoteReady = true;
          }
        }
        oldDotAffected = dotAffected;
        if (quote === null) {
          if (c === ".") {
            dotAffected = true;
          } else if (c === " " || c === "\t" || c === "\n" || c === "\r") {

          } else {
            dotAffected = false;
          }
        }
        if (c === "\"" && quote === null) {
          quote = "double";
          i++;
        } else if (c === "'" && quote === null) {
          quote = "single";
          i++;
        } else if (c === "/" && quote === null && oldSlashQuoteReady) {
          quote = "slash";
          i++;
        } else if ((c === "\"" && quote === "double") || (c === "'" && quote === "single") || (c === "/" && quote === "slash")) {
          quote = null;
          i++;
        } else if (c === "\\" && quote !== null) {
          i += 2;
        } else if (c === "(") {
          parenthesis++;
          i++;
        } else if (c === "[") {
          bracket++;
          i++;
        } else if (c === "{") {
          brace++;
          i++;
        } else if (c === ")") {
          parenthesis--;
          i++;
        } else if (c === "]") {
          bracket--;
          i++;
        } else if (c === "}") {
          brace--;
          i++;
        } else if (quote === null && !oldDotAffected && ((parenthesis === bracket && bracket === brace) && brace === 0)) {
          if (round === 0) {
            if (c === ":") {
              name = wishStr.substr(i + 1);
              wishStr = wishStr.substr(0, i);
              break;
            }
          } else if (round === 1) {
            s = wishStr.substr(i);
            if ((match = s.match(/^=([^]+)$/)) != null) {
              parsed = {
                type: "equal",
                components: [wishStr.substr(0, i), match[1]]
              };
              break;
            } else if ((match = s.match(/^<>([^]+)$/)) != null) {
              parsed = {
                type: "notEqual",
                components: [wishStr.substr(0, i), match[1]]
              };
              break;
            } else if ((match = s.match(/^\sis\s([^]+)$/)) != null) {
              parsed = {
                type: "is",
                components: [wishStr.substr(0, i), match[1]]
              };
              break;
            } else if ((match = s.match(/^\sisnt\s([^]+)$/)) != null) {
              parsed = {
                type: "isnt",
                components: [wishStr.substr(0, i), match[1]]
              };
              break;
            } else if ((match = s.match(/^\sthrows(?:\s([^]+))?$/)) != null) {
              parsed = {
                type: "throws",
                components: [wishStr.substr(0, i), match[1] != null ? match[1] : "undefined"]
              };
              break;
            } else if ((match = s.match(/^<=([^]+)$/)) != null) {
              parsed = {
                type: "lessThanOrEqual",
                components: [wishStr.substr(0, i), match[1]]
              };
              break;
            } else if ((match = s.match(/^>=([^]+)$/)) != null) {
              parsed = {
                type: "greaterThanOrEqual",
                components: [wishStr.substr(0, i), match[1]]
              };
              break;
            } else if ((match = s.match(/^<([^]+)$/)) != null) {
              parsed = {
                type: "lessThan",
                components: [wishStr.substr(0, i), match[1]]
              };
              break;
            } else if ((match = s.match(/^>([^]+)$/)) != null) {
              parsed = {
                type: "greaterThan",
                components: [wishStr.substr(0, i), match[1]]
              };
              break;
            }
          }
          i++;
        } else {
          i++;
        }
      }
      if (round === 1) {
        return parsed != null ? parsed : parsed = {
          type: "doesNotThrow",
          components: [wishStr]
        };
      }
    });
    parsed.components.push(JSON.stringify((name != null ? name : wishStr).trim()));
    return parsed;
  };

  wishlist.parseWishes = function(wishesStr) {
    var brace, bracket, c, i, lastIndex, oldSlashQuoteReady, parenthesis, positions, quote, r, s, slashQuoteReady;
    quote = null;
    parenthesis = 0;
    bracket = 0;
    brace = 0;
    slashQuoteReady = true;
    positions = [];
    i = 0;
    while (i < wishesStr.length) {
      c = wishesStr[i];
      oldSlashQuoteReady = slashQuoteReady;
      if (quote === null) {
        if (("a" <= c && c <= "z") || ("A" <= c && c <= "Z") || ("0" <= c && c <= "9") || c === "_" || c === "$" || c === ")" || c === "]") {
          slashQuoteReady = false;
        } else if (c === " " || c === "\t" || c === "\n" || c === "\r") {

        } else {
          slashQuoteReady = true;
        }
      }
      if (c === "\"" && quote === null) {
        quote = "double";
        i++;
      } else if (c === "'" && quote === null) {
        quote = "single";
        i++;
      } else if (c === "/" && quote === null && oldSlashQuoteReady) {
        quote = "slash";
        i++;
      } else if ((c === "\"" && quote === "double") || (c === "'" && quote === "single") || (c === "/" && quote === "slash")) {
        quote = null;
        i++;
      } else if (c === "\\" && quote !== null) {
        i += 2;
      } else if (c === "(") {
        parenthesis++;
        i++;
      } else if (c === "[") {
        bracket++;
        i++;
      } else if (c === "{") {
        brace++;
        i++;
      } else if (c === ")") {
        parenthesis--;
        i++;
      } else if (c === "]") {
        bracket--;
        i++;
      } else if (c === "}") {
        brace--;
        i++;
      } else if (quote === null && ((parenthesis === bracket && bracket === brace) && brace === 0) && c === ";") {
        positions.push(i);
        i++;
      } else {
        i++;
      }
    }
    r = [];
    lastIndex = -1;
    positions.forEach(function(index) {
      var s;
      s = wishesStr.substring(lastIndex + 1, index).trim();
      if (s !== "") {
        r.push(s);
      }
      return lastIndex = index;
    });
    s = wishesStr.substr(lastIndex + 1).trim();
    if (s !== "") {
      r.push(s);
    }
    return r;
  };

  wishlist.sha256 = function(str) {
    var Ch, H, K, M, Maj, N, ROTR, SHR, SIGMA0, SIGMA1, T1, T2, W, a, add, b, bytes, c, d, e, f, g, h, i, j, k, l, o, offset, p, paddedLength, q, ref, ref1, ref2, sigma0, sigma1, t, u, v, w, wordToString;
    if (str.length > Math.round(Math.pow(2, 31) - 1)) {
      throw new Error();
    }
    wordToString = function(n) {
      var i;
      return ((function() {
        var o, results;
        results = [];
        for (i = o = 7; o >= 0; i = --o) {
          results.push(((n >>> (i * 4)) % 16).toString(16));
        }
        return results;
      })()).join("");
    };
    add = function() {
      var arg, len, o, r;
      r = 0;
      for (o = 0, len = arguments.length; o < len; o++) {
        arg = arguments[o];
        r = (r + arg) % 0x100000000;
      }
      return r;
    };
    ROTR = function(x, n) {
      return x >>> n | x << (32 - n);
    };
    SHR = function(x, n) {
      return x >>> n;
    };
    Ch = function(x, y, z) {
      return (x & y) ^ (~x & z);
    };
    Maj = function(x, y, z) {
      return (x & y) ^ (x & z) ^ (y & z);
    };
    SIGMA0 = function(x) {
      return ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22);
    };
    SIGMA1 = function(x) {
      return ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25);
    };
    sigma0 = function(x) {
      return ROTR(x, 7) ^ ROTR(x, 18) ^ SHR(x, 3);
    };
    sigma1 = function(x) {
      return ROTR(x, 17) ^ ROTR(x, 19) ^ SHR(x, 10);
    };
    K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
    H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
    bytes = str.split("").map(function(m) {
      return m.charCodeAt(0);
    });
    l = str.length * 8;
    k = 448 - l - 1;
    while (k < 0) {
      k += 512;
    }
    paddedLength = l + 1 + k + 64;
    bytes.push(0x80);
    for (i = o = 0, ref = Math.round((k - 7) / 8); 0 <= ref ? o < ref : o > ref; i = 0 <= ref ? ++o : --o) {
      bytes.push(0);
    }
    bytes.push(0);
    bytes.push(0);
    bytes.push(0);
    bytes.push(0);
    bytes.push(l >>> 24);
    bytes.push((l >>> 16) % 256);
    bytes.push((l >>> 8) % 256);
    bytes.push(l % 256);
    N = Math.round(paddedLength / 512);
    M = new Array(N);
    for (i = p = 0, ref1 = N; 0 <= ref1 ? p < ref1 : p > ref1; i = 0 <= ref1 ? ++p : --p) {
      M[i] = new Array(16);
      for (j = q = 0; q < 16; j = ++q) {
        offset = i * 64 + j * 4;
        M[i][j] = (bytes[offset] << 24) | (bytes[offset + 1] << 16) | (bytes[offset + 2] << 8) | bytes[offset + 3];
      }
    }
    W = new Array(64);
    for (i = u = 0, ref2 = N; 0 <= ref2 ? u < ref2 : u > ref2; i = 0 <= ref2 ? ++u : --u) {
      for (t = v = 0; v < 64; t = ++v) {
        W[t] = t < 16 ? M[i][t] : add(sigma1(W[t - 2]), W[t - 7], sigma0(W[t - 15]), W[t - 16]);
      }
      a = H[0];
      b = H[1];
      c = H[2];
      d = H[3];
      e = H[4];
      f = H[5];
      g = H[6];
      h = H[7];
      for (t = w = 0; w < 64; t = ++w) {
        T1 = add(h, SIGMA1(e), Ch(e, f, g), K[t], W[t]);
        T2 = add(SIGMA0(a), Maj(a, b, c));
        h = g;
        g = f;
        f = e;
        e = add(d, T1);
        d = c;
        c = b;
        b = a;
        a = add(T1, T2);
      }
      H[0] = add(a, H[0]);
      H[1] = add(b, H[1]);
      H[2] = add(c, H[2]);
      H[3] = add(d, H[3]);
      H[4] = add(e, H[4]);
      H[5] = add(f, H[5]);
      H[6] = add(g, H[6]);
      H[7] = add(h, H[7]);
    }
    return H.map(function(m) {
      return wordToString(m);
    }).join("");
  };


  /*
  In `wishlist.Test`, the `wishes` property contains only separated wishes
  (i.e. not including those defined and checked in a test function), but
  the `wishResults` property includes results for all wishes.
  Test names can be duplicate. Wish names can also be duplicate.
  Restriction: On browser it doesn't work well with exceptional tests.
   */

  wishlist.Test = (function() {
    function Test(name1) {
      this.name = name1 != null ? name1 : "";
      this._children = [];
      this.fun = (function(_this) {
        return function() {};
      })(this);
      this.afterFun = (function(_this) {
        return function() {};
      })(this);
      this.wishes = [];
      this.async = false;
      this.parent = null;
      this.allCount = 1;
      this._resetContext();
    }

    Test.prototype._resetContext = function() {
      this.env = {};
      this.wishResults = [];
      this.result = null;
      return this.endedCount = 0;
    };

    Test.prototype.set = function() {
      var fun, name, normalizeWishes, options, rawWishes, wishes;
      name = fun = wishes = rawWishes = options = void 0;
      normalizeWishes = (function(_this) {
        return function(raw) {
          var combined;
          combined = Array.isArray(raw) ? raw.join(";") : typeof raw === "string" ? raw : "";
          return wishlist.parseWishes(combined);
        };
      })(this);
      if (typeof arguments[0] === "string") {
        name = arguments[0];
        fun = arguments[1];
        if (typeof arguments[2] === "object" && arguments[2] !== null && !Array.isArray(arguments[2])) {
          options = arguments[2];
        } else {
          rawWishes = arguments[2];
          options = arguments[3];
        }
      } else {
        fun = arguments[0];
        if (typeof arguments[1] === "object" && arguments[1] !== null && !Array.isArray(arguments[1])) {
          options = arguments[1];
        } else {
          rawWishes = arguments[1];
          options = arguments[2];
        }
      }
      wishes = normalizeWishes(rawWishes);
      if (options == null) {
        options = {};
      }
      if (name !== void 0) {
        this.name = name;
      }
      this.fun = fun;
      if (rawWishes !== void 0) {
        this.wishes = wishes;
      }
      if (options.async !== void 0) {
        this.async = options.async;
      }
      return this;
    };

    Test.prototype.setAsync = function() {
      var args, lastArg, len, m, o;
      args = [];
      for (o = 0, len = arguments.length; o < len; o++) {
        m = arguments[o];
        args.push(m);
      }
      lastArg = args[args.length - 1];
      if (typeof lastArg === "object" && lastArg !== null && !Array.isArray(lastArg)) {
        lastArg.async = true;
      } else {
        args.push({
          async: true
        });
      }
      return this.set.apply(this, args);
    };

    Test.prototype.after = function(afterFun) {
      this.afterFun = afterFun;
      return this;
    };

    Test.prototype.add = function() {
      var count, newChild;
      newChild = null;
      count = null;
      if (arguments[0] instanceof wishlist.Test) {
        newChild = arguments[0];
        count = newChild.getAll().length;
      } else {
        newChild = new wishlist.Test();
        newChild.set.apply(newChild, arguments);
        count = 1;
      }
      newChild.parent = this;
      this._children.push(newChild);
      this.getAncestorsAndSelf().forEach((function(_this) {
        return function(test) {
          return test.allCount += count;
        };
      })(this));
      return this;
    };

    Test.prototype.addAsync = function() {
      var args, lastArg, len, m, o;
      args = [];
      for (o = 0, len = arguments.length; o < len; o++) {
        m = arguments[o];
        args.push(m);
      }
      lastArg = args[args.length - 1];
      if (typeof lastArg === "object" && lastArg !== null && !Array.isArray(lastArg)) {
        lastArg.async = true;
      } else {
        args.push({
          async: true
        });
      }
      return this.add.apply(this, args);
    };

    Test.prototype.getChildren = function() {
      return this._children.slice(0);
    };

    Test.prototype.getAncestors = function() {
      var r, test;
      test = this;
      r = [];
      while (test.parent !== null) {
        r.push(test.parent);
        test = test.parent;
      }
      return r;
    };

    Test.prototype.getAncestorsAndSelf = function() {
      return [this].concat(this.getAncestors());
    };

    Test.prototype.getAll = function() {
      var r, traverse;
      r = [];
      r.push(this);
      traverse = (function(_this) {
        return function(test) {
          return test.getChildren().forEach(function(m) {
            r.push(m);
            return traverse(m);
          });
        };
      })(this);
      traverse(this);
      return r;
    };

    Test.prototype.run = function(isRoot) {
      var allTests, timer, timerJob;
      if (isRoot == null) {
        isRoot = true;
      }
      if (isRoot) {
        wishlist.currentRootTest = this;
      }
      this._resetContext();
      if (this.parent != null) {
        this.env = wishlist.objectClone(this.parent.env);
      }
      setTimeout((function(_this) {
        return function() {
          var domain;
          if (wishlist.environmentType === "node") {
            domain = require("domain").create();
            domain.on("error", function(error) {
              return _this.end({
                type: false,
                errorMessage: "Error Name: " + error.name + "\nError Message: " + error.message + "\nError Stack: " + error.stack
              });
            });
            return domain.run(function() {
              return process.nextTick(function() {
                _this.fun(_this.env, _this);
                if ((_this.result == null) && !_this.async) {
                  return _this.end({
                    type: true
                  });
                }
              });
            });
          } else {
            try {
              _this.fun(_this.env, _this);
              if ((_this.result == null) && !_this.async) {
                return _this.end({
                  type: true
                });
              }
            } catch (_error) {
              return _this.end({
                type: false
              });
            }
          }
        };
      })(this), 0);
      if (isRoot) {
        allTests = this.getAll();
        console.log();
        timerJob = (function(_this) {
          return function() {
            var exceptionTests, failureCount, mark, markString, okTests, pendingTests, successCount;
            okTests = allTests.filter(function(m) {
              return (m.result != null) && m.result.type === true;
            });
            exceptionTests = allTests.filter(function(m) {
              return (m.result != null) && m.result.type === false;
            });
            pendingTests = allTests.filter(function(m) {
              return m.result == null;
            });
            console.log(((new Date().toISOString()) + " OK: " + okTests.length + ", ") + ("Exception: " + exceptionTests.length + ", Pending: " + pendingTests.length));
            if (pendingTests.length === 0) {
              clearInterval(timer);
              exceptionTests.forEach(function(m) {
                console.log("\n********** Exceptional Test **********");
                console.log("Test: " + m.name);
                console.log("Function: " + (m.fun.toString()));
                if (m.result.errorMessage != null) {
                  return console.log(m.result.errorMessage);
                }
              });
              failureCount = 0;
              successCount = 0;
              markString = "";
              allTests.forEach(function(m) {
                return m.wishResults.forEach(function(n) {
                  var ancestors, longName;
                  markString += " " + n.type.toString();
                  if (n.type === false) {
                    failureCount++;
                    ancestors = m.getAncestors();
                    ancestors.reverse();
                    longName = ancestors.concat([m]).map(function(m) {
                      return m.name;
                    }).join(" --> ");
                    console.log("\n********** Broken Wish **********");
                    console.log("    Test: " + longName);
                    console.log("    Wish: " + n.name);
                    console.log("Expected: " + n.expected);
                    return console.log("  Actual: " + n.actual);
                  } else {
                    return successCount++;
                  }
                });
              });
              markString = markString.trim();
              mark = wishlist.sha256(markString).substr(0, 5);
              console.log("\n" + ((exceptionTests.length === 0 ? "Tests OK." : exceptionTests.length + " tests of " + allTests.length + " exceptional.") + " " + (failureCount === 0 ? "Wishes fulfilled." : failureCount + " wishes of " + (failureCount + successCount) + " broken.") + " " + ("Mark: " + mark)) + "\n");
              return wishlist.currentRootTest = null;
            }
          };
        })(this);
        timer = setInterval(timerJob, 1000);
        setTimeout(timerJob, 10);
      }
      return this;
    };

    Test.prototype.end = function(result) {
      if (this.result == null) {
        this.result = result != null ? result : {
          type: true
        };
        this.wishes.forEach((function(_this) {
          return function(m) {
            return _this._checkWish(m);
          };
        })(this));
        this.getAncestorsAndSelf().forEach((function(_this) {
          return function(test) {
            test.endedCount++;
            if (test.endedCount === test.allCount) {
              return test._tryCallFun(function() {
                return test.afterFun(test.env);
              });
            }
          };
        })(this));
        this.getChildren().forEach((function(_this) {
          return function(m) {
            return m.run(false);
          };
        })(this));
      }
      return this;
    };

    Test.prototype._tryCallFun = function(fun) {
      var domain;
      if (wishlist.environmentType === "node") {
        domain = require("domain").create();
        domain.on("error", (function(_this) {
          return function(error) {
            return console.log(error.stack);
          };
        })(this));
        return domain.run((function(_this) {
          return function() {
            return process.nextTick(fun);
          };
        })(this));
      } else {
        try {
          return fun();
        } catch (_error) {
          return console.log("Error!");
        }
      }
    };

    Test.prototype._checkWish = function(wishStr) {
      var args, interpret, name, parsed, result, that;
      that = this;
      interpret = (function(_this) {
        return function(s) {
          wishlist.parseExpression(s, Object.keys(_this.env)).forEach(function(m, index) {
            var insertedString, pos;
            insertedString = "that.env.";
            pos = m + insertedString.length * index;
            return s = s.substr(0, pos) + insertedString + s.substr(pos);
          });
          return s;
        };
      })(this);
      parsed = wishlist.parseWish(wishStr);
      args = parsed.components.map((function(_this) {
        return function(m, index) {
          if (index === parsed.components.length - 1) {
            return m;
          } else {
            return interpret(m);
          }
        };
      })(this));
      name = JSON.parse(args[args.length - 1]);
      result = (function() {
        try {
          args = args.map((function(_this) {
            return function(m) {
              return eval("((" + m + "))");
            };
          })(this));
          return this["_check_" + parsed.type].apply(this, args);
        } catch (_error) {
          return {
            type: false,
            name: name,
            actual: "unknown",
            expected: "unknown"
          };
        }
      }).call(this);
      return this.wishResults.push(result);
    };

    Test.prototype.wish = function(wishesStr) {
      return wishlist.parseWishes(wishesStr).forEach((function(_this) {
        return function(wishStr) {
          return _this._checkWish(wishStr);
        };
      })(this));
    };

    return Test;

  })();

  wishlist.Test.prototype._check_equal = function(actual, ruler, name) {
    var determine, objects, result;
    if (name == null) {
      name = "";
    }
    objects = [];
    determine = (function(_this) {
      return function(actual, ruler) {
        if (Array.isArray(actual) && Array.isArray(ruler)) {
          if (actual.length === ruler.length && ruler.every(function(m, index) {
            if (indexOf.call(objects, m) >= 0) {
              return wishlist.objectIs(actual[index], m);
            } else {
              if (typeof m === "object" && m !== null) {
                objects.push(m);
              }
              return determine(actual[index], m);
            }
          })) {
            return true;
          } else {
            return false;
          }
        } else if (typeof actual === "object" && actual !== null && typeof ruler === "object" && ruler !== null) {
          if (wishlist.hasSameKeys(actual, ruler) && Object.keys(ruler).every(function(m) {
            var ref;
            if (ref = ruler[m], indexOf.call(objects, ref) >= 0) {
              return wishlist.objectIs(actual[m], ruler[m]);
            } else {
              if (typeof ruler[m] === "object" && ruler[m] !== null) {
                objects.push(ruler[m]);
              }
              return determine(actual[m], ruler[m]);
            }
          })) {
            return true;
          } else {
            return false;
          }
        } else {
          return wishlist.objectIs(actual, ruler);
        }
      };
    })(this);
    result = {
      type: determine(actual, ruler),
      name: name
    };
    if (result.type === false) {
      result.actual = wishlist.valueToMessage(actual);
      result.expected = "= " + wishlist.valueToMessage(ruler);
    }
    return result;
  };

  wishlist.Test.prototype._check_notEqual = function(actual, ruler, name) {
    var determine, objects, result;
    if (name == null) {
      name = "";
    }
    objects = [];
    determine = (function(_this) {
      return function(actual, ruler) {
        if (Array.isArray(actual) && Array.isArray(ruler)) {
          if (actual.length !== ruler.length || ruler.some(function(m, index) {
            if (indexOf.call(objects, m) >= 0) {
              return !wishlist.objectIs(actual[index], m);
            } else {
              if (typeof m === "object" && m !== null) {
                objects.push(m);
              }
              return determine(actual[index], m);
            }
          })) {
            return true;
          } else {
            return false;
          }
        } else if (typeof actual === "object" && actual !== null && typeof ruler === "object" && ruler !== null) {
          if (!wishlist.hasSameKeys(actual, ruler) || Object.keys(ruler).some(function(m) {
            var ref;
            if (ref = ruler[m], indexOf.call(objects, ref) >= 0) {
              return !wishlist.objectIs(actual[m], ruler[m]);
            } else {
              if (typeof ruler[m] === "object" && ruler[m] !== null) {
                objects.push(ruler[m]);
              }
              return determine(actual[m], ruler[m]);
            }
          })) {
            return true;
          } else {
            return false;
          }
        } else {
          return !wishlist.objectIs(actual, ruler);
        }
      };
    })(this);
    result = {
      type: determine(actual, ruler),
      name: name
    };
    if (result.type === false) {
      result.actual = wishlist.valueToMessage(actual);
      result.expected = " " + wishlist.valueToMessage(ruler);
    }
    return result;
  };

  wishlist.Test.prototype._check_is = function(actual, ruler, name) {
    var result;
    if (name == null) {
      name = "";
    }
    result = {
      type: wishlist.objectIs(actual, ruler),
      name: name
    };
    if (result.type === false) {
      result.actual = wishlist.valueToMessage(actual);
      result.expected = "is " + wishlist.valueToMessage(ruler);
    }
    return result;
  };

  wishlist.Test.prototype._check_isnt = function(actual, ruler, name) {
    var result;
    if (name == null) {
      name = "";
    }
    result = {
      type: !wishlist.objectIs(actual, ruler),
      name: name
    };
    if (result.type === false) {
      result.actual = wishlist.valueToMessage(actual);
      result.expected = "isn't " + wishlist.valueToMessage(ruler);
    }
    return result;
  };

  wishlist.Test.prototype._check_throws = function(fun, ruler, name) {
    var error, passed, result, resultType;
    if (name == null) {
      name = "";
    }
    passed = false;
    resultType = (function() {
      try {
        fun();
        passed = true;
        return false;
      } catch (_error) {
        error = _error;
        if (ruler == null) {
          return true;
        } else if (ruler instanceof RegExp) {
          if (ruler.test(error.message)) {
            return true;
          } else {
            return false;
          }
        } else {
          if (error instanceof ruler) {
            return true;
          } else {
            return false;
          }
        }
      }
    })();
    result = {
      type: resultType,
      name: name
    };
    if (result.type === false) {
      result.actual = passed ? "no exception" : "another exception";
      result.expected = passed ? "exception" : "an exception";
    }
    return result;
  };

  wishlist.Test.prototype._check_doesNotThrow = function(fun, name) {
    var result, resultType;
    if (name == null) {
      name = "";
    }
    resultType = (function() {
      try {
        fun();
        return true;
      } catch (_error) {
        return false;
      }
    })();
    result = {
      type: resultType,
      name: name
    };
    if (result.type === false) {
      result.actual = "exception";
      result.expected = "no exception";
    }
    return result;
  };

  wishlist.Test.prototype._check_lessThan = function(actual, ruler, name) {
    var result;
    if (name == null) {
      name = "";
    }
    result = {
      type: actual < ruler,
      name: name
    };
    if (result.type === false) {
      result.actual = wishlist.valueToMessage(actual);
      result.expected = "< " + wishlist.valueToMessage(ruler);
    }
    return result;
  };

  wishlist.Test.prototype._check_lessThanOrEqual = function(actual, ruler, name) {
    var result;
    if (name == null) {
      name = "";
    }
    result = {
      type: actual <= ruler,
      name: name
    };
    if (result.type === false) {
      result.actual = wishlist.valueToMessage(actual);
      result.expected = "<= " + wishlist.valueToMessage(ruler);
    }
    return result;
  };

  wishlist.Test.prototype._check_greaterThan = function(actual, ruler, name) {
    var result;
    if (name == null) {
      name = "";
    }
    result = {
      type: actual > ruler,
      name: name
    };
    if (result.type === false) {
      result.actual = wishlist.valueToMessage(actual);
      result.expected = "> " + wishlist.valueToMessage(ruler);
    }
    return result;
  };

  wishlist.Test.prototype._check_greaterThanOrEqual = function(actual, ruler, name) {
    var result;
    if (name == null) {
      name = "";
    }
    result = {
      type: actual >= ruler,
      name: name
    };
    if (result.type === false) {
      result.actual = wishlist.valueToMessage(actual);
      result.expected = ">= " + wishlist.valueToMessage(ruler);
    }
    return result;
  };

  if (wishlist.environmentType === "browser") {
    window.npmWishlist = wishlist;
  }

  if (wishlist.moduleSystem === "commonjs") {
    module.exports = wishlist;
  }

}).call(this);

// ***** ))) file end


}, nameIndexes: {}, result: initialModResult_674497323404793172}
    ];

    // This wrapper is to prevent naming conflicts.
    (function() {
        var initialModResult = initialModResult_674497323404793172;
        var mods = mods_674497323404793172;
        var run = function(index) {
            var mod = mods[index];
            var theExports = {};
            var theModule = {exports: theExports};
            var theRequire = function(name) {

                // half-way result, for caching & preventing infinite loops
                mod.result = theModule.exports;

                var newIndex = mod.nameIndexes[name];
                if (newIndex === undefined) {
                    throw new Error("Cannot find module " + JSON.stringify(name) + ".");
                }
                if (mods[newIndex].result === initialModResult) {
                    run(newIndex);
                }
                return mods[newIndex].result;
            };
            mod.fun.apply(theExports, [theExports, theModule, theRequire]);
            mod.result = theModule.exports; // for caching
        };
        run(0);
    })();
})();
