// Generated by CoffeeScript 1.7.1

/* @preserve
Mate
https://github.com/zhanzhenzhen/mate
(c) 2013 Zhenzhen Zhan
Mate may be freely distributed under the MIT license.
 */

(function() {
  var featureLoaders, npmMate,
    __indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  featureLoaders = [];

  npmMate = {};

  npmMate.testing = {};

  npmMate.environmentType = (typeof exports !== "undefined" && exports !== null) && ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) ? "node" : typeof window !== "undefined" && window !== null ? "browser" : void 0;

  npmMate.enableAllFeatures = function() {
    if (npmMate.environmentType === "browser") {
      window.global = window;
    }
    global.npmMate = npmMate;
    return featureLoaders.forEach(function(m) {
      return m();
    });
  };

  npmMate.testing.Test = (function() {
    function Test(description) {
      this.description = description != null ? description : "";
      this._children = [];
      this._fun = null;
      this._interpretedFunction = null;
      this._envFun = null;
      this.async = false;
      this.parent = null;
      this._resetContext();
    }

    Test.prototype._resetContext = function() {
      this.env = {};
      this.unitResults = [];
      return this.result = null;
    };

    Test.prototype.define = function(fun) {
      this._envFun = fun;
      return this;
    };

    Test.prototype.set = function(fun) {
      this._fun = fun;
      return this;
    };

    Test.prototype.get = function() {
      return this._fun;
    };

    Test.prototype._interpret = function() {
      var funStr_834942610148628375;
      funStr_834942610148628375 = null;
      (function(_this) {
        return (function() {
          var funStr, testArgName;
          funStr = _this._fun.toString();
          testArgName = "testArg_834942610148628375";
          funStr = funStr.replace(/\([^\)]*\)/, "(" + testArgName + ")");
          npmMate.testing.parseFunction(funStr).forEach(function(m, index) {
            var insertedString, pos;
            insertedString = testArgName + ".";
            pos = m + insertedString.length * index;
            return funStr = funStr.substr(0, pos) + insertedString + funStr.substr(pos);
          });
          funStr = funStr.replace(RegExp("" + testArgName + "\\.unit\\s*\\(\\s*(\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*')(?:\\s*,\\s*(\"(?:[^\"\\\\]|\\\\.)*\"|'(?:[^'\\\\]|\\\\.)*'))?\\s*\\)", "g"), function(match, p1, p2) {
            var args, description, parsed, unitStr;
            if (p2 === "") {
              p2 = void 0;
            }
            unitStr = eval(p1).trim();
            description = p2 != null ? p2 : JSON.stringify(unitStr);
            parsed = npmMate.testing.parseUnitString(unitStr);
            args = parsed.components;
            args.push(description);
            return "" + testArgName + "." + parsed.type + "(" + (args.join(', ')) + ")";
          });
          npmMate.testing.parseFunction(funStr, Object.keys(_this.env)).forEach(function(m, index) {
            var insertedString, pos;
            insertedString = testArgName + ".env.";
            pos = m + insertedString.length * index;
            return funStr = funStr.substr(0, pos) + insertedString + funStr.substr(pos);
          });
          funStr_834942610148628375 = funStr;
          return _this.async = funStr.indexOf("" + testArgName + ".finish") !== -1;
        });
      })(this)();
      this._interpretedFunction = eval("(" + funStr_834942610148628375 + ")");
      return this;
    };

    Test.prototype.add = function(description, fun) {
      var newChild;
      if (typeof description === "object") {
        newChild = description;
      } else {
        if (typeof description !== "string") {
          fun = description;
          description = "";
        }
        newChild = new npmMate.testing.Test(description).set(fun);
      }
      newChild.parent = this;
      this._children.push(newChild);
      return this;
    };

    Test.prototype.getChildren = function() {
      return this._children.slice(0);
    };

    Test.prototype.getAncestors = function() {
      var r, test;
      test = this;
      r = [];
      while (test.parent !== null) {
        r.push(test.parent);
        test = test.parent;
      }
      return r;
    };

    Test.prototype.run = function(showsMessage) {
      var allTests, timer, timerJob, traverse;
      if (showsMessage == null) {
        showsMessage = true;
      }
      this._resetContext();
      if (this.parent != null) {
        this.env = npmMate.testing.objectClone(this.parent.env);
      }
      if (typeof this._envFun === "function") {
        this._envFun(this.env);
      }
      if (this._fun != null) {
        this._interpret();
        setTimeout((function(_this) {
          return function() {
            var doTest, domain;
            doTest = function() {
              _this._interpretedFunction(_this);
              if (!_this.async) {
                return _this.finish({
                  type: true
                });
              }
            };
            if ((typeof exports !== "undefined" && exports !== null) && ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null)) {
              domain = require("domain").create();
              domain.on("error", function(error) {
                return _this.finish({
                  type: false,
                  errorMessage: "Error Name: " + error.name + "\nError Message: " + error.message + "\nError Stack: " + error.stack
                });
              });
              return domain.run(doTest);
            } else {
              try {
                return doTest();
              } catch (_error) {
                return _this.finish({
                  type: false
                });
              }
            }
          };
        })(this), 0);
      }
      this.getChildren().forEach((function(_this) {
        return function(m) {
          return m.run(false);
        };
      })(this));
      if (showsMessage) {
        allTests = [];
        if (this.get() != null) {
          allTests.push(this);
        }
        traverse = (function(_this) {
          return function(test) {
            return test.getChildren().forEach(function(m) {
              if (m.get() != null) {
                allTests.push(m);
              }
              return traverse(m);
            });
          };
        })(this);
        traverse(this);
        console.log();
        timerJob = (function(_this) {
          return function() {
            var exceptionTests, failureCount, mark, markString, okTests, pendingTests;
            okTests = allTests.filter(function(m) {
              return (m.result != null) && m.result.type === true;
            });
            exceptionTests = allTests.filter(function(m) {
              return (m.result != null) && m.result.type === false;
            });
            pendingTests = allTests.filter(function(m) {
              return m.result == null;
            });
            console.log(("" + (new Date().toISOString()) + " OK: " + okTests.length + ", ") + ("Exception: " + exceptionTests.length + ", Pending: " + pendingTests.length));
            if (pendingTests.length === 0) {
              clearInterval(timer);
              exceptionTests.forEach(function(m) {
                console.log("\n********** Exceptional Test **********");
                console.log("Test: " + m.description);
                console.log("Function: " + (m.get().toString()));
                if (m.result.errorMessage != null) {
                  return console.log(m.result.errorMessage);
                }
              });
              failureCount = 0;
              markString = "";
              allTests.forEach(function(m) {
                return m.unitResults.forEach(function(n) {
                  var ancestors, longDescription;
                  markString += " " + n.type.toString();
                  if (n.type === false) {
                    failureCount++;
                    ancestors = m.getAncestors();
                    ancestors.reverse();
                    longDescription = ancestors.concat([m]).map(function(m) {
                      return m.description;
                    }).join(" --> ");
                    console.log("\n********** Failed Unit **********");
                    console.log("    Test: " + longDescription);
                    console.log("    Unit: " + n.description);
                    console.log("Expected: " + n.expected);
                    return console.log("  Actual: " + n.actual);
                  }
                });
              });
              markString = markString.trim();
              mark = npmMate.testing.sha256(markString).substr(0, 5);
              console.log("\n" + (exceptionTests.length === 0 && failureCount === 0 ? "All tests are OK. All units succeeded." : ("" + exceptionTests.length + " Exceptional Tests, ") + ("" + failureCount + " Failed Units, ") + ("Mark: " + mark)) + "\n");
              if (typeof process !== "undefined" && process !== null) {
                return process.exit();
              }
            }
          };
        })(this);
        timer = setInterval(timerJob, 1000);
        setTimeout(timerJob, 0);
      }
      return this;
    };

    Test.prototype.finish = function(result) {
      this.result = result != null ? result : {
        type: true
      };
      return this;
    };

    Test.prototype.equal = function(actual, ruler, description) {
      var determine, newResult, objects;
      if (description == null) {
        description = "";
      }
      objects = [];
      determine = (function(_this) {
        return function(actual, ruler) {
          if (Array.isArray(actual) && Array.isArray(ruler)) {
            if (ruler.every(function(m, index) {
              if (__indexOf.call(objects, m) >= 0) {
                return npmMate.testing.objectIs(actual[index], m);
              } else {
                if (typeof m === "object" && m !== null) {
                  objects.push(m);
                }
                return determine(actual[index], m);
              }
            })) {
              return true;
            } else {
              return false;
            }
          } else if (typeof actual === "object" && actual !== null && typeof ruler === "object" && ruler !== null) {
            if (Object.keys(ruler).every(function(m) {
              var _ref;
              if (_ref = ruler[m], __indexOf.call(objects, _ref) >= 0) {
                return npmMate.testing.objectIs(actual[m], ruler[m]);
              } else {
                if (typeof ruler[m] === "object" && ruler[m] !== null) {
                  objects.push(ruler[m]);
                }
                return determine(actual[m], ruler[m]);
              }
            })) {
              return true;
            } else {
              return false;
            }
          } else {
            return npmMate.testing.objectIs(actual, ruler);
          }
        };
      })(this);
      newResult = {
        type: determine(actual, ruler),
        description: description
      };
      if (newResult.type === false) {
        newResult.actual = npmMate.testing.valueToMessage(actual);
        newResult.expected = "= " + npmMate.testing.valueToMessage(ruler);
      }
      this.unitResults.push(newResult);
      return this;
    };

    Test.prototype.notEqual = function(actual, ruler, description) {
      var determine, newResult, objects;
      if (description == null) {
        description = "";
      }
      objects = [];
      determine = (function(_this) {
        return function(actual, ruler) {
          if (Array.isArray(actual) && Array.isArray(ruler)) {
            if (ruler.some(function(m, index) {
              if (__indexOf.call(objects, m) >= 0) {
                return !npmMate.testing.objectIs(actual[index], m);
              } else {
                if (typeof m === "object" && m !== null) {
                  objects.push(m);
                }
                return determine(actual[index], m);
              }
            })) {
              return true;
            } else {
              return false;
            }
          } else if (typeof actual === "object" && actual !== null && typeof ruler === "object" && ruler !== null) {
            if (Object.keys(ruler).some(function(m) {
              var _ref;
              if (_ref = ruler[m], __indexOf.call(objects, _ref) >= 0) {
                return !npmMate.testing.objectIs(actual[m], ruler[m]);
              } else {
                if (typeof ruler[m] === "object" && ruler[m] !== null) {
                  objects.push(ruler[m]);
                }
                return determine(actual[m], ruler[m]);
              }
            })) {
              return true;
            } else {
              return false;
            }
          } else {
            return !npmMate.testing.objectIs(actual, ruler);
          }
        };
      })(this);
      newResult = {
        type: determine(actual, ruler),
        description: description
      };
      if (newResult.type === false) {
        newResult.actual = npmMate.testing.valueToMessage(actual);
        newResult.expected = "â‰  " + npmMate.testing.valueToMessage(ruler);
      }
      this.unitResults.push(newResult);
      return this;
    };

    Test.prototype.is = function(actual, ruler, description) {
      var newResult;
      if (description == null) {
        description = "";
      }
      newResult = {
        type: npmMate.testing.objectIs(actual, ruler),
        description: description
      };
      if (newResult.type === false) {
        newResult.actual = npmMate.testing.valueToMessage(actual);
        newResult.expected = "is " + npmMate.testing.valueToMessage(ruler);
      }
      this.unitResults.push(newResult);
      return this;
    };

    Test.prototype.isnt = function(actual, ruler, description) {
      var newResult;
      if (description == null) {
        description = "";
      }
      newResult = {
        type: !npmMate.testing.objectIs(actual, ruler),
        description: description
      };
      if (newResult.type === false) {
        newResult.actual = npmMate.testing.valueToMessage(actual);
        newResult.expected = "isn't " + npmMate.testing.valueToMessage(ruler);
      }
      this.unitResults.push(newResult);
      return this;
    };

    Test.prototype.throws = function(fun, ruler, description) {
      var error, newResult, passed, resultType;
      if (description == null) {
        description = "";
      }
      passed = false;
      resultType = (function() {
        try {
          fun();
          passed = true;
          return false;
        } catch (_error) {
          error = _error;
          if (ruler == null) {
            return true;
          } else if (ruler instanceof RegExp) {
            if (ruler.test(error.message)) {
              return true;
            } else {
              return false;
            }
          } else {
            if (error instanceof ruler) {
              return true;
            } else {
              return false;
            }
          }
        }
      })();
      newResult = {
        type: resultType,
        description: description
      };
      if (newResult.type === false) {
        newResult.actual = passed ? "no exception" : "another exception";
        newResult.expected = passed ? "exception" : "an exception";
      }
      this.unitResults.push(newResult);
      return this;
    };

    Test.prototype.doesNotThrow = function(fun, description) {
      var newResult, resultType;
      if (description == null) {
        description = "";
      }
      resultType = (function() {
        try {
          fun();
          return true;
        } catch (_error) {
          return false;
        }
      })();
      newResult = {
        type: resultType,
        description: description
      };
      if (newResult.type === false) {
        newResult.actual = "exception";
        newResult.expected = "no exception";
      }
      this.unitResults.push(newResult);
      return this;
    };

    return Test;

  })();

  npmMate.testing.objectIs = function(a, b) {
    if (typeof a === "number" && typeof b === "number") {
      if (a === 0 && b === 0) {
        return 1 / a === 1 / b;
      } else if (isNaN(a) && isNaN(b)) {
        return true;
      } else {
        return a === b;
      }
    } else {
      return a === b;
    }
  };

  npmMate.testing.objectClone = function(x) {
    var key, y, _i, _len, _ref;
    y = {};
    _ref = Object.keys(x);
    for (_i = 0, _len = _ref.length; _i < _len; _i++) {
      key = _ref[_i];
      y[key] = x[key];
    }
    return y;
  };

  npmMate.testing.valueToMessage = function(value) {
    var internal, r;
    internal = function(value, maxLevel) {
      if (value === void 0) {
        return "undefined";
      } else if (value === null) {
        return "null";
      } else if (Array.isArray(value)) {
        if (maxLevel > 0) {
          return "[" + value.map(function(m) {
            return internal(m, maxLevel - 1);
          }).join(",") + "]";
        } else {
          return "[Array]";
        }
      } else if (typeof value === "function") {
        return "[Function]";
      } else if (typeof value === "object") {
        if (maxLevel > 0) {
          return "{" + Object.keys(value).map(function(m) {
            return ("" + (JSON.stringify(m)) + ":") + internal(value[m], maxLevel - 1);
          }).join(",") + "}";
        } else {
          return "[Object]";
        }
      } else if (typeof value === "string") {
        return JSON.stringify(value.toString());
      } else if (typeof value === "number") {
        if (npmMate.testing.objectIs(value, -0)) {
          return "-0";
        } else {
          return value.toString();
        }
      } else {
        return value.toString();
      }
    };
    r = internal(value, 3);
    if (r.length > 1000) {
      r = internal(value, 2);
    }
    if (r.length > 1000) {
      r = internal(value, 1);
    }
    if (r.length > 1000) {
      r = internal(value, 0);
    }
    return r;
  };

  featureLoaders.push(function() {
    return global.Test = npmMate.testing.Test;
  });

  npmMate.testing.parseFunction = function(funStr, envNames) {
    var c, dotAffected, i, keywords, oldDotAffected, oldSlashQuoteReady, oldWordStarted, positions, quote, regex, s, slashQuoteReady, wordStarted;
    keywords = envNames != null ? envNames : ["finish", "unit"];
    if (keywords.length === 0) {
      return [];
    }
    regex = new RegExp("^(" + keywords.join("|") + ")[^a-zA-Z0-9_$]", "g");
    positions = [];
    quote = null;
    slashQuoteReady = true;
    wordStarted = false;
    dotAffected = false;
    i = 0;
    while (i < funStr.length) {
      c = funStr[i];
      oldSlashQuoteReady = slashQuoteReady;
      if (quote === null) {
        if (("a" <= c && c <= "z") || ("A" <= c && c <= "Z") || ("0" <= c && c <= "9") || c === "_" || c === "$" || c === ")" || c === "]") {
          slashQuoteReady = false;
        } else if (c === " " || c === "\t" || c === "\n" || c === "\r") {

        } else {
          slashQuoteReady = true;
        }
      }
      oldWordStarted = wordStarted;
      if (quote === null) {
        if (("a" <= c && c <= "z") || ("A" <= c && c <= "Z") || ("0" <= c && c <= "9") || c === "_" || c === "$" || c === ".") {
          wordStarted = true;
        } else {
          wordStarted = false;
        }
      }
      oldDotAffected = dotAffected;
      if (quote === null) {
        if (c === ".") {
          dotAffected = true;
        } else if (c === " " || c === "\t" || c === "\n" || c === "\r") {

        } else {
          dotAffected = false;
        }
      }
      if (c === "\"" && quote === null) {
        quote = "double";
        i++;
      } else if (c === "'" && quote === null) {
        quote = "single";
        i++;
      } else if (c === "/" && quote === null && oldSlashQuoteReady) {
        quote = "slash";
        i++;
      } else if ((c === "\"" && quote === "double") || (c === "'" && quote === "single") || (c === "/" && quote === "slash")) {
        quote = null;
        i++;
      } else if (c === "\\" && quote !== null) {
        i += 2;
      } else if (quote === null && !oldWordStarted && !oldDotAffected && ("a" <= c && c <= "z")) {
        s = funStr.substr(i, 31);
        if (s.search(regex) !== -1) {
          positions.push(i);
        }
        i++;
      } else {
        i++;
      }
    }
    return positions;
  };

  npmMate.testing.parseUnitString = function(unitStr) {
    var brace, bracket, c, dotAffected, i, match, oldDotAffected, oldSlashQuoteReady, parenthesis, parsed, quote, s, slashQuoteReady;
    parsed = null;
    quote = null;
    parenthesis = 0;
    bracket = 0;
    brace = 0;
    slashQuoteReady = true;
    dotAffected = false;
    i = 0;
    while (i < unitStr.length) {
      c = unitStr[i];
      oldSlashQuoteReady = slashQuoteReady;
      if (quote === null) {
        if (("a" <= c && c <= "z") || ("A" <= c && c <= "Z") || ("0" <= c && c <= "9") || c === "_" || c === "$" || c === ")" || c === "]") {
          slashQuoteReady = false;
        } else if (c === " " || c === "\t" || c === "\n" || c === "\r") {

        } else {
          slashQuoteReady = true;
        }
      }
      oldDotAffected = dotAffected;
      if (quote === null) {
        if (c === ".") {
          dotAffected = true;
        } else if (c === " " || c === "\t" || c === "\n" || c === "\r") {

        } else {
          dotAffected = false;
        }
      }
      if (c === "\"" && quote === null) {
        quote = "double";
        i++;
      } else if (c === "'" && quote === null) {
        quote = "single";
        i++;
      } else if (c === "/" && quote === null && oldSlashQuoteReady) {
        quote = "slash";
        i++;
      } else if ((c === "\"" && quote === "double") || (c === "'" && quote === "single") || (c === "/" && quote === "slash")) {
        quote = null;
        i++;
      } else if (c === "\\" && quote !== null) {
        i += 2;
      } else if (c === "(") {
        parenthesis++;
        i++;
      } else if (c === "[") {
        bracket++;
        i++;
      } else if (c === "{") {
        brace++;
        i++;
      } else if (c === ")") {
        parenthesis--;
        i++;
      } else if (c === "]") {
        bracket--;
        i++;
      } else if (c === "}") {
        brace--;
        i++;
      } else if (quote === null && !oldDotAffected && ((parenthesis === bracket && bracket === brace) && brace === 0)) {
        s = unitStr.substr(i);
        if ((match = s.match(/^=([^]+)$/)) != null) {
          parsed = {
            type: "equal",
            components: [unitStr.substr(0, i), match[1]]
          };
          break;
        } else if ((match = s.match(/^<>([^]+)$/)) != null) {
          parsed = {
            type: "notEqual",
            components: [unitStr.substr(0, i), match[1]]
          };
          break;
        } else if ((match = s.match(/^\sis\s([^]+)$/)) != null) {
          parsed = {
            type: "is",
            components: [unitStr.substr(0, i), match[1]]
          };
          break;
        } else if ((match = s.match(/^\sisnt\s([^]+)$/)) != null) {
          parsed = {
            type: "isnt",
            components: [unitStr.substr(0, i), match[1]]
          };
          break;
        } else if ((match = s.match(/^\sthrows(?:\s([^]+))?$/)) != null) {
          parsed = {
            type: "throws",
            components: [unitStr.substr(0, i), match[1] != null ? match[1] : "undefined"]
          };
          break;
        }
        i++;
      } else {
        i++;
      }
    }
    if (parsed == null) {
      parsed = {
        type: "doesNotThrow",
        components: [unitStr]
      };
    }
    parsed.components = parsed.components.map(function(m) {
      return m.trim();
    });
    return parsed;
  };

  npmMate.testing.sha256 = function(str) {
    var Ch, H, K, M, Maj, N, ROTR, SHR, SIGMA0, SIGMA1, T1, T2, W, a, add, b, bytes, c, d, e, f, g, h, i, j, k, l, offset, paddedLength, sigma0, sigma1, t, wordToString, _i, _j, _k, _l, _m, _n, _ref;
    if (str.length > Math.round(Math.pow(2, 31) - 1)) {
      throw new Error();
    }
    wordToString = function(n) {
      var i;
      return ((function() {
        var _i, _results;
        _results = [];
        for (i = _i = 7; _i >= 0; i = --_i) {
          _results.push(((n >>> (i * 4)) % 16).toString(16));
        }
        return _results;
      })()).join("");
    };
    add = function() {
      var arg, r, _i, _len;
      r = 0;
      for (_i = 0, _len = arguments.length; _i < _len; _i++) {
        arg = arguments[_i];
        r = (r + arg) % 0x100000000;
      }
      return r;
    };
    ROTR = function(x, n) {
      return x >>> n | x << (32 - n);
    };
    SHR = function(x, n) {
      return x >>> n;
    };
    Ch = function(x, y, z) {
      return (x & y) ^ (~x & z);
    };
    Maj = function(x, y, z) {
      return (x & y) ^ (x & z) ^ (y & z);
    };
    SIGMA0 = function(x) {
      return ROTR(x, 2) ^ ROTR(x, 13) ^ ROTR(x, 22);
    };
    SIGMA1 = function(x) {
      return ROTR(x, 6) ^ ROTR(x, 11) ^ ROTR(x, 25);
    };
    sigma0 = function(x) {
      return ROTR(x, 7) ^ ROTR(x, 18) ^ SHR(x, 3);
    };
    sigma1 = function(x) {
      return ROTR(x, 17) ^ ROTR(x, 19) ^ SHR(x, 10);
    };
    K = [0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85, 0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];
    H = [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19];
    bytes = str.split("").map(function(m) {
      return m.charCodeAt(0);
    });
    l = str.length * 8;
    k = 448 - l - 1;
    while (k < 0) {
      k += 512;
    }
    paddedLength = l + 1 + k + 64;
    bytes.push(0x80);
    for (i = _i = 0, _ref = Math.round((k - 7) / 8); 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      bytes.push(0);
    }
    bytes.push(0);
    bytes.push(0);
    bytes.push(0);
    bytes.push(0);
    bytes.push(l >>> 24);
    bytes.push((l >>> 16) % 256);
    bytes.push((l >>> 8) % 256);
    bytes.push(l % 256);
    N = Math.round(paddedLength / 512);
    M = new Array(N);
    for (i = _j = 0; 0 <= N ? _j < N : _j > N; i = 0 <= N ? ++_j : --_j) {
      M[i] = new Array(16);
      for (j = _k = 0; _k < 16; j = ++_k) {
        offset = i * 64 + j * 4;
        M[i][j] = (bytes[offset] << 24) | (bytes[offset + 1] << 16) | (bytes[offset + 2] << 8) | bytes[offset + 3];
      }
    }
    W = new Array(64);
    for (i = _l = 0; 0 <= N ? _l < N : _l > N; i = 0 <= N ? ++_l : --_l) {
      for (t = _m = 0; _m < 64; t = ++_m) {
        W[t] = t < 16 ? M[i][t] : add(sigma1(W[t - 2]), W[t - 7], sigma0(W[t - 15]), W[t - 16]);
      }
      a = H[0];
      b = H[1];
      c = H[2];
      d = H[3];
      e = H[4];
      f = H[5];
      g = H[6];
      h = H[7];
      for (t = _n = 0; _n < 64; t = ++_n) {
        T1 = add(h, SIGMA1(e), Ch(e, f, g), K[t], W[t]);
        T2 = add(SIGMA0(a), Maj(a, b, c));
        h = g;
        g = f;
        f = e;
        e = add(d, T1);
        d = c;
        c = b;
        b = a;
        a = add(T1, T2);
      }
      H[0] = add(a, H[0]);
      H[1] = add(b, H[1]);
      H[2] = add(c, H[2]);
      H[3] = add(d, H[3]);
      H[4] = add(e, H[4]);
      H[5] = add(f, H[5]);
      H[6] = add(g, H[6]);
      H[7] = add(h, H[7]);
    }
    return H.map(function(m) {
      return wordToString(m);
    }).join("");
  };

  featureLoaders.push(function() {
    var ArrayLazyWrapper;
    ArrayLazyWrapper = (function() {
      function ArrayLazyWrapper(value, chainToCopy, itemToPush) {
        this._value = value;
        this._chain = (chainToCopy != null ? chainToCopy : []).slice(0);
        if (itemToPush != null) {
          this._chain.push(itemToPush);
        }
        Object.getter(this, "length", (function(_this) {
          return function() {
            return _this.force().length;
          };
        })(this));
      }

      ArrayLazyWrapper.prototype.force = function() {
        var m, n, _i, _len, _ref;
        n = this._value;
        _ref = this._chain;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          m = _ref[_i];
          n = m.fun.apply(n, m.args);
        }
        return n;
      };

      ArrayLazyWrapper.prototype.map = function() {
        return this._pushChain(Array.prototype.map, arguments);
      };

      ArrayLazyWrapper.prototype.filter = function() {
        return this._pushChain(Array.prototype.filter, arguments);
      };

      ArrayLazyWrapper.prototype.concat = function() {
        return this._pushChain(Array.prototype.concat, arguments);
      };

      ArrayLazyWrapper.prototype.portion = function() {
        return this._pushChain(Array.prototype.portion, arguments);
      };

      ArrayLazyWrapper.prototype.funSort = function() {
        return this._pushChain(Array.prototype.funSort, arguments);
      };

      ArrayLazyWrapper.prototype.funSortDescending = function() {
        return this._pushChain(Array.prototype.funSortDescending, arguments);
      };

      ArrayLazyWrapper.prototype.funReverse = function() {
        return this._pushChain(Array.prototype.funReverse, arguments);
      };

      ArrayLazyWrapper.prototype.except = function() {
        return this._pushChain(Array.prototype.except, arguments);
      };

      ArrayLazyWrapper.prototype.group = function() {
        return this._pushChain(Array.prototype.group, arguments);
      };

      ArrayLazyWrapper.prototype.flatten = function() {
        return this._pushChain(Array.prototype.flatten, arguments);
      };

      ArrayLazyWrapper.prototype.random = function() {
        return this._pushChain(Array.prototype.random, arguments);
      };

      ArrayLazyWrapper.prototype.some = function() {
        return this._unwrapAndDo(Array.prototype.some, arguments);
      };

      ArrayLazyWrapper.prototype.every = function() {
        return this._unwrapAndDo(Array.prototype.every, arguments);
      };

      ArrayLazyWrapper.prototype.isEmpty = function() {
        return this._unwrapAndDo(Array.prototype.isEmpty, arguments);
      };

      ArrayLazyWrapper.prototype.at = function() {
        return this._unwrapAndDo(Array.prototype.at, arguments);
      };

      ArrayLazyWrapper.prototype.atOrNull = function() {
        return this._unwrapAndDo(Array.prototype.atOrNull, arguments);
      };

      ArrayLazyWrapper.prototype.contains = function() {
        return this._unwrapAndDo(Array.prototype.contains, arguments);
      };

      ArrayLazyWrapper.prototype.first = function() {
        return this._unwrapAndDo(Array.prototype.first, arguments);
      };

      ArrayLazyWrapper.prototype.firstOrNull = function() {
        return this._unwrapAndDo(Array.prototype.firstOrNull, arguments);
      };

      ArrayLazyWrapper.prototype.last = function() {
        return this._unwrapAndDo(Array.prototype.last, arguments);
      };

      ArrayLazyWrapper.prototype.lastOrNull = function() {
        return this._unwrapAndDo(Array.prototype.lastOrNull, arguments);
      };

      ArrayLazyWrapper.prototype.single = function() {
        return this._unwrapAndDo(Array.prototype.single, arguments);
      };

      ArrayLazyWrapper.prototype.singleOrNull = function() {
        return this._unwrapAndDo(Array.prototype.singleOrNull, arguments);
      };

      ArrayLazyWrapper.prototype.withMax = function() {
        return this._unwrapAndDo(Array.prototype.withMax, arguments);
      };

      ArrayLazyWrapper.prototype.withMin = function() {
        return this._unwrapAndDo(Array.prototype.withMin, arguments);
      };

      ArrayLazyWrapper.prototype.max = function() {
        return this._unwrapAndDo(Array.prototype.max, arguments);
      };

      ArrayLazyWrapper.prototype.min = function() {
        return this._unwrapAndDo(Array.prototype.min, arguments);
      };

      ArrayLazyWrapper.prototype.sum = function() {
        return this._unwrapAndDo(Array.prototype.sum, arguments);
      };

      ArrayLazyWrapper.prototype.average = function() {
        return this._unwrapAndDo(Array.prototype.average, arguments);
      };

      ArrayLazyWrapper.prototype.median = function() {
        return this._unwrapAndDo(Array.prototype.median, arguments);
      };

      ArrayLazyWrapper.prototype.product = function() {
        return this._unwrapAndDo(Array.prototype.product, arguments);
      };

      ArrayLazyWrapper.prototype.randomOne = function() {
        return this._unwrapAndDo(Array.prototype.randomOne, arguments);
      };

      ArrayLazyWrapper.prototype._pushChain = function(fun, args) {
        return new ArrayLazyWrapper(this._value, this._chain, {
          fun: fun,
          args: args
        });
      };

      ArrayLazyWrapper.prototype._unwrapAndDo = function(fun, args) {
        return fun.apply(this.force(), args);
      };

      return ArrayLazyWrapper;

    })();
    Array._elementOrUseSelector = function(element, selector) {
      if (selector != null) {
        return selector(element);
      } else {
        return element;
      }
    };
    Array.prototype._numberToIndex = function(pos) {
      if ((0 < pos && pos < 1)) {
        return pos = Math.round(pos * (this.length - 1));
      } else {
        return pos;
      }
    };
    Array.prototype._numberToLength = function(pos) {
      if ((0 < pos && pos < 1)) {
        return pos = Math.round(pos * this.length);
      } else {
        return pos;
      }
    };
    Array.prototype.copy = function() {
      return this.slice(0);
    };
    Array.prototype.isEmpty = function() {
      return this.length === 0;
    };
    Array.prototype.lazy = function() {
      return new ArrayLazyWrapper(this);
    };
    Array.prototype.portion = function(startIndex, length, endIndex) {
      if (Number.isFraction(startIndex) || Number.isFraction(length) || Number.isFraction(endIndex)) {
        if (startIndex === 0) {
          startIndex = 0 + Number.EPSILON;
        }
        if (startIndex === 1) {
          startIndex = 1 - Number.EPSILON;
        }
        if (length === 0) {
          length = 0 + Number.EPSILON;
        }
        if (length === 1) {
          length = 1 - Number.EPSILON;
        }
        if (endIndex === 0) {
          endIndex = 0 + Number.EPSILON;
        }
        if (endIndex === 1) {
          endIndex = 1 - Number.EPSILON;
        }
      }
      startIndex = this._numberToIndex(startIndex);
      length = this._numberToLength(length);
      endIndex = this._numberToIndex(endIndex);
      return this.slice(startIndex, length != null ? startIndex + length : endIndex + 1);
    };
    Array.prototype.at = function(index) {
      index = this._numberToIndex(index);
      assert((0 <= index && index < this.length));
      return this[index];
    };
    Array.prototype.atOrNull = function(index) {
      try {
        return this.at(index);
      } catch (_error) {
        return null;
      }
    };
    Array.prototype.contains = function(value) {
      return __indexOf.call(this, value) >= 0;
    };
    Array.prototype.first = function(predicate) {
      var queryResult;
      queryResult = predicate != null ? this.filter(predicate) : this;
      return queryResult.at(0);
    };
    Array.prototype.firstOrNull = function(predicate) {
      try {
        return this.first(predicate);
      } catch (_error) {
        return null;
      }
    };
    Array.prototype.last = function(predicate) {
      var queryResult;
      queryResult = predicate != null ? this.filter(predicate) : this;
      return queryResult.at(queryResult.length - 1);
    };
    Array.prototype.lastOrNull = function(predicate) {
      try {
        return this.last(predicate);
      } catch (_error) {
        return null;
      }
    };
    Array.prototype.single = function(predicate) {
      var queryResult;
      queryResult = predicate != null ? this.filter(predicate) : this;
      assert(queryResult.length === 1);
      return queryResult.at(0);
    };
    Array.prototype.singleOrNull = function(predicate) {
      try {
        return this.single(predicate);
      } catch (_error) {
        return null;
      }
    };
    Array.prototype.withMax = function(selector) {
      return this.reduce((function(_this) {
        return function(a, b, index) {
          if (Array._elementOrUseSelector(a, selector) > Array._elementOrUseSelector(b, selector)) {
            return a;
          } else {
            return b;
          }
        };
      })(this));
    };
    Array.prototype.withMin = function(selector) {
      return this.reduce((function(_this) {
        return function(a, b, index) {
          if (Array._elementOrUseSelector(a, selector) < Array._elementOrUseSelector(b, selector)) {
            return a;
          } else {
            return b;
          }
        };
      })(this));
    };
    Array.prototype.max = function(selector) {
      return Array._elementOrUseSelector(this.withMax(selector), selector);
    };
    Array.prototype.min = function(selector) {
      return Array._elementOrUseSelector(this.withMin(selector), selector);
    };
    Array.prototype.sum = function(selector) {
      if (this.length === 1) {
        return Array._elementOrUseSelector(this.first(), selector);
      } else {
        return this.reduce((function(_this) {
          return function(a, b, index) {
            return (index === 1 ? Array._elementOrUseSelector(a, selector) : a) + Array._elementOrUseSelector(b, selector);
          };
        })(this));
      }
    };
    Array.prototype.average = function(selector) {
      return this.sum(selector) / this.length;
    };
    Array.prototype.median = function(selector) {
      var a, b, m, n, sorted;
      sorted = this.funSort(selector);
      a = sorted.at(0.5 - Number.EPSILON);
      b = sorted.at(0.5 + Number.EPSILON);
      m = Array._elementOrUseSelector(a, selector);
      n = Array._elementOrUseSelector(b, selector);
      return (m + n) / 2;
    };
    Array.prototype.product = function(selector) {
      if (this.length === 1) {
        return Array._elementOrUseSelector(this.first(), selector);
      } else {
        return this.reduce((function(_this) {
          return function(a, b, index) {
            return (index === 1 ? Array._elementOrUseSelector(a, selector) : a) * Array._elementOrUseSelector(b, selector);
          };
        })(this));
      }
    };
    Array.prototype.group = function(keySelector, valueSelector) {
      var comparedKey, elements, key, m, results, sorted, _i, _len;
      if (this.isEmpty()) {
        return [];
      }
      sorted = this.funSort(keySelector);
      results = [];
      comparedKey = Array._elementOrUseSelector(sorted.first(), keySelector);
      elements = [];
      for (_i = 0, _len = sorted.length; _i < _len; _i++) {
        m = sorted[_i];
        key = Array._elementOrUseSelector(m, keySelector);
        if (key !== comparedKey) {
          results.push([comparedKey, Array._elementOrUseSelector(elements, valueSelector)]);
          comparedKey = key;
          elements = [];
        }
        elements.push(m);
      }
      results.push([comparedKey, Array._elementOrUseSelector(elements, valueSelector)]);
      return results;
    };
    Array.prototype._sort = function(keySelector, isDescending) {
      return this.copy().sort((function(_this) {
        return function(a, b) {
          var a1, b1;
          a1 = Array._elementOrUseSelector(a, keySelector);
          b1 = Array._elementOrUseSelector(b, keySelector);
          if (a1 < b1) {
            if (isDescending) {
              return 1;
            } else {
              return -1;
            }
          } else if (a1 > b1) {
            if (isDescending) {
              return -1;
            } else {
              return 1;
            }
          } else {
            return 0;
          }
        };
      })(this));
    };
    Array.prototype.funSort = function(keySelector) {
      return this._sort(keySelector, false);
    };
    Array.prototype.funSortDescending = function(keySelector) {
      return this._sort(keySelector, true);
    };
    Array.prototype.funReverse = function() {
      return this.copy().reverse();
    };
    Array.prototype.except = function(array) {
      return this.filter(function(m) {
        return __indexOf.call(array, m) < 0;
      });
    };
    Array.prototype.flatten = function(level) {
      var canContinue, m, n, r, _i, _j, _len, _len1;
      if (level <= 0) {
        return fail();
      } else {
        r = [];
        canContinue = false;
        for (_i = 0, _len = this.length; _i < _len; _i++) {
          m = this[_i];
          if (Array.isArray(m)) {
            canContinue = true;
            for (_j = 0, _len1 = m.length; _j < _len1; _j++) {
              n = m[_j];
              r.push(n);
            }
          } else {
            r.push(m);
          }
        }
        if (canContinue) {
          if (level != null) {
            if (level === 1) {
              return r;
            } else {
              return r.flatten(level - 1);
            }
          } else {
            return r.flatten();
          }
        } else {
          return r;
        }
      }
    };
    Array.prototype.randomOne = function() {
      return this[Math.randomInt(this.length)];
    };
    Array.prototype.random = function(count) {
      return this.copy().takeRandom(count);
    };
    Array.prototype.takeRandomOne = function() {
      var index, r;
      index = Math.randomInt(this.length);
      r = this[index];
      this.removeAt(index);
      return r;
    };
    Array.prototype.takeRandom = function(count) {
      if (count == null) {
        count = this.length;
      }
      count = this._numberToLength(count);
      return repeat(count, (function(_this) {
        return function() {
          return _this.takeRandomOne();
        };
      })(this));
    };
    Array.prototype.removeAt = function(index) {
      this.splice(index, 1);
      return this;
    };
    Array.prototype.remove = function(element) {
      var index;
      index = this.indexOf(element);
      assert(index > -1);
      return this.removeAt(index);
    };
    Array.prototype.removeAll = function(element) {
      var index;
      while (true) {
        index = this.indexOf(element);
        if (index === -1) {
          break;
        }
        this.removeAt(index);
      }
      return this;
    };
    Array.prototype.removeMatch = function(predicate) {
      var index;
      index = this.findIndex(predicate);
      assert(index > -1);
      return this.removeAt(index);
    };
    return Array.prototype.removeAllMatch = function(predicate) {
      var index;
      while (true) {
        index = this.findIndex(predicate);
        if (index === -1) {
          break;
        }
        this.removeAt(index);
      }
      return this;
    };
  });

  featureLoaders.push(function() {
    if (Number.EPSILON === void 0) {
      Number.EPSILON = 2.2204460492503130808472633361816e-16;
    }
    if (Number.isInteger === void 0) {
      Number.isInteger = function(x) {
        return typeof x === "number" && isFinite(x) && x > -9007199254740992 && x < 9007199254740992 && Math.floor(x) === x;
      };
    }
    if (String.prototype.startsWith === void 0) {
      String.prototype.startsWith = function(s) {
        return this.indexOf(s) === 0;
      };
    }
    if (String.prototype.endsWith === void 0) {
      String.prototype.endsWith = function(s) {
        return this.lastIndexOf(s) === this.length - s.length;
      };
    }
    if (String.prototype.contains === void 0) {
      String.prototype.contains = function(s) {
        return this.indexOf(s) !== -1;
      };
    }
    if (Object.is === void 0) {
      Object.is = npmMate.testing.objectIs;
    }
    if (Array.from === void 0) {
      Array.from = function(arrayLike) {
        var m, _i, _len, _results;
        _results = [];
        for (_i = 0, _len = arrayLike.length; _i < _len; _i++) {
          m = arrayLike[_i];
          _results.push(m);
        }
        return _results;
      };
    }
    if (Array.prototype.find === void 0) {
      Array.prototype.find = function(predicate) {
        var found;
        assert(typeof predicate === "function");
        found = this.filter(predicate);
        if (!found.isEmpty()) {
          return found.at(0);
        } else {
          return void 0;
        }
      };
    }
    if (Array.prototype.findIndex === void 0) {
      Array.prototype.findIndex = function(predicate) {
        var element;
        element = this.find(predicate);
        if (element === void 0) {
          return -1;
        } else {
          return this.indexOf(element);
        }
      };
    }
    if (Math.sign === void 0) {
      Math.sign = function(x) {
        if (typeof x === "number") {
          if (x === 0) {
            return 0;
          } else if (x > 0) {
            return 1;
          } else if (x < 0) {
            return -1;
          } else {
            return NaN;
          }
        } else {
          return NaN;
        }
      };
    }
    if (global.setImmediate === void 0) {
      global.setImmediate = function(callback, args) {
        return setTimeout(callback, 0, args);
      };
    }
    if (global.clearImmediate === void 0) {
      return global.clearImmediate = clearTimeout;
    }
  });

  featureLoaders.push(function() {
    global.compose = function(functions) {
      if (arguments.length > 1) {
        functions = Array.from(arguments);
      }
      return function() {
        var args, m, _i, _len;
        args = arguments;
        for (_i = 0, _len = functions.length; _i < _len; _i++) {
          m = functions[_i];
          args = [m.apply(this, args)];
        }
        return args[0];
      };
    };
    global.fail = function(errorMessage) {
      throw new Error(errorMessage);
    };
    global.assert = function(condition, message) {
      if (!condition) {
        return fail(message);
      }
    };
    global.repeat = function(iterator, times) {
      var i, _i, _ref, _results;
      if (typeof iterator === "number") {
        _ref = [iterator, times], times = _ref[0], iterator = _ref[1];
      }
      _results = [];
      for (i = _i = 0; 0 <= times ? _i < times : _i > times; i = 0 <= times ? ++_i : --_i) {
        _results.push(iterator());
      }
      return _results;
    };
    global.spread = function(value, count) {
      var i, _i, _results;
      _results = [];
      for (i = _i = 0; 0 <= count ? _i < count : _i > count; i = 0 <= count ? ++_i : --_i) {
        _results.push(value);
      }
      return _results;
    };
    Object.getter = function(obj, prop, fun) {
      return Object.defineProperty(obj, prop, {
        get: fun,
        configurable: true
      });
    };
    Object.setter = function(obj, prop, fun) {
      return Object.defineProperty(obj, prop, {
        set: fun,
        configurable: true
      });
    };
    Object.clone = function(x) {
      var key, y, _i, _len, _ref;
      y = {};
      _ref = Object.keys(x);
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        y[key] = x[key];
      }
      return y;
    };
    JSON.clone = function(x) {
      return JSON.parse(JSON.stringify(x));
    };
    String.prototype.matches = function(regex) {
      var adjustedRegex, match, result;
      adjustedRegex = new RegExp(regex.source, "g");
      result = [];
      while (true) {
        match = adjustedRegex.exec(this);
        if (match != null) {
          result.push(match);
        } else {
          break;
        }
      }
      return result;
    };
    String.prototype.capitalize = function() {
      return this.charAt(0).toUpperCase() + this.substr(1);
    };
    Date.prototype.add = function(x) {
      return new Date(this - (-x));
    };
    Date.prototype.subtract = function(x) {
      if (typeof x === "number") {
        return new Date(this - x);
      } else {
        return this - x;
      }
    };
    Date.prototype.equals = function(x) {
      return (x <= this && this <= x);
    };
    console.logt = function() {
      return console.log.apply(console, [new Date().toISOString()].concat(Array.from(arguments)));
    };
    global.eventField = function() {
      var f;
      f = function(method, arg) {
        if (typeof method === "function") {
          arg = method;
          method = "bind";
        }
        assert(typeof method === "string");
        f[method](arg);
        return this;
      };
      f._listeners = [];
      f.bind = function(listener) {
        if (__indexOf.call(f._listeners, listener) < 0) {
          f._listeners.push(listener);
        }
        return f;
      };
      f.unbind = function(listener) {
        f._listeners.removeAll(listener);
        return f;
      };
      f.fire = function(arg) {
        var m, _i, _len, _ref;
        _ref = f._listeners;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          m = _ref[_i];
          if (arg != null ? arg.blocksListeners : void 0) {
            break;
          }
          m(arg);
        }
        return void 0;
      };
      return f;
    };
    return global.EventedObject = (function() {
      function EventedObject() {
        this._eventList = {};
      }

      EventedObject.prototype.on = function(eventName, listener) {
        var _base;
        if ((_base = this._eventList)[eventName] == null) {
          _base[eventName] = [];
        }
        if (__indexOf.call(this._eventList[eventName], listener) < 0) {
          this._eventList[eventName].push(listener);
        }
        return this;
      };

      EventedObject.prototype.off = function(eventName, listener) {
        this._eventList[eventName].removeAll(listener);
        return this;
      };

      EventedObject.prototype.fire = function(eventName, arg) {
        var m, _base, _i, _len, _ref;
        if ((_base = this._eventList)[eventName] == null) {
          _base[eventName] = [];
        }
        _ref = this._eventList[eventName];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          m = _ref[_i];
          m(arg);
        }
        return void 0;
      };

      EventedObject.prototype.listeners = function(eventName) {
        return this._eventList[eventName];
      };

      return EventedObject;

    })();
  });

  featureLoaders.push(function() {
    Math.nearlyEquals = function(a, b) {
      var threshold, _ref;
      threshold = 1 + 1 / 65536;
      return (1 / threshold < (_ref = a / b) && _ref < threshold);
    };
    Math.nearlyGreaterThan = function(a, b) {
      return a > b || Math.nearlyEquals(a, b);
    };
    Math.nearlyLessThan = function(a, b) {
      return a < b || Math.nearlyEquals(a, b);
    };
    Math.radiansToDegrees = function(radians) {
      return radians / Math.PI * 180;
    };
    Math.degreesToRadians = function(degrees) {
      return degrees / 180 * Math.PI;
    };
    Math.principalRadians = function(radians) {
      var t;
      t = radians % (2 * Math.PI);
      if (t <= -Math.PI) {
        return t + 2 * Math.PI;
      } else if (t > Math.PI) {
        return t - 2 * Math.PI;
      } else {
        return t;
      }
    };
    Math.principalDegrees = function(degrees) {
      var t;
      t = degrees % 360;
      if (t <= -180) {
        return t + 360;
      } else if (t > 180) {
        return t - 360;
      } else {
        return t;
      }
    };
    Math.randomNumber = function(m, n) {
      if (m < n) {
        return m + Math.random() * (n - m);
      } else {
        return fail();
      }
    };
    Math.randomInt = function(m, n) {
      var max, min;
      min = n === void 0 ? 0 : m;
      max = n === void 0 ? m : n;
      return Math.floor(Math.randomNumber(min, max));
    };
    Number.isFraction = function(x) {
      return typeof x === "number" && isFinite(x) && Math.floor(x) !== x;
    };
    Number.parseFloatExt = function(s) {
      return parseFloat(s) * (s.endsWith("%") ? 0.01 : 1);
    };
    Number.prototype.nearlyEquals = function(x) {
      return Math.nearlyEquals(this, x);
    };
    Number.prototype.nearlyGreaterThan = function(x) {
      return Math.nearlyGreaterThan(this, x);
    };
    Number.prototype.nearlyLessThan = function(x) {
      return Math.nearlyLessThan(this, x);
    };
    global.Point = (function() {
      function Point(x, y) {
        this.x = x;
        this.y = y;
      }

      Point.from = function(value) {
        if (typeof value === "number") {
          return new Point(value, 0);
        } else if (value instanceof Point) {
          return value.clone();
        } else if (typeof value === "string") {
          return Point.fromString(value);
        } else if (Array.isArray(value)) {
          return Point.fromArray(value);
        } else {
          return fail();
        }
      };

      Point.fromArray = function(array) {
        return new Point(array[0], array[1]);
      };

      Point.fromString = function(s) {
        var adjustedString, complexMatch, imaginary, normalMatch, real, _ref, _ref1;
        adjustedString = s.replace(/[\x20()]/g, "");
        normalMatch = adjustedString.match(/^([^,]*),(.*)$/);
        if (normalMatch != null) {
          return new Point(Number.parseFloatExt(normalMatch[1]), Number.parseFloatExt(normalMatch[2]));
        } else {
          complexMatch = adjustedString.match(/^([+-]?[0-9]*\.?[0-9]*(?:[Ee][+-]?[0-9]+)?(?![i0-9Ee.]))?(?:([+-]?[0-9]*\.?[0-9]*(?:[Ee][+-]?[0-9]+)?)i)?$/);
          if (complexMatch != null) {
            real = (_ref = complexMatch[1]) != null ? _ref : "0";
            imaginary = (_ref1 = complexMatch[2]) != null ? _ref1 : "0";
            if (real === "") {
              real = "1";
            }
            if (imaginary === "") {
              imaginary = "1";
            }
            if (real === "+") {
              real = "1";
            }
            if (imaginary === "+") {
              imaginary = "1";
            }
            if (real === "-") {
              real = "-1";
            }
            if (imaginary === "-") {
              imaginary = "-1";
            }
            return new Point(parseFloat(real), parseFloat(imaginary));
          } else {
            return fail();
          }
        }
      };

      Point.fromPolar = function(r, angle) {
        return new Point(r * Math.cos(angle), r * Math.sin(angle));
      };

      Point.fromPolarInDegrees = function(r, angle) {
        switch (Math.principalDegrees(angle)) {
          case 0:
            return new Point(r, 0);
          case 90:
            return new Point(0, r);
          case -90:
            return new Point(0, -r);
          case 180:
            return new Point(-r, 0);
          default:
            return Point.fromPolar(r, Math.degreesToRadians(angle));
        }
      };

      Point.prototype.real = function() {
        return this.x;
      };

      Point.prototype.imaginary = function() {
        return this.y;
      };

      Point.prototype.toString = function() {
        return "(" + this.x + "," + this.y + ")";
      };

      Point.prototype.toComplexString = function() {
        var sign;
        sign = this.y >= 0 ? "+" : "-";
        return "" + this.x + sign + (Math.abs(this.y)) + "i";
      };

      Point.prototype.clone = function() {
        return new Point(this.x, this.y);
      };

      Point.prototype.equals = function(p) {
        return cmath.equals(this, p);
      };

      Point.prototype.nearlyEquals = function(p) {
        return cmath.nearlyEquals(this, p);
      };

      Point.prototype.opposite = function() {
        return cmath.opposite(this);
      };

      Point.prototype.reciprocal = function() {
        return cmath.reciprocal(this);
      };

      Point.prototype.conjugate = function() {
        return cmath.conjugate(this);
      };

      Point.prototype.abs = function() {
        return cmath.abs(this);
      };

      Point.prototype.add = function(p) {
        return cmath.add(this, p);
      };

      Point.prototype.subtract = function(p) {
        return cmath.subtract(this, p);
      };

      Point.prototype.multiply = function(p) {
        return cmath.multiply(this, p);
      };

      Point.prototype.divide = function(p) {
        return cmath.divide(this, p);
      };

      Point.prototype.distance = function(p) {
        return cmath.distance(this, p);
      };

      Point.prototype.dotProduct = function(p) {
        p = Point.from(p);
        return this.x * p.x + this.y * p.y;
      };

      Point.prototype.crossProduct = function(p) {
        p = Point.from(p);
        return this.x * p.y - this.y * p.x;
      };

      Point.prototype.isOppositeTo = function(p) {
        return this.opposite().equals(p);
      };

      Point.prototype.phase = function() {
        return cmath.phase(this);
      };

      Point.prototype.phaseTo = function(p) {
        p = Point.from(p);
        return Math.principalRadians(p.phase() - this.phase());
      };

      Point.prototype.phaseInDegrees = function() {
        return cmath.phaseInDegrees(this);
      };

      Point.prototype.phaseInDegreesTo = function(p) {
        p = Point.from(p);
        return Math.principalDegrees(p.phaseInDegrees() - this.phaseInDegrees());
      };

      Point.prototype.scale = function(size) {
        size = Point.from(size);
        return new Point(this.x * size.x, this.y * size.y);
      };

      Point.prototype.rotate = function(angle) {
        return this.multiply(Point.fromPolar(1, angle));
      };

      Point.prototype.rotateDegrees = function(angle) {
        return this.multiply(Point.fromPolarInDegrees(1, angle));
      };

      return Point;

    })();
    return global.cmath = {
      equals: function(a, b) {
        a = Point.from(a);
        b = Point.from(b);
        return a.x === b.x && a.y === b.y;
      },
      nearlyEquals: function(a, b) {
        a = Point.from(a);
        b = Point.from(b);
        return a.x.nearlyEquals(b.x) && a.y.nearlyEquals(b.y);
      },
      opposite: function(p) {
        p = Point.from(p);
        return new Point(-p.x, -p.y);
      },
      reciprocal: function(p) {
        var n;
        p = Point.from(p);
        n = p.x * p.x + p.y * p.y;
        return new Point(p.x / n, -p.y / n);
      },
      conjugate: function(p) {
        p = Point.from(p);
        return new Point(p.x, -p.y);
      },
      abs: function(p) {
        p = Point.from(p);
        if (p.x === 0) {
          return Math.abs(p.y);
        } else if (p.y === 0) {
          return Math.abs(p.x);
        } else {
          return Math.sqrt(p.x * p.x + p.y * p.y);
        }
      },
      phase: function(p) {
        p = Point.from(p);
        return Math.atan2(p.y, p.x);
      },
      phaseInDegrees: function(p) {
        var d;
        p = Point.from(p);
        if (p.x === 0 && p.y === 0) {
          return 0;
        } else if (p.x === 0 && p.y > 0) {
          return 90;
        } else if (p.x === 0 && p.y < 0) {
          return -90;
        } else if (p.x > 0 && p.y === 0) {
          return 0;
        } else if (p.x < 0 && p.y === 0) {
          return 180;
        } else {
          d = Math.radiansToDegrees(cmath.phase(p));
          if (d <= -180) {
            return 180;
          } else {
            return d;
          }
        }
      },
      add: function(a, b) {
        a = Point.from(a);
        b = Point.from(b);
        return new Point(a.x + b.x, a.y + b.y);
      },
      subtract: function(a, b) {
        return cmath.add(a, cmath.opposite(b));
      },
      multiply: function(a, b) {
        a = Point.from(a);
        b = Point.from(b);
        return new Point(a.x * b.x - a.y * b.y, a.x * b.y + a.y * b.x);
      },
      divide: function(a, b) {
        return cmath.multiply(a, cmath.reciprocal(b));
      },
      distance: function(a, b) {
        return cmath.abs(cmath.subtract(a, b));
      },
      exp: function(p) {
        p = Point.from(p);
        return Point.fromPolar(Math.exp(p.x), p.y);
      },
      log: function(p) {
        return new Point(Math.log(cmath.abs(p)), cmath.phase(p));
      },
      pow: function(a, b) {
        return cmath.exp(cmath.multiply(cmath.log(a), b));
      },
      sqrt: function(p) {
        var r;
        p = Point.from(p);
        r = cmath.abs(p);
        return new Point(Math.sqrt((r + p.x) / 2), Math.sign(p.y) * Math.sqrt((r - p.x) / 2));
      },
      cos: function(p) {
        return cmath.divide(cmath.add(cmath.exp(cmath.multiply(p, new Point(0, 1))), cmath.exp(cmath.multiply(cmath.opposite(p), new Point(0, 1)))), 2);
      },
      sin: function(p) {
        return cmath.divide(cmath.subtract(cmath.exp(cmath.multiply(p, new Point(0, 1))), cmath.exp(cmath.multiply(cmath.opposite(p), new Point(0, 1)))), new Point(0, 2));
      },
      tan: function(p) {
        return cmath.divide(cmath.sin(p), cmath.cos(p));
      },
      acos: function(p) {
        return cmath.opposite(cmath.multiply(cmath.log(cmath.add(p, cmath.multiply(cmath.sqrt(cmath.add(cmath.opposite(cmath.multiply(p, p)), 1)), new Point(0, 1)))), new Point(0, 1)));
      },
      asin: function(p) {
        return cmath.opposite(cmath.multiply(cmath.log(cmath.add(cmath.multiply(p, new Point(0, 1)), cmath.sqrt(cmath.add(cmath.opposite(cmath.multiply(p, p)), 1)))), new Point(0, 1)));
      },
      atan: function(p) {
        return cmath.multiply(cmath.subtract(cmath.log(cmath.subtract(1, cmath.multiply(p, new Point(0, 1)))), cmath.log(cmath.add(1, cmath.multiply(p, new Point(0, 1))))), new Point(0, 0.5));
      }
    };
  });

  featureLoaders.push(function() {
    Date.Timer = (function() {
      Timer._endOfTime = new Date("9999-12-30T00:00:00Z");

      function Timer(targetTime) {
        this.targetTime = targetTime != null ? targetTime : Date.Timer._endOfTime;
        this._counterValue = 0;
        this._internalTimer = null;
        this._running = false;
        this.allowsEqual = true;
        this.precision = 30;
        this.onArrive = eventField();
      }

      Timer.prototype.run = function() {
        if (this._running) {
          return;
        }
        this._counterValue = 0;
        this._internalTimer = setInterval((function(_this) {
          return function() {
            var lastTargetTime, nowTime;
            nowTime = new Date();
            if ((_this.allowsEqual ? nowTime >= _this.targetTime : nowTime > _this.targetTime)) {
              _this._counterValue++;
              lastTargetTime = _this.targetTime;
              _this.targetTime = Date.Timer._endOfTime;
              return _this.onArrive.fire({
                idealTime: lastTargetTime,
                nowTime: nowTime,
                index: _this._counterValue - 1
              });
            }
          };
        })(this), this.precision);
        this._running = true;
        return this;
      };

      Timer.prototype.stop = function() {
        if (!this._running) {
          return;
        }
        clearInterval(this._internalTimer);
        this._running = false;
        return this;
      };

      Timer.prototype.getRunning = function() {
        return this._running;
      };

      Timer.prototype.resetCounter = function() {
        return this._counterValue = 0;
      };

      Timer.prototype.getCounterValue = function() {
        return this._counterValue;
      };

      return Timer;

    })();
    return Date.IntervalTimer = (function(_super) {
      __extends(IntervalTimer, _super);

      function IntervalTimer(interval, startTime, endTime) {
        this.interval = interval != null ? interval : 1000;
        this.startTime = startTime != null ? startTime : new Date();
        this.endTime = endTime;
        IntervalTimer.__super__.constructor.call(this);
        this._started = false;
        this.includesStart = true;
        this.includesEnd = false;
        this.onStart = eventField();
        this.onArrive.bind((function(_this) {
          return function(event) {
            _this.targetTime = event.idealTime.add(_this.interval);
            if (!_this._started) {
              _this._started = true;
              if (!_this.includesStart) {
                _this.resetCounter();
                event.blocksListeners = true;
              }
              _this.onStart.fire();
            }
            if ((_this.endTime != null) && (_this.includesEnd ? _this.targetTime > _this.endTime : _this.targetTime >= _this.endTime)) {
              return _this.stop();
            }
          };
        })(this));
      }

      IntervalTimer.prototype.run = function() {
        if (this.getRunning()) {
          return;
        }
        this.targetTime = this.startTime;
        return IntervalTimer.__super__.run.call(this);
      };

      return IntervalTimer;

    })(Date.Timer);
  });

  if (npmMate.environmentType === "browser") {
    window.npmMate = npmMate;
  } else if (npmMate.environmentType === "node") {
    module.exports = npmMate;
  } else {
    throw new Error();
  }

  npmMate.packageInfo = {
    "name": "mate",
    "version": "0.7.0",
    "description": "New concept testing, array extensions, ES6 shim, etc. Small but all in one.",
    "keywords": ["test", "unit", "testing", "event", "coffeescript", "timer", "math", "javascript", "es6", "js", "coffee"],
    "author": "Zhenzhen Zhan <zhanzhenzhen@hotmail.com>",
    "homepage": "https://github.com/zhanzhenzhen/mate",
    "licenses": [
      {
        "type": "MIT",
        "url": "https://github.com/zhanzhenzhen/mate/blob/master/LICENSE.txt"
      }
    ],
    "repository": {
      "type": "git",
      "url": "https://github.com/zhanzhenzhen/mate.git"
    },
    "devDependencies": {
      "coffee-script": "1.7.1",
      "uglify-js": "2.4.13"
    },
    "main": "mate"
  };

}).call(this);
